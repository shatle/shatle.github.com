<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: es6 | Liu.Shatle]]></title>
  <link href="http://shatle.github.io/blog/categories/es6/atom.xml" rel="self"/>
  <link href="http://shatle.github.io/"/>
  <updated>2018-02-17T23:53:13+08:00</updated>
  <id>http://shatle.github.io/</id>
  <author>
    <name><![CDATA[liu.shatle &hearts; gmail.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: The Future]]></title>
    <link href="http://shatle.github.io/blog/2016/03/20/es6-in-depth-the-future/"/>
    <updated>2016-03-20T17:03:15+08:00</updated>
    <id>http://shatle.github.io/blog/2016/03/20/es6-in-depth-the-future</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-the-future/">ES6 In Depth: The Future</a></p></blockquote>

<p>上周的ES6模块结束了为期四个多月的ES6新特性的这一系列的文章。</p>

<p>这文章主要会包括我们之前未讨论过的众多新特性，它们就如这JS语言大厦中的衣柜和奇怪的房子都是十分有趣的，也许还会一个地下室，或者有两个。如果你没有阅读过这一系统的其它文章，可以看<a href="http://shatle.github.io/blog/categories/shen-ru-es6/">这里</a> 。这文章并不是好的开头。</p>

<p>额外提醒：之前提到的很多特性还没有得到广泛的支持。好了，让我们开始吧。</p>

<h4></h4>

<p>ES6部分特性的标准化来源于之前的其它标准过程，或者部分得到广泛的实现支持而没有标准化。</p>

<ul>
<li><strong>类型数组(Typed arrays)/ArrayBuffer/DataView</strong> 这些是WebGL标准化的一部分，但现在也会运用于其它许多地方的API，包括Canvas、网络音频API和WebRTC。无论你处理多大的二进制文件或者数值数据，都是很方便的。</li>
</ul>


<p>例如，如果你<code>Canvas</code>需要渲染内容时没有你想要的，或者你希望手动操作更为高效时，你可以自己实现它：</p>

<pre><code class="js">var context = canvas.getContext("2d");
var image = context.getImageData(0, 0, canvas.width, canvas.height);
var pixels = image.data; // a Uint8ClampedArray object ect
// ... Your code here!
// ... Hack n the raw bits in `pixels`
// ... and then write them back to th canvas;
context.putImageData(image, 0, 0);
</code></pre>

<p>在标准化过程中，类型数组(Typed arrays)包括有常见了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">方法</a>，如<code>.slice()</code>，<code>.map()</code>，<code>.filter()</code>。</p>

<ul>
<li><p><strong>Promises</strong>  仅用一个自然段来描写promise，就像是吃饭只能吃一个薯片。不用管它有多难，这甚至是什么任何意义的事情。说什么？Promise可以用来对JS进行异步编程来构建代码块。它的作用会在后面提到。比如，当你调用<code>fetch()</code>时，不像普通代码块，它会立即返回一个promise对象，其数据获取会在后台进行。当有返回值时，它会调用你的相应代码。promise优于普通的callback函数，因为它的操作链真心很好。promise有很多有趣的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">操作</a>，通常会是第一选择，你可以简单进行错误处理而不需要做过多的学习。它们已经在浏览器支持了。如果你还不一点都不知道promise，可以查看 <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">Jake Archibald 的文章</a>。</p></li>
<li><p><strong>函数在代码块的作用域中</strong> 你不应该让这情况出现，但是，你可能已经无意地存在相关代码了。</p></li>
</ul>


<p>在ES1-5中，下面的代码在技术上说是有问题的：</p>

<pre><code class="js">if (temperature &gt; 100 ) {
  function chill() {
    return fan.switchOn().then(obtainLemonade);
  }
  chill();
}
</code></pre>

<p>这个函数声明是在<code>if</code>代码块中的，这理念上是不允许的。函数声明只能在顶级中，或者在函数体内的最外层。</p>

<p>但是，上面代码几乎能在所有主流的浏览器中运行，从某种程度上是这样子的。</p>

<p>但又不完全一样，在每个浏览器中其处理细节有些不一样。但是，某种程度上都是可以工作的，并且很多网页还在使用它。</p>

<p>不幸的是，Firefox和Safari还没有实现新的标准。对现在来说，可以使用一个函数的表达式来替代：</p>

<pre><code class="js">if (temperature &gt; 100) {
  var chill = function() {
    return fan.switchOn().then(obtainLemonade);
  };
  chill();
}
</code></pre>

<p>多年来，代码块作用域函数(block-scoped function)没有标准化是因为向后兼容的限制并非常复杂。没有人认为他们可以解决这一问题。ES6处理这种<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics">奇怪规则</a>的线程只能在非严格模式中使用。我不能在这里解释，但请相信我，使用严格模式。</p>

<ul>
<li><strong>函数名称</strong> 所有的主流JS引擎都会在函数中有个非标准的<code>.name</code>属性来表示其名称。ES6对此进行了标准化，它会明智地对某些没有名称的函数推测出<code>.name</code>的属性：</li>
</ul>


<pre><code class="js">&gt; var lessThan = function(a, b) { return a&lt;b;}
&gt; lessThan.name
    "lessThan"
</code></pre>

<h4>好事</h4>

<ul>
<li><strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign(target, &#8230;sources)</a></strong> 标准库中的新函数，类似于Underscore中的<code>.extend()</code></li>
<li><strong>函数调用中的展开操作符(spread operator，实际是省略号，翻译为展开操作符因为作用就是将数据展开为多个值)</strong>  在这里Nutella并没有做什么，尽管Nutella尝着美味。但是，它依然是个美味的特性，我认为你们会喜欢的。</li>
</ul>


<p>在之前的五月中，我们介绍了<a href="http://shatle.github.io/blog/2015/10/25/es6-in-depth-rest-parameters-and-defaults/">rest parameters</a>，这为函数提供了一个可能接收任意数量的参数方式，它比那随意、笨拙的<code>arguments</code>对象更为友好。</p>

<pre><code class="js">function log(...stuff) { // stuff is the rest parameter.
  var rendered = stuff.map(renderStuff); // It's a real array.
  $("#log").add($(rendered));
}
</code></pre>

<p>那时我们并没有对函数中传递任意数量的参数的匹配语法进行说明，它相比<code>fn.apply()</code>更为友好。</p>

<pre><code class="js">// log all the vlaues from an array
log(...myArray);
</code></pre>

<p>好的，它可以作用于任意的<a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">迭代对象</a>，所以你可以通过<code>log(...mySet)</code>来记录所有的事情。</p>

<p>并不像剩余参数，它可以在一个参数列表中使用多个展开操作符：</p>

<pre><code class="js">// kicks are before trids
log("Kicks:", ...kicks, "Trids:", ...trids);
</code></pre>

<p>展开操作符可以二维数组压平为一维数组：</p>

<pre><code class="js">&gt; var smallArrays = [ [], ["one"], ["two", "twos"]];
&gt; var onBigArray = [].concat(...smallArrays);
&gt; oneBigArray
    ["one", "two", "twos"]
</code></pre>

<p>但也许只有我有这一个迫切的需求，如果是这样，我真要责骂Haskell了。</p>

<ul>
<li><strong>构建数组时的展开操作符</strong> 同样回到五月，我们谈到解构中的&#8221;rest“剩余模式。这是一个可以将一数组中的任意数量值取出来的方式。</li>
</ul>


<pre><code class="js">&gt; var [head, ...tail] = [1, 2, 3, 4];
&gt; head
    1
&gt; tail
    [2, 3, 4]
</code></pre>

<p>猜测一下下面代码。这匹配的语法会将任意数量的元素整合为一个数组：</p>

<pre><code class="js">&gt; var reunited = [head, ...tail];
&gt; reunited
    [1, 2, 3, 4]
</code></pre>

<p>同样的，你可以在函数调用中拥有相同的规则：你可以在同一数组中使用多次展开操作符，等等。</p>

<ul>
<li><strong>适时的尾部调用</strong>  如果让我在这里解释这个，对我来说还是难的。</li>
</ul>


<p>为了更好地理解这一特性，没有比这<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-9.html#%_chap_1">计算机编程的结构和解析</a>更合适开始学习的了。如果你感兴趣，你可以坚持读它。尾部调用会在 <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.1">1.2.1部分 线性递归与迭代</a>中有解释。ES6标准化中要求的实现是线性递归的方式，也就是那文章提到的。</p>

<p>没有任一主流的浏览器实现这一特性，这很难实现，但是所有的事情都在往好的方向发展。</p>

<h4>文本(Text)</h4>

<ul>
<li><strong>Unicode 版本升级</strong> ES5要求实现至少支持Unicode的3.0版本字符。ES6则要求至少是Unicode 5.1.0。你可以在函数名称上使用<a href="https://en.wikipedia.org/wiki/Linear_B">Linear B</a>。</li>
</ul>


<p>[Linear A]使用上还有点问题，因为它在Unicode7.0版本之前没有支持，也因为很难管理没有破译的语言进而的代码编写。</p>

<p>(尽管JS引擎支持在Unicode6.1版本中的emoji，但你还是不能使用这些表情作为变量的名称。出于某种原因，Unicode联盟不支持使用它们作为身份标识字符。)</p>

<ul>
<li><strong>长的Unicode转义序列</strong> 如早期版本一样，ES6支持4个数值的Unicode转义序列。它们看着如<code>\u212A</code>。它们很好用，你可以在字符串中使用它们。或者，如果你想耍幽默同时你无论什么时候也不同进行代码检查，你可以使用它们作为变量的名称。但是，对于一个字符如<code>U+1a3021</code>，一个用头倒立的人的埃及象形文字，明显是有问题的。<code>13021</code>有五个数值，已经超过了四个。</li>
</ul>


<p>在ES5中，你不得不编写两个转义符号，因为UTF-16的代理对(surrogate pair)。这实际上就感觉生活在暗黑时代：寒冷、悲惨、野蛮的。ES6就像是意大利的文化复兴，带来了巨大的变化：你现在可以编写<code>\u{13021}</code>。</p>

<ul>
<li><strong>对BMP字符有更好支持</strong> <code>.toUpperCase()</code>和<code>.toLowerCase()</code>方法现在可以用于犹太字符中了。</li>
</ul>


<p>同样的，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint"><code>String.fromCodePoint(...codePoints)</code></a>函数与老式的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode"><code>String.fromCharCode(...codeUnits)</code></a>差不多，只是前者会支持BMP的点编码。</p>

<ul>
<li><strong>Unicode 正则</strong> ES6的正则表达式支持新的标签，<code>u</code>标签，因为除在BMP中正则表达式认为会将其认为是个单独的字符，而不是两个分离的编码单元。例如，没有<code>u</code>时，<code>/./</code>只会匹配半个字符“ ”，但<code>/./u</code>会匹配整个。</li>
</ul>


<p>在正则在增加<code>u</code>的标签，还可以处理unicode的非大小写和长类型的unicode转义序列。至于完整的说明，可参考<a href="https://mathiasbynens.be/notes/es6-unicode-regex">Mathias Bynens 非常详尽的文章</a></p>

<ul>
<li><p><strong>Sticky正则</strong> 对于非unicode的可以使用<code>y</code>标签，详情在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky">此可查看</a>。sticky正则表达式只会从由<code>.lastIndex</code>指定的偏移位开始查找，如果不要指定的位置找到，不会一直向下找，而是直接返回<code>null</code>。</p></li>
<li><p><strong>官方的国际化指引</strong> ES6实现了对国际化的支持，<a href="http://www.ecma-international.org/publications/standards/Ecma-402.htm">ECMA-402 the ECMAScript 2015 国际化说明</a>，这额外的标准中指定了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl"><code>Intl</code>对象</a>。Firefox，chorme 和 IE 11+ 已经支持它了，Node 0.12 也支持。</p></li>
</ul>


<h4>数值(Numbers)</h4>

<ul>
<li><strong>二进制和八进制</strong> 如果你觉得数字 8,675,309 和 <code>0x845fed</code>并不适合你，而想要一种更为特殊的方式表达，你现在可以编写<code>0o41057755</code>（八进制）或者 <code>0b100001000101111111101101</code>（二进制）。</li>
</ul>


<p><code>Number(str)</code>现在也可以识别这格式<code>Number("0b101010")</code>字符串，会返回42。</p>

<p>（快速提醒：<code>number.toString(base)</code>和<code>parseInt(stsring, base)</code>还是可以如原来一样转化数字，无论是转出还是转入，转换的过程中会根据base。）</p>

<ul>
<li><strong>新<code>Number</code>函数和常量</strong> 这是非常好的地方。如果你对此感兴趣，你可以自己查看标准文档，可以从<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-number.epsilon"><code>Number.EPSILON</code></a>开始。</li>
</ul>


<p>也许，这最有意思的新想法是“安全的整型”，它可以从<code>-(2**25-1)</code>到<code>+(2**53-1)</code>，包含边界值 。JS中的数值存在着范围。这一个在此范围中的整型都可以用JS数字表示，进而可以查看其临近的数字。简单来说，在这范围中操作<code>++</code>和<code>--</code>得到的效果是期望所得的。超出这范围时，奇数是不能表示的，就如64位浮点的数字，同样这些数字的增加和减少也不能得到正确的结果（偶数也一样）。为了解决你代码中的这些问题，标准委员会提供了常量<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER"><code>Number.MIN_SAFE_INTEGER</code></a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER"><code>Number.MAX_SAFE_INTEGER</code></a>，和一个判断方法<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger"><code>Number.isSafeInteger(n)</code></a>。</p>

<ul>
<li><strong>新的<code>Math</code>函数</strong>  ES6增加了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh">曲线三角函数</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh">它们的相反值</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt"><code>Math.cbrt(x)</code></a> 会计算立方，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot"><code>Math.hypot(x,y)</code></a> 会计算直角三角形的斜边长，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log2"><code>Math.log2(x)</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10"><code>Math.log10(x)</code></a> 会计算常见的对数值，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32"><code>Math.clz32(x)</code></a>可帮忙求对数（其基本等于<code>32-log2(x)</code>，还有些其它的。</li>
</ul>


<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign"><code>Math.sign(x)</code></a> 可获取数字的符号（1,0,-1对应于正零负）。</p>

<p>ES6还添加了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul"><code>Math.imul(x, y)</code></a>，它就是32位的带符号乘法。这是十分奇怪的需求，除非你实际工作中没有64位的整型或者大数值的整型。如果是这样，这还是挺方便的， 这有助于编译器，Emscripten 可以利用此函数在JS中计算64位的乘法。</p>

<p>类似的，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround"><code>Math.fround(x)</code></a>可助于编译器对32位浮点数值的支持。</p>

<h4>结束语</h4>

<p>这就是所有特性了？</p>

<p>不。我还没有提到在所有内置迭代器中的对象通用原型，还有生成器函数的构造函数，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is(v1, v2)</code></a>。<code>Symbol.species</code>可以帮助进行子类内置操作，如数组和Promise。ES6 还有许多没有标准化的目标正在进行中。</p>

<p>我可以确认的是我肯定遗失些事情没有提到。</p>

<p>但是，如果你一直都跟着下来，你会对整体有个很好的印象。你可以知道今天你可以能用上的特性，如果你还这么做了，那么你正迈向更好的语言。</p>

<p>几天前，Josh Mock 提醒我说，他只只用的50行代码就说完了八个不同的ES6特性，但没有深入的想法。<a href="https://gist.github.com/JoshMock/98f187c7a8bf745e4cf6">文章</a>包含有模块、类、默认参数、Set、Map、模板字符串、前头函数、和let。（他忘记了for-of循环）</p>

<p>这也就是我的经验所得到的。文章对于新的特性在一块处理得很好，它们会真正影响到你日常编写的每一行代码。</p>

<p>同时，每个JS引擎都在积极跟进和优化这些我们之前几个月一直在讨论的特性。</p>

<p>只要我们的工作完成了，这语言也就完善好了。我们将不会不得不再次调整代码了，而我将不得不找其它工作了。</p>

<p>只是开个玩笑。ES7的提案已经提交了。这里可以暴露一点：</p>

<ul>
<li><p><strong>幂操作符</strong> <code>2**8</code>将会返回 256，这会是Firefox中的日版本中更新。</p></li>
<li><p><strong>Array.prototype.includes(value)</strong> 如果这数组包含有指定的值时，会返回true。此会通过polyfill的方式在Firefox的日版本中。</p></li>
<li><p><strong>SIMD</strong>  将128位的SIMD指令集提供给先进的CPU。这些指令集会对相邻的数组元素进行算术计算，可以动态地提升大范围的各种算术，对于流媒体音频、视频、密码、游戏、图片处理等都是相当有用的。更加底层的操作，更为强大。此会通过polyfill的方式在Firefox的日版本中。</p></li>
<li><p><strong>异步函数</strong> 我们在之前的生成器的文章中隐藏这一特性。异步函数类似于生成器，但区别时同步编程。当你调用一个生成器时，它会返回一个迭代器。当你调用一个异步函数时，它会返回一个promise。生成器可以使用yield的关键字来暂停和产出一个值；同步函数则会使用<code>await</code>关键字来暂停和等待一个promise。</p></li>
</ul>


<p>这是很难用几句话来说完的。但异步函数会在ES7中有重大的调整和意义。</p>

<ul>
<li><strong>类型化对象</strong>  这就是之前的类型数组。类型数组的元素拥有其类型，一个类型的对象是一个其属性被类型化后的对象。</li>
</ul>


<pre><code class="js">// Create a new struct type. Every Point has two fields
// named x and y.
var Point = new TypedObject.StructType({
  x: TypedObject.int32,
  y: TypedObject.int32
});

// Now create an instance of that type.
var p = new Point({x: 800, y: 600});
console.log(p.x); // 800
</code></pre>

<p>你为了性能的原因会编写此代码。类似类型数组，类型对象会增加些编程的优势（减少内存的使用和提升速度），但是其每个对象、每个输入选项，相对于之前语言所有事情都会被静态地类型化，也就是被类型会之后，其值必须是那个类型。</p>

<p>这是作为JS的综合目标，并会在Firefox的日版本中实现。</p>

<ul>
<li><strong>类和原型装饰器</strong>  装饰器就是一个属性、类、方法中的标签。通过一个例子来说明其是什么样子的：</li>
</ul>


<pre><code class="js">import debug from "jsdebug";
class Person {
  @debug.logWhenCalled
  hasRoundHead(assert) {
    return this.head instanceof Spheroid;
  }
  ...
}
</code></pre>

<p><code>@debug.logWhenCalled</code>就是所谓的装饰器，你可以想象这方法是做什么的。</p>

<p><a href="https://github.com/wycats/javascript-decorators/blob/master/README.md">这里的提案</a>有解释其详细工作的过程，同时还包含许多的例子。</p>

<p>还有一个令人兴奋的特性我不得不提到，但它还在开发阶段并且不是语言的特性。</p>

<p>TC39, 这个ECMAScript的标准委员会，将会更为频繁地发布版本和有更多的公开进度。在ES5和ES6之间已经有六年。委员会对ES7的目标是在ES6的12个月之后，随后的标准版本会以12个月的节奏进行发布。上面提到的部分特性已经准时完成了，它们会跟上这火车并成为ES7的一部分的。那些还没有完成的，会在下列火车的时间表中。</p>

<p>很高兴分享了很多的ES6的好的新特性，同时也很高兴能够花时间来讨论这些特性，可能以后再也没有这时间了。</p>

<p>很高兴参与深入ES6的文章，我希望你们能喜欢它。保持联系。; )</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: Modules]]></title>
    <link href="http://shatle.github.io/blog/2016/03/20/es6-in-depth-modules/"/>
    <updated>2016-03-20T17:01:19+08:00</updated>
    <id>http://shatle.github.io/blog/2016/03/20/es6-in-depth-modules</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/">ES6 In Depth: Modules</a></p></blockquote>

<p>当我在2007年加入到Mozilla的JS团队时，有一笑话是经典的JS程序只有一行代码。</p>

<p>那时已经是Google Map开始的两年之后了。在此之前，最为卓越的JS代码就是表单的验证，那么你在<code>&lt;input onchange=&gt;</code>上的平均处理代码也就是一行，对的，已经足够了。</p>

<p>事情已经发生了变化。JS项目已经成长为令人惊奇的量级，同时社区中也开发了一些工具来适应规模的变化。其中一个最为基本的事情是你需要模块系统，它可以将你的工作分离到多个文件和目录中，但是它依然保证在必要时能访问其他部分，同时使得加载所有代码更为有效。所以实际上，JS已经有了模块系统，并且有几种。同时，还有些包管理工具来安装软件和复制其高层的依赖。你可能会想到ES6，它为JS带来了新的模块系统，确实有点晚了些。</p>

<p>好的，今天我们就开始来看ES6为这已经存在的系统增加了些什么功能，同时看一下可以使用它来做些什么标准和工具吧。但是首先，让我们开始查看ES6模块长什么样子吧。</p>

<h4>模块基础</h4>

<p>ES6的模块是一个包含有JS代码的模块。它没有<code>module</code>的关键字，一个模块几乎可以看成为一个脚本。这里有两个区别：</p>

<ul>
<li>ES6模块会自动启用 严格模式，即使你没有在代码中使用&#8221;use strict&#8221;</li>
<li>你可以在模块中使用<code>import</code>和<code>export</code></li>
</ul>


<p>让我们先来说一下<code>export</code>。在模块中的任何声明，默认都只会作用于此模块。如果你想在模块中的声明公开出去，也就是其它模块能使用它，你必须<em>暴露</em>这个特性(变量、函数等）。有些方式可以做到这点，最为简单的方式就是添加一个<code>export</code>的关键字。</p>

<pre><code class="js">// kittydar.js - Find the locations of all the cats in an image.
//(Heather Arthur wrote this library for real)
// (but she didn't use modules, because it was 2013)

export function delectCats(cavas, options) {
  var kittydar = new Kittydar(options);
  return kittydar.detectCats(canvas);
}

export clas Kittydar {
  ... several methods doing image processing ...
}

// This helper function isn't exported.
function resizeCanvas() {
  ...
}
</code></pre>

<p>你可以<code>export</code>任何顶级的<code>function</code>、<code>class</code>、<code>var</code>、<code>let</code>、<code>const</code>。</p>

<p>这也就是你需要知道有关模块的所有信息。你并不需要使用IIFE或者一个回调函数。你只要正常地声明你所需要的任何事情。因此，这代码就是模块，不是脚本，所有的声明的作用域都会在此模块中，并不会在全局所有的脚本和模块是可见的。将这些声明暴露出去，会使这成为此模块对外的公开API，这就是你想要的。</p>

<p>与暴露代码不同，在模块中的代码仅仅只是普通的代码。你可以使用全局字面量，如<code>Object</code>和<code>Array</code>。如果你模块运行于浏览器中，你可以使用<code>document</code>和<code>XMLHttpRequest</code>。</p>

<p>在一个分离的文件中，我们可能导入并使用<code>detectCats()</code>函数：</p>

<pre><code class="js">// domo.js - Kittydar demo program

import {detectCats} from "kittydar.js";

function go(){
  var canvas = document.getElementById("catpix");
  var cats = detectCats(canvas);
  drawRectangles(canvas, cats);
}
</code></pre>

<p>为了从一个模块中导入多个名称，你可以编写:</p>

<pre><code class="js">import {detectCats, Kittydar) from "kittydar.js";
</code></pre>

<p>当你运行一个含有<code>import</code>声明的模块时，需要导入的模块会先被加载，每个模块的代码体会根据整个依赖图进行深度遍历执行，并跳过已经执行的模块来避免循环加载。</p>

<p>这就是模块的基础内容了，这确实是十分简单的，;-)</p>

<h4>导出列表</h4>

<p>相比于在每个特性中进行导出的标记，你可以编写一个简单的列表来指出你想导出的所有名称，并放到大括号中：</p>

<pre><code class="js">export {detectCats, Kittydar};

// no export keyword required here
function detectCats(canvas, options) { ... }
class Kittydar { ... }
</code></pre>

<p><code>export</code>的列表并不一定需要在文件的第一行，它可以出现在模块的顶级的任意地方。你可以拥有多个<code>export</code>列表，或者与其它的<code>export</code>混合起来用，只要保证导出的名称不超过一次就好。</p>

<h4>对导入导出重命名</h4>

<p>有时，一个导入的名称可能会与其它你同样需要使用的名称是一样的，所以ES6允许你对导入的名称进行重命名：</p>

<pre><code class="js">// suburbia.js

// Both these modules export something named `flip`.
// To import them both, we must rename at least one.
import {flip as flipOmelet} from "eggs.js";
import {flip as flipHouse} from "real-estate.js";
</code></pre>

<p>类似的，你可以对导出的名称进行重命名。有时可能会出现，你希望以不同的名称导出相同的值，如下：</p>

<pre><code class="js">// unlicensed_nuclear_accelerator.js - media streaming without drm
// (not a real library, but maybe it should be)

function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
</code></pre>

<h4>默认导出</h4>

<p>设计的新标准是能与已经存在的CommonJS和AMD模块能正常溶合，所以当你一个Node项目，并且完成命令<code>npm install lodash</code>。你的ES6代码可以从<code>lodash</code>导入单独的函数：</p>

<pre><code class="js">import {each, map} from "lodash";

each([3,2,1], x=&gt; console.log(x));
</code></pre>

<p>但是，你可能已经习惯看到<code>_.each</code>而不是<code>each</code>，并且你希望编写代码依然保持这方式。或者自从有 <a href="https://lodash.com/docs#_">这个</a>，你还想使用<code>_</code>作为一个函数。</p>

<p>为了做到这点，你可以稍微地调整为不同的语法：导入模块时不使用大括号：</p>

<pre><code class="js">import _ from "lodash";
</code></pre>

<p>这其实就是等价于<code>import {default as _} from "lodash"</code>。所有的CommonJS和AMD模块都会为ES6提供一个<code>default</code>的导出名称，这其实就类似于你<code>require()</code>这模块，也就是<code>exports</code>对象。</p>

<p>ES6模块被设计为可以让你导出多个事物，但在已经存在的CommonJS模块中，默认的导出是包含所有事物。例如，有名的<a href="https://github.com/Marak/colors.js">colors</a>包在我说之前并没有任何对ES6的支持。它就是一个CommonJS的集合，就像很多在npm的包一样。但是，你可以明确地告诉ES6代码需要导入的内容。</p>

<pre><code class="js">// ES6 equivalent of `var colors = require("colors/safte");`
import colors from "colors/safe"
</code></pre>

<p>如果你希望你的ES6模块有个默认的导出，那很容易。这并没有什么魔法性的操作，它就像其它的导出操作，只是将其命名为<code>"default"</code>。你可以使用我们之前提到的重命名的语法：</p>

<pre><code class="js">let myObject = {
  field1: value1,
  field2: value2
};
export {myObject as default};
</code></pre>

<p>或者使用缩写：</p>

<pre><code class="js">export default {
  field1: value1,
  field2: value2
}
</code></pre>

<p>关键字<code>export default</code>后面可以接任意的值：一个函数，一个类，一个你命名的对象字面量。</p>

<h4>模块对象</h4>

<p>十分抱歉，这部分内容有些长。但是，这并不仅仅是JS特有的。因为某些原因，所有语言中的模块系统都试图做到足够的小、方便。幸运，还剩一个特性。好吧，是两个。</p>

<pre><code class="js">import * as cows from "cows";
</code></pre>

<p>当你使用<code>import *</code>时，它导入的是一个模块命名对象。它的属性是这一模块的所有导出。所以，如果&#8221;cow&#8221;模块导出有一个名为<code>moo()</code>的函数，那么在此行代码导入&#8221;cows&#8221;之后，你可以使用<code>cows.moo()</code>。</p>

<h4>聚合模块</h4>

<p>有时，主模块可能会将其它模块的包导入进来，同时会将它们又以非统一的方式导出。为了简化这一类的代码，下面有个聚合的从导入到导出的缩写：</p>

<pre><code class="js">// world-foods.js - good stuff from all over

// import "sri-lanka" and re-export some of its exports
export {Tea, Cinnamon} from "sri-lanka";

// import "equatorial-guinea" and re-export some of its exports
export {Coffee, Cocoa} from "equatorial-guinea";

// import "singapore" and export ALL of its exports
export * from "singapore";
</code></pre>

<p>每个这些<code>export-from</code>的表达式都类似于<code>import-from</code>，只是调整为<code>export</code>。并不像导入一样，这并不会重新添加导出的绑定到主模块的作用域中。所以，如果你想在<code>world-foods.js</code>中编写代码使用<code>Tea</code>，就不要使用这一缩写。你会发现找不到这字面量。</p>

<p>如果在导出&#8221;singapore&#8221;时会与其它的导出有冲突，会产生一个错误，所以请小心使用<code>export *</code>。</p>

<p>好了，我们介绍完语法了。让我们开始些有趣的事情。</p>

<h4><code>import</code>实际上做了什么</h4>

<p>你会相信 它没什么吗？</p>

<p>好吧，你不是那么好欺骗的。好的，你会相信标准委员会几乎没有对<code>import</code>进行说明？这是好事吗？</p>

<p>ES6的模块加载的整个详情可以移步到 <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hostresolveimportedmodule">其实现</a>，它的实现详情可移步于 <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toplevelmoduleevaluationjob">详细说明</a>。</p>

<p>粗略来讲，当你告诉JS引擎在运行一个模块时，它不得不进行如下四个步骤：</p>

<ul>
<li>1、解析：读取模块资源的实现代码并检查语法错误</li>
<li>2、加载：递归地加载所有需要导入的模块，这一部分还没有标准化。</li>
<li>3、链接：对于每个加载完成的模块，会为其创建一个作用域，并将此模块声明绑定到此作用域中，包括从其它模块导入过来的事物。</li>
</ul>


<p>这就是<code>import {cake} from "paleo"</code>的部分。但是，如果&#8221;paleo&#8221;模块并没有导出任何名为&#8221;cake&#8221;的字面量，你将会得到一个错误。这是很坏的体验，因为你已经实际上运行了一些JS代码了。</p>

<ul>
<li>4、运行：最后，开始运行每个新加载的模块体。这时候，<code>import</code>的处理进程已经完成了，所以当代码执行到含有<code>import</code>声明的代码行时，没有什么会发生。</li>
</ul>


<p>看？我之前就告诉你答案是“没什么”。我对编程语言并不会撒谎。</p>

<p>但是，现在我们开始接触这模块系统的有趣部分了，这是个感觉好玩的点。因为模块系统并没有指定怎么加载模块，你可以在开始时候，找出在资源代码中所有的<code>import</code>声明。ES6的其中一个实现方式，是将所有的工作都放到编译阶段，并将所有的模块捆绑放入一个文件中，才发送给网络上。webpack这工具实际上就是这么做的。</p>

<p>这是个大的话题，因为加载脚本会花费网络的时间。当你每次获取时，你会查找其<code>import</code>的声明，时间就会成倍增长了。比较天真的加载方式是会发送多个网络请求，但通过webpack，这不仅仅是今天使用ES6模块，你会自动得到所有软件工程所要到达的运行时优点。</p>

<p>ES6模块加载的详情还是与原始计划的一样，并构建起来的。其中一个原因就是因为没有统一怎么实现此特性，所以它并不是最后的标准。我希望某人能够指出来，因为就如我们看到的，模块的加载确实需要标准化，而且打包非常有用，是不能放弃的。</p>

<h4>静态 vs 动态，或者：规则或打破规则</h4>

<p>作为动态语言，JS已经拥有其令人惊奇的静态模块系统。</p>

<ul>
<li><p>所有的<code>import</code>和<code>export</code>都只允许在模块的顶级声明，导入导出没有额外的限制条件，但你不能在函数作用域中使用。</p></li>
<li><p>所有的导出定义必须是在资源代码中存在有明确的名称。你不能通过编程来循环一个数组并导出一堆的名称。</p></li>
<li><p>模块对象是冻结的。不能通过hack的方式来操作模块对象，polyfill方式的也不行。</p></li>
<li><p>在任一模块代码运行之前，所有模块依赖必须加载完成、解析和关联上。按照要求，不允许<code>import</code>导入模块懒加载的。</p></li>
<li><p>对于<code>import</code>的错误没有任何的恢复机制。一个App可能会有上百的模块，如果有任何的加载或者关联失败，所有代码将不会运行。你不能在<code>try/catch</code>中使用<code>import</code>。（这里有个优点，因为这模块系统是静态的，所以webpack可以在编译阶段检查出可能存在的错误。）</p></li>
<li><p>在没有加载完依赖之前，不允许运行模块中的任何代码。这意味着如果依赖没有加载完成时，模块本身不知道怎么控制代码的运行。</p></li>
</ul>


<p>如果你需求是静态的话，这模块系统是十分好的。但是，有时你可能需要些hack，是不是？</p>

<p>这就是为什么你需要编程API来处理与ES6的<code>import/export</code>语法相违背的模块系统加载机制。例如，<a href="http://webpack.github.io/docs/code-splitting.html">webpack includes an API</a> 你可以使用“code splitting&#8221;，按需求对某些模块进行懒加载。这个API可以让你打破上面所提到的多数规则。</p>

<p>ES6的模块语法是十分静态的(晕，什么叫十分静态），同时它也是好的，因为这样可以缩短其编译工具的时间。但是，通过编程后的加载API，这静态的语法已经可以动态操作了。</p>

<h4>什么时候可以使用这ES6的模块？</h4>

<p>现在为了使用模块，你需要一个编译器，如 Traceur 或者 Babel。早些时候，Gaston I. Silva 有一<a href="http://shatle.github.io/blog/2015/12/16/es6-in-depth-using-es6-today-with-babel-and-broccoli/">文章</a> 来说明怎么为Web编译ES6代码。在这一文章中，Gaston 已经有一个例子是有关ES6模块的。这有个Axel Rauschmayer 编写的<a href="http://www.2ality.com/2015/04/webpack-es6.html">例子</a>，它使用Bable和webpack。</p>

<p>模块系统主要由 Dave Herman 和 Sam Tobin-Hochstadt 设计，他们为此模块系统的静态化辩护，同时为此长年与包括我在内的很多人抗争着。Jon Coppeard 实现了 Firefox 中的模块。另外的<a href="https://github.com/whatwg/loader">JS 加载器标准化</a>也正在进行中，人们所希望的在HTML中添加<code>&lt;script type=module&gt;</code>的特性也会随之而来。</p>

<p>这就是ES6。</p>

<p>这些实在是太有意思了，以致我并不想结束。也许，我们只是完成了部分的故事情节。我们可以讨论些ES6说明中零碎的特性，但它们又不能足够单独写成文章。也许，将来会对这些进行讨论。请在下周加入我们，一起对深入ES6进行个完美的总结吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: Subclassing]]></title>
    <link href="http://shatle.github.io/blog/2016/03/20/es6-in-depth-subclassing/"/>
    <updated>2016-03-20T17:00:04+08:00</updated>
    <id>http://shatle.github.io/blog/2016/03/20/es6-in-depth-subclassing</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/">ES6 In Depth: Subclassing</a></p></blockquote>

<p>两周之前，我们介绍了ES6中新增加的一个类的系统，它可以用来做面向对象式的创建对象。我们可以展示一下，你可以怎么使用它来编写代码，如下：</p>

<pre><code class="js">class Circle {
  constructor(radius) {
    this.radius = radius;
    Circle.circlesMade++;
  };

  static draw(circle, canvas){
    // Canvas drawing code
  };

  static get chiclesMade() {
    return !this._count ? 0 : this._count;
  };
  static set circlesMade(val) {
    this._count = val;
  };

  area() {
    return Math.pow(this.radius, 2) * Math.PI;
  };

  get radius() {
    return this._radius;
  };
  set radius(radius) {
    if (!Number.isInteger(radius))
      throw new Error("Circle radius must be an integer.");
    this._radius = radius;
  };
}
</code></pre>

<p>很不幸的是，就如一些人指出的，这并没有体现ES6中类的其它作用。就像传统的类系统(如，C++ 或者 Java)，ES6允许继承，也就是一个类可以将另外一个作为基类，然后为自己增加更多的特性进而实现扩展。让我们更为接近这一新特性，查看其操作的可能性。</p>

<p>在我们开始讨论子类化之前，还需要花些时间来复习一下属性的继承和动态的原型链。</p>

<h4>JS的继承</h4>

<p>当我们创建一个对换昌，我们可以为其增加属性，同时它继承于其本身原型对象的属性。JS程序大大应该会很熟悉存在的<code>Object.create</code>这个API，它让我们可以简单地做到这点：</p>

<pre><code class="js">var proto = {
  value: 4,
  method() { return 14; }
}

var obj = Object.create(proto);

obj.value; //4
obj.method(); //14
</code></pre>

<p>接着，当我们为<code>obj</code>添加在<code>proto</code>拥有相同名称的属性时，这些<code>obj</code>属性就相当于<code>proto</code>的影子：</p>

<pre><code class="js">obj.value = 5;
obj.value; //5
proto.value; //4
</code></pre>

<h4>子类化的基础</h4>

<p>这时，我们应该知道我们应该怎么通过类来处理对象创建时的原型链。再次重复一下，当我们创建一个类时，我们在类定义的内部为<code>constructor</code>方法创建一个新的函数，它可以处理所有的静态方法。我们也可以为创建好的函数增加一个包含原型属性的对象，它可以处理实例对象的方法。为了创建一个能继承所有静态属性的新类，我们不得不创建一个函数对象来继承基类的函数对象。类似的，对于实例方法，我们不得不为创建一个新的原型链上的函数，并继承于基类的原型类对象。</p>

<p>这描述有点让人迷惑，让我们来看一个例子，它会显示我们是怎么不用新语法来实现继承，接着进行些细小的扩展来让其更美观些。</p>

<p>继续我们之前例子，假设我们有一个类<code>Shape</code>，我们希望其可以子类化：</p>

<pre><code class="js">class Shape {
  get color() {
    return this._color;
  }
  set color(c) {
    this._color = parseColorAsRGB(c);
    this.markChanged();  // repaint the canvas later
  }
}
</code></pre>

<p>当我们试图编写这样的代码时，对于<code>static</code>的属性我们依然会遇到之前文章同样的问题：没有语法来改变原型链的函数定义。当你可以有一方法类如<code>Object.setPrototypeOf</code>来解决这问题时，这方法比那些直接在原型链上创建函数要显得性能更为低劣。</p>

<pre><code class="js">class Circle {
  // As above
}

// Hook up the instance properties
Object.setPrototypeOf(Circle.prototype, Shape.prototype);

// Hook up the static properties
Ojbect.setPrototypeOf(Circle, Shape);
</code></pre>

<p>这代码是十分丑陋的。我们增加了类的语法，可以让我们将对象的所有逻辑都封装在一个地方中，而不是像刚才的包括其它的&#8221;hooking things up(使用勾子方法提升功能)&#8221;的逻辑。Java、Ruby和其它的面向对象的语言中，都有一个方式来声明一个子类化的类，并指出来源于哪个类，所以我们也应该这样。我们使用关键字<code>extends</code>，所以我们可以编写成：</p>

<pre><code class="js">class Circle extends Shape {
  // As above
}
</code></pre>

<p>你可以在<code>extends</code>的后面添加任意的表达式，只要它是一个合法的<code>prototype</code>的原型构建器，如：</p>

<ul>
<li>其它类</li>
<li>由存在的继承框架产生的与类相似的函数</li>
<li>一个普通的函数</li>
<li>一个包含一个函数或者类的变量</li>
<li>一个对象的访问属性(obj[name])</li>
<li>一个函数调用</li>
</ul>


<p>如何你不想实例继承于<code>Object.prototype</code>，你甚至可以使用 <code>null</code>。</p>

<h4>Super 属性</h4>

<p>所以现在我们可以进行子类化，同时我们可以继承属性，可以通过我们的继承为方法创建影子方法。但是，如果你想避免这些影子方法呢？</p>

<p>想象一下我们希望为我们的<code>Circle</code>编写一个子类，它可以通过某些因素进行缩放。为了做到这点，我们可以编写下面显得不太自然的类：</p>

<pre><code class="js">class ScalableCircle extends Circle {
  get radius() {
    return this.scalingFactor * super.radius;
  }
  set raadius() {
    throw new Error("ScalableCircle radius is constants." +
                                   "Set scaling factor instead.");
  }

  // Code to handle scalingFactor
}
</code></pre>

<p>注意在<code>radius</code>的getter方法中使用了<code>super.radius</code>。这个<code>super</code>的关键字可以让我们忽略自身的属性，而开始从我们的原型链中查找属性，因此也会过滤所有之前我们提到的影子方法。</p>

<p>我们可以在任意方法的函数定义中访问super属性(随便提醒，<code>super[expr]</code>也能工作)。当这些函数从原始对象中脱离出来后，super的方法访问实际上关联的是方法第一次定义的对象。这就意味着将一个方法脱离原有操作并定义到一个本地变量中，并不会改变<code>super</code>的方法访问产生的行为。</p>

<pre><code class="js">var obj = {
  toString() {
    return "MyObject: " + super.toString();
  }
}

obj.toString(); // MyObject: [object Object]
var a = obj.toString;
a(); // MyObject: [object Object]
</code></pre>

<h4>子类化后的内置操作(基类方法的继承)</h4>

<p>另外，你们可能希望在JS语言内部编写些扩展功能。JS内部的数据结构赋予其巨大的能力，可以利用这些能力来创建新的数据类型，其也是子类化设计中的基础。JS支持你编写一个具有版本的数组。（我知道，相信我，我知道）。版本数组应该可以修改，可能提交修改，回退到之前的提交变化。有一种方式来快速的编写版本数组，就是创建<code>Array</code>的子类。</p>

<pre><code class="js">class VersionedArray extends Array {
  constructor() {
    super();
    this.history = [[]];
  }
  commit() {
    // Save changes to history
    this.history.push(this.slice());
  }
  revert() {
    this.splice(0, this.length, this.history[this.history.length - 1]);
  }
}
</code></pre>

<p><code>VersionedArray</code>的实例保持有数组中的一些重要属性，它们可以说是<code>Array</code>的实例，方法包括有<code>map</code>，<code>filter</code>和<code>sort</code>。<code>Array.isArray()</code>会将其实例认为是数组，它们还可以自动地更新数组的<code>length</code>属性。再者，返回数组的函数此时会返回一个<code>VersionedArray</code>（如<code>Array.prototype.slice()</code>）！</p>

<h4>类构建器的派生</h4>

<p>你可能已经注意到了上面的例子中的<code>constructor</code>方法有<code>super()</code>。</p>

<p>在传统的类模型中，构建器是用来初始化类实例的内部状态的。每个连续的子类负责初始化状态和相关的具体子类(什么叫连续的子类？晕)。我们希望这些能起作用，所以需要子类可以通过扩展来操作相同的初始化代码。</p>

<p>为了调用基类的构建器，我们可以再次使用<code>super</code>这关键字，它是操作就是个函数。这语法只有在使用<code>extends</code>的类的<code>constructor</code>的方法中是合法的，我们可能重新编写我们形状（Shape）类。</p>

<pre><code class="js">class Shape {
  constructor() {
    this._color = color;
  }
}

class Circle extends Shape {
  constructor(color, radius) {
    super(color);
    this.radius = radius;
  }

  // As from above
}
</code></pre>

<p>在JS中，我们通过编写构建器，来操作<code>this</code>对象、安装属性和初始化内部的状态。一般来说，当我们通过<code>new</code>调用构建器时<code>this</code>对象就创建成功了，就像是<code>Object.create()</code>会处理其构建器的<code>prototype</code>的属性。但是，有些内置操作会在不同的内部对象布局上。例如，数组在内存中的位置不同于常规的对象。因为，我们想看到子类的内置操作，我们需要让基类分配到<code>this</code>对象。如果它是内置操作，我们会得到我们想要的对象行为，如果它是普通的构建器，我们会得到期望中的默认的<code>this</code>对象。</p>

<p>可能会得到个奇怪的结论，认为<code>this</code>绑定的是子类的构建器。当我们运行到基类的构建器时，允许其指定<code>this</code>对象，但<strong>我们子类实际上并不会有<code>this</code>的值</strong>。因此，在没有调用基类构建器之前，所有访问子类构建器会导致一个<code>ReferenceError</code>错误。</p>

<p>就如之前的文章，你可以省略掉<code>contructor</code>方法，派生出来的构建器也是可能省略的，它就如你编写：</p>

<pre><code class="js">constructor(...args) {
  super(...args);
}
</code></pre>

<p>有时，构建器并不能作用于<code>this</code>对象。相反，它们会通过其它的方式来创建对象，并初始化，接着直接返回此对象。如果是这一情况，那就不用使用<code>super</code>了。所有的构建器都会直接返回一个对象，不依赖于其基类构建器是否调用。</p>

<h4><code>new.target</code></h4>

<p>基类指定<code>this</code>对象时会有其它怪异的效果，那就是有时基类并不知道指定哪类的对象。假设，你正在编写一个对象框架的库，你希望有个基类<code>Collection</code>，某些子类会是数组，某些子类会是映射(Map)。然后，这时你运行<code>Collection</code>构建器，你并不会被告知是创建了哪类对象。</p>

<p>因此我们在进行内置操作时，当我们运行内置的构建器，我们需要知道其原始类的<code>prototype</code>。没有原型，我们是不能创建一个对象，使其有相应的实例方法的。为了解决这<code>Collection</code>的怪异情况，我们需要增加语法来暴露其信息给JS代码。我们已经增加了一个新的<em>元属性(Meta Property)</em> <code>new.target</code>，它关联构建器，可能直接调用<code>new</code>。通过<code>new</code>调用一个函数时，<code>new.target</code>会设置到其调用的函数中。调用<code>super</code>的函数中的<code>new.target</code>会作用<code>new.target</code>的值 。</p>

<p>这很难理解，所以让我用代码来解释我说的意思吧：</p>

<pre><code class="js">class foo {
  constructor() {
    return new.target;
  }
}

class bar extends foo {
  // This is included explicitly for clarity. It is not necessary
  // to get these results.
  constructor() {
    super();
  }
}

//foo directly invoked, so new.target is foo
new foo(); // foo

// 1) bar directly invoked, so new.target is bar
// 2) bar invokes foo via super(), so new.target is still bar
new bar(); // bar
</code></pre>

<p>我们已经解决了上面<code>Collection</code>所描述的问题，因为<code>Collection</code>构建器只检查<code>new.target</code>，就可以知道其类的家族，查看其是否是内置操作。</p>

<p><code>new.target</code>在任何的函数中都是合法的，如果一个方法没有由<code>new</code>调用时，它会被设置了<code>undefined</code>。</p>

<h4>最好的两个世界(多继承)</h4>

<p>希望你已经从这新特性的头脑风暴中生还出来，十分感谢能一直走到现在。现在，让我们花点时间来讨论，这些新特性怎么解决我们的问题。很多人很直率地质疑在JS加入继承这一特性是否好的。你可能会认为继承在创建对象上并不如<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">组合</a>一般好，或者认为相比于旧式的原型链模型，这精简的新语法会减少其设计上的灵活性。不容质疑的是，混入(mixin)通过扩展的方式来分享代码从而创建对象已经成为惯用手法。同时，它还有个好的原因：它提供了简单方式来将不相关的代码放置到同一个对象中，而不需要理解这两部分不相关代码是否适合在同一继承结构中。</p>

<p>在这主题上有很多不同的激烈信仰，但是我认为这并不值得讨论。首先，对一个语言增加类的特性，并不一定要求开发人员使用。第二，也同等的重要，语言中有类这一特性并不意味着它总是解决继承问题的最好方法！实际上，部分问题使用原型链继承的方式更为合适。到今天为此，类只是为你提供了额外的工具；它并不是唯一的，也不是最为必要的。</p>

<p>如果你想继续使用混入的方式，你可以理解那些由不同事情整合继承出来的类，才能通过混入来实现继承，以保证每件事能正常进行。不幸的是，现在这方式可能会修改继承模型，这显得十分刺耳。所以，JS并不对继承多个类进行实现。不过，它还是有一混合的方式来允许在类框架中使用混入方式的。详细看一下下面的函数，它是基于众所周知的<code>extend</code>混入的。</p>

<pre><code class="js">function mix(...mixins) {
  class Mix {}

  // Programatically add all the methods and accessors 
  // of the mixins to class Mix.
  for (let mixin of mixins) {
    copyProperties(Mix, mixin);
    copyProperties(Mix.prototype, mixin.prototype);
  }

  return Mix;
}

function copyProperties(target, source) {
  for (let key of Reflect.ownKeys(source)) {
    if ( key !== "constructor" &amp;&amp; key!== "prototype" &amp;&amp; key !== "name" ) {
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.definProperty(target, key, desc);
    }
  }
}
</code></pre>

<p>现在我们可以使用<code>mix</code>函数还创建一个组合型的超级类，通过变量mixins，我们不需要创建详细的继承关系。细想一下，当你编写一个协作编辑工具时，需要记录编辑的动作，同时需要将其内容序列化。你可以使用<code>mix</code>函数来编写一个<code>DistributedEdit</code>的类。</p>

<pre><code class="js">class DistributedEdit extends mix(Loggable, Serializable) {
  //Event methods
}
</code></pre>

<p>这对两个世界都很好。通过这例子，可以简单地看到怎么处理使得模型可以混入多个基类：我们可以简单地将基类放到<code>mix</code>函数中，并用类进行扩展继承。</p>

<h4>当前可用性</h4>

<p>好了，我们已经谈到许多有关子类化的内置等所有新功能，但是你是否现在可能使用它呢？</p>

<p>好吧，部分吧。在主要的浏览器商家中，Chrome已经支持我们今天所讨论到大部分的内容。在严格模式中，你可以我们讨论过的所有所有事情，除了<code>Array</code>的子类化。其它内置操作也可以使用，但是<code>Array</code>会出现一些额外的问题，所以可以不奇怪地确定还没有完成。我在firefox实现此功能，并快要接近尾声了（所有除了<code>Array</code>）。可以检查一下 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1141863">bug 1141863</a> 看到更多的信息，但是它会在几周后的日更新版本中出现。</p>

<p>再者，Edge已经支持<code>super</code>，但并不支持子类化的内置操作。Safari并不支持任何函数功能。</p>

<p>转换编译器在部分会有些不利的地方。它们可能创建类，可能使用<code>super</code>，但它们并没有一种方式来子类化内部操作，因为你需要一个引擎来支持一个类的实例能回溯到内置的操作方法(参考<code>Array.prototype.splice</code>)。</p>

<p>好了，这真是长啊。下周，Jason Orendorff 会回来并一起讨论ES6的模块系统。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: let and const]]></title>
    <link href="http://shatle.github.io/blog/2016/03/12/es6-in-depth-let-and-const/"/>
    <updated>2016-03-12T10:47:20+08:00</updated>
    <id>http://shatle.github.io/blog/2016/03/12/es6-in-depth-let-and-const</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/">ES6 In Depth: let and const</a></p></blockquote>

<p>今天我要讨论的特性刚第一眼可能显得很简单，但实际上是很强大的。</p>

<p>当BrenDan Eich在1995年开始设计JS的第一个版本时，它做了很多错误的事情，这些事情还包括之后的语言发展中。例如，当你不小心错误处理<code>Date</code>和其它对象时，会自动转为<code>NaN</code>。但是，有些重要的事情他是正确的，有先见之明：对象、原型、第一类函数有词法作用域（就是函数是有作用域的）、默认是可变的。这语言基础是十分良好的，它优于大家对它的第一印象。</p>

<p>同时，Brendan 创建了个特别的设计并影响到今天的文章 &#8211; &#8211; 我认为他这决定是可以称为一个错误的。它是个小事情，十分微小的事情，你可能使用JS多年还没注意到它。但是，它是重要的，因为从这语言来看，这个错误的设计部分在今天来看，我们认为它是好的部分。</p>

<p>它不得不与变量一起处理。</p>

<h4>问题1：代码块没有作用域</h4>

<p>这问题看起来很无辜：<strong>在JS函数中进行<code>var</code>声明时，变量作用域是可以在整个函数体中的</strong>。其中，有两个方式来看到此问题引起的后果。</p>

<p>一个是在代码块中声明的变量的作用域不仅仅是在此代码块中，它会作用于整个函数。</p>

<p>你之前也许并不会注意到这点，但我担心这一点可能会你并不想看到的。让我们通过一场景来看一下这个狡猾的Bug。</p>

<p>你在某些代码中使用一个名称为<code>t</code>的变量：</p>

<pre><code>function runTowerExperiment(tower, startTime) {
  var t = startTime;

  tower.on('click', function() {
    ... code that uses t ...
  });
  ... more code ...
}
</code></pre>

<p>目前，每件事都工作得很好。现在，你想增加保龄球的测速功能，所以，你在内部的callback函数中增加些<code>if</code>表达式。</p>

<pre><code>function runTowerExperiment(tower, startTime) {
  var t = startTime;

  tower.on('click', function() {
    ... code that uses t ...
    if (bowlingBall.altitude() &lt;= 0 ) {
      var t = readTachymeter();
      ...
    }
  });
  ... more code ...
}
</code></pre>

<p>噢，你无意地增加了第二个名称为<code>t</code>的变量。现在，之前正常工作的<code>t</code>，与一个新的内部的变量<code>t</code>关联上了，替代了外部早已存在的那个变量。</p>

<p>JS中<code>var</code>的作用域类似于PS中的桶刷工具，它会从声明、向前、向后各方向得到扩展，直到它碰到函数的边界，否则一直会起作用。因此，此处目前的<code>t</code>的作用域是向后兼容的，它就是我们在开始进行函数时创建的，这称作为变量升域(hoisting)。我几乎认为，JS引擎通过一个微小的代码起重机，将每个<code>var</code>和<code>function</code>提升到函数闭域的顶部。</p>

<p>现在，升域也是有它好处的。没有这一特性，很多在全局作用域中能很好工作的完美的好的技术将不能在<a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">即时调用函数表达式(IIFE)</a> 使用。但与此同时，升域会导致一个恶心的Bug： 当你使用<code>t</code>去计算时可能会得到<code>NaN</code>，这时你很难去追踪到它，特别是当你的代码大于此时的小例子时。</p>

<p>添加一个新的代码块会导致之前的代码块出现意想不到的错误。它只影响到我？它是不是真的怪异？我们并不想影响到之前的结果。</p>

<p>但是，相对于<code>var</code>的第二个问题，这个问题还是小的。</p>

<h4>问题2：变量在循环中会过度地分享</h4>

<p>你可以先猜测一下，当你运行这代码时会出现什么情况。它很简单：</p>

<pre><code class="js">var messages = ["Hi!", "I'm a web page!", "alert() is fun!"];

for (var i = 0; i &lt; messages.length; i++;){
  alert(messages[i]);;
}
</code></pre>

<p>如果你看了这一系列的文章，你会知道我很喜欢在例子代码中使用<code>alert()</code>。也许，你也知道<code>alert()</code>是个糟糕的API，它是同步操作的。所以，当一个警告提示窗出现时，输入事件是不会传递的。在你的JS代码、实际在你的整个UI界面基本会是暂停的，直到用户点击确定选项。</p>

<p>多数时候，你在网页中使用<code>alert()</code>是个错误的选择，我之所以使用它，是因为我只觉得<code>alert()</code>是个很好的教学工具。</p>

<p>同时，我还应该被劝说放弃所有的杂乱和坏的行为，它意味着我可以这样创造一个说话的猫：</p>

<pre><code class="js">var messages = ["Meow!", "I'm a taling cat!", "callbacks are fun!");

for (var i=0; i &lt; messages.length; i++) {
  setTimeout(function () {
    cat.say(messages[i]);
  }, i * 1500);
}
</code></pre>

<p>但是这会出错。这并不会顺序地说出三个消息，这代码猫会说出三次的&#8221;undefined&#8221;。</p>

<p>你能指出这个问题吗？</p>

<p>这问题出现在唯一的变量<code>i</code>中，它会作用于循环内部和三个延时的返回函数。但当循环完成时，<code>i</code>的值会变成3，因为<code>messages.length</code>等于3，但任一返回函数并没有被调用。</p>

<p>所以，当第一个延时函数工作时，会调用<code>cat.say(messages[i])</code>，它实际会是<code>messages[3]</code>，而这会导致出现<code>undefined</code>。</p>

<p>有很多的方法来解决这一问题，但这个是<code>var</code>的作用域规则导致的第二个问题。首先，确保代码不会有这一问题是十分好的。</p>

<h4>let 新于 var</h4>

<p>在很多时候，JS在设计上的缺陷是不能弥补的（其它语言也会设计缺陷，但JS犹为突出）。向后兼容意味着不能改变已经存在的Web中JS代码行为。甚至，标准委员会也没致力于此，认为解决这些怪异的问题就是自动插入分号(意思是注意细节？)。浏览器制作人并不想对这种破坏性的改变进行实现，因为这些改变会成为其用户的惩罚（也可能会因此失去部分用户）。</p>

<p>所以，大概十年之前，当 Brendan Eich 决定解决这问题时，那时只有一种方式来实现。</p>

<p>他添加了一个新的关键字<code>let</code>，它可以用来声明变量，就像<code>var</code>一样，但其作用域规则更好。</p>

<p>它看起来这样子：</p>

<pre><code class="js">let t = readTachymeter();
</code></pre>

<p>或者这样：</p>

<pre><code class="js">for (let i = 0; i &lt; messages.length; i++) {
  ...
}
</code></pre>

<p><code>let</code>和<code>var</code>是不一样的。如果你只是需要在你代码中做个全局的搜索和替换，又可以在你的部分代码中进行中断（有可能是无意的），那么你可以使用怪异的<code>var</code>。但是在更多时候，在ES6中，你应该在任何地方都要停止使用<code>var</code>，而使用<code>let</code>。正因为如此，标题为“let 新于 var”。</p>

<p><code>let</code>和<code>var</code>到底有哪些不一样呢？很高兴你会提问：</p>

<ul>
<li><strong><code>let</code>变量是代码块作用域的</strong>  使用<code>let</code>来声明一个变量，其作用域只会在包含的作用域中，而不是整个函数的内部。</li>
</ul>


<p><code>let</code>也会有一定的升域情况，但是它并不是任意的。用<code>let</code>替换<code>var</code>，可以简单地解决<code>runTowerExperiment</code>例子中的问题。如果你在任何的地方都使用<code>let</code>，你将不会再遇到此类问题。</p>

<ul>
<li><p><strong>全局的<code>let</code>变量并不会成为全局对象的属性</strong> 是的，你不能通过编写<code>window.variableName</code>来访问它们。相反，它们运行在网页中的一个不可见的包含所有JS代码的块中。</p></li>
<li><p><strong>在<code>for (let x ...)</code>的每次循环中会创建新的绑定的变量<code>x</code></strong>。这会有些微小的不同的，意味着<code>for (let ...)</code>循环执行多次时，每次其内部包含一个闭包。就像之前我们的猫例子，每个闭包会得到循环的不同的一个复本，而不是每次闭包得到同一个循环变量。</p></li>
</ul>


<p>所以，对于猫这例子说，将<code>var</code>修改为<code>let</code>就可以解决之前的问题。</p>

<p>这作用于所有的三类<code>for</code>循环表达式：for-of, for-in 和老式C语言的分号方式。</p>

<ul>
<li><strong>在没有遇到<code>let</code>声明之前使用变量会出错</strong>  当控制流没有到达变量声明的代码行时，其是未初始化的。例如：</li>
</ul>


<pre><code class="js">function update() {
  console.log("current time:", t); //ReferenceError
  ...
  let t = readTachymeter(); 
}
</code></pre>

<p>这一规则可以帮助你抓取到Bug。结果并不是<code>NaN</code>，你将会在出现问题的代码行中得到一个异常。</p>

<p>这个变量在作用域但并没有被初始化的这一区域，被称为 <em>temporal deal zone</em>(临时死区间)。我一直等待更为专业的术语来描述这事情，就像在写科幻小说一样，然而没有。</p>

<p>（性能详情：在多数情况下，（在变量查找方式中）你可以告知变量是否声明，或者不仅仅去查找相关代码。所以，JS引擎实际上并不是每次都会进行额外的检查，以确认变量是否初始化。但是，在闭包中有时是不明确的，在这些情况下，就意味着使用<code>let</code>会比<code>var</code>慢。）</p>

<p>（作用域详情：在某些编程语言中，变量的作用域开始于其声明的地方，而不是在整个闭合的代码中向后查找。标准委员会认为可以通过<code>let</code>来使用这作用域规则。如此，当<code>t</code>在<code>let t</code>的语句后面调用时，会简单得到一个引用错误，所以，它也不会关联到任一变量。它应该在闭合的作用域中关联到变量<code>t</code>上，但这方法对于闭包或者函数式的升域都是无效的，所以它实际上会被忽略掉。）</p>

<ul>
<li><strong>重复声明变量会引起语法错误</strong> 这一规则也是利于检测细小的错误。同时，它的不同点还有：当你试图将全局的<code>let</code>转化为<code>var</code>，会导致些问题，因为它曾经是个全局<code>let</code>的变量。</li>
</ul>


<p>如果你的某些脚本声明了相同的全局变量，你最好保持使用<code>var</code>。如果你试图转化为<code>let</code>时，那些第二个用到此变量的脚本会出错的。</p>

<p>或者，使用ES6的模块，但是那是之后某天的故事了。</p>

<p>（语法详情：<code>let</code>是在严格的代码模式下是保留关键它。在非严格代码模式下，为了向后兼容，你依然可以声明变量、函数和参数的名称为<code>let</code>。你可以编写<code>var let = 'q';</code>，但你最好不要这让做。同时，<code>let let;</code>也是不允许的。）</p>

<p>除了这些不一样的地方，<code>let</code>和<code>var</code>其实是一样的。它们可以通过逗号来分开声明多个变量，例如，他们也都支持解构(释构？destructuring)。</p>

<p>注意，类<code>class</code>的声明类似于<code>let</code>，而不<code>var</code>。如果你在加载的脚本中多个声明一个类<code>class</code>，在第二次时你会因为重复声明类而得到一个错误。</p>

<h4>常量(const)</h4>

<p>是的，新的东西。</p>

<p>ES6介绍了一个三方的关键字，它可以在<code>let</code>的旁边使用: <code>const</code>。</p>

<p>使用<code>const</code>声明变量类似于<code>let</code>，但不能在声明之外对它进行赋值，这会引起一个语法错误。</p>

<pre><code class="js">const MAX_CAT_SIZE_KG = 3000; //

MAX_CAT_SIZE_KG = 5000; // SyntaxError
MAX_CAT_SIZE_KG++; // nice try, but still a SyntaxError
</code></pre>

<p>明显够了，你不能只声明一个<code>const</code>变量而不赋值：</p>

<pre><code class="js">const theFairest; // SyntaxError, you troublemaker
</code></pre>

<h4>命名空间的秘密</h4>

<p><em>&#8220;命名空间是一个非常好的主意 &#8211; 让我们更多地使用它&#8221; &#8211; Tim Peters，&#8221;Python 的秘决&#8221;</em></p>

<p>在私底下，内嵌式的作用域是始终围绕编程语言的一个核心概念。自从<a href="https://en.wikipedia.org/wiki/ALGOL">ALGOL</a> 出来后一直就是这样，已经大概有57年了，但对今天来说，此结论更为正确。</p>

<p>在ES3之前，JS只有全局的任务域和函数作用域。（让我们忽略掉<code>with</code>表达式。）ES3介绍了<code>try-catch</code>的表达式，它会增加一个新类型的作用域，此作用域只用来操作异常的变量并作用于<code>catch</code>代码块。ES5通过调用<code>eval()</code>会产生一个新的作用域。ES6添加了代码块作用域，for循环作用域，新的全局<code>let</code>作用域，模块作用域，还有用来解释参数中默认参数的额外作用域。</p>

<p>所有在ES3之后添加的作用域都是必要的，它们使得JS在程序上和面向对象特性上更合理、精确、直观，就如闭包一样；同时，可以和闭包无缝协作。也许你之前并没有注意到这些作用域的规则，如果是这样，说明JS做的工作并没有困扰你。</p>

<h4>现在我能使用<code>let</code>和<code>const</code>吗？</h4>

<p>可以。为了在Web中使用它们，你不得不使用ES6的编译器，如Babel, Traceur, 或者 TypeScript。（Babel 和 Traceur 并不支持 <em>temporal deal zone</em>(临时死区间)。）</p>

<p>io.js 支持<code>let</code>和<code>const</code>，但只能在严格模式下使用，Node.js 在支持上是一样的，但参数<code>--harmony</code>也是必要的。</p>

<p>Brendan Eich 在九年前实现了Firefox中<code>let</code>的第一个版本，这一特性在其标准化进程中进行了彻底的重新设计。为了符合标准，Shu-yu Guo 更新了此实现方式，代码审核由Jeff Walden和其它人完成。</p>

<p>好了，我们展开双手来欢迎新特性。ES6史诗级的特性到现在结束了。在之前两周中，我们完成了多数人渴望在ES6看到的特性的文章。但是首先要说明，下周我们将对之前早些时间提到的新特性：super。所以，和Eric Faust 一块加入我们，深入了解ES6的子类化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: Classes]]></title>
    <link href="http://shatle.github.io/blog/2016/02/23/es6-in-depth-classes/"/>
    <updated>2016-02-23T23:04:55+08:00</updated>
    <id>http://shatle.github.io/blog/2016/02/23/es6-in-depth-classes</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/07/es6-in-depth-classes/">ES6 In Depth: Classes</a></p></blockquote>

<p>今天，我们可以从这一系列的之前复杂的文章中得到些喘息的机会。现在没有新的、没见过的 生成器、代理，这些会影响JS内部运算逻辑的hook，没有新的数据结构可去除用户自己的需求解决方案。相反，我们来讨论些语法性的、惯用的、待解释清楚的旧问题：JS中的对象构建器。</p>

<h4>问题</h4>

<p>我们想要创建一个最为精典的面向对象原则的例子：圆形类。想象一下，我们为一个画布的库编写一个圆形类。在所有事情中，我们需要知道怎么做到以下项：</p>

<ul>
<li>在一画布中画一个圆形</li>
<li>记录画布中圆形的所有数量</li>
<li>记录每一圆形的半径，并确定如何读写这值</li>
<li>计算圆形的面积</li>
</ul>


<p>这用JS的语言可以这么说：我们首先应该创建一个函数构建器，然后为这个函数增加必要的属性，接着使用一个对象来替换构建器中的<code>prototype</code>的属性。当我们开始创建一个实例对象时，这个<code>prototype</code>对象会包含所有属性。即使一个简单的例子，当你输入所有数据时，多数这样的模板也就完成了：</p>

<pre><code class="js">function Circle(radius) {
  this.radius = radius;
  Circle.circlesMade++;
}

Circle.draw = function draw(circle, canvas) { /* Canvas drawing code */ }

Object.defineProperty(Circle, "circlesMade", {
  get: function() {
    return !this._count ? 0 : this._count;
  },

  set: function(val) {
    this._count = val;
  }
});

Circle.prototype = {
  area: function area() {
    return Math.pow(this.radius, 2) * Math.PI;
  }
};

Object.defineProperty(Circle.prototype, "radius", {
  get: function() {
    return this._radius;
  },

  set: function() {
    if (!Number.isInteger(radius))
      throw new Error("Circle radius must be an integer");
    this._radius = radius;
  }
});
</code></pre>

<p>这代码不仅仅很繁琐，它还离理想的有些远。它要求对函数的工作方式拥有很好的理解，这很重要，同时，了解各种将属性设置到创建的实例对象中。如果这方法看起来很复杂，不要担心。这整篇文章的目的就是展示一种很简单的方式来做到这些事情。</p>

<h4>定义方法的语法</h4>

<p>在第一次尝试新方法之前，ES6提供了一种新的语法来为一个对象增加特殊的属性。对于上面的例子，它可以很容易地为<code>Circle.prototype</code>添加<code>area</code>的方法，它会让 <code>radius</code>的setter/getter方法更为有效些。作为JS一个面向对象的新方法，人们很乐意去使用一个设计更为精简的对象访问方式。我们需要一个新的方式来为一个对象增加方法，比如添加时如<code>obj.prop = method</code>，而不需要<code>Object.defineProperty</code>这么笨重。人们希望可以让下列的事情更为简单：</p>

<ol>
<li>为一个对象增加普通的函数属性。</li>
<li>为一个对象增加生成器函数属性。</li>
<li>为一个对象增加普通的访问函数属性。</li>
<li>为一个已经完成的对象，通过<code>[]</code>来进行以上三种的操作。我们将这称为 <em>计算属性名称</em>(<em>Computed property names</em>)。</li>
</ol>


<p>有些事情在之前不能操作的。例如，没有一种方式来为<code>obj.prop</code>定义setter和getter方法。因此，新的语法是必定要添加的。你现在可以类似编写如下代码：</p>

<pre><code class="js">var obj = {
  // Methods are now added without a function keyword, using the name of the
  // property as the name of the function.
  method(args) { ... },

  // To make a method that's a generator instead, just add a '*', as normal.
  *genMethod(args) { ... },

  // Accessors can now go inline, with the help of |get| and |set|. You can
  // just define the functions inline. No generators, though.

  // Note that a getter installed this way must have no arguments
  get propName() { ... },

  // Note that a setter installed this way must have exactly one argument
  set propName(arg) { ... },

  // To handle case (4) above, [] syntax is now allowed anywhere a name would
  // have gone! This can use symbols, call functions, concatenate strings, or
  // any other expression that evaluates to a property id. Though I've shown
  // it here as a method, this syntax also works for accessors or generators.
  [functionThatReturnsPropertyName()] (args) { ... }
};
</code></pre>

<p>利用新的语法，我们可以编写如下</p>

<pre><code class="js">function Circle(radius) {
  this.radius = radius;
  Circle.circlesMade++;
}

Circle.draw = function draw(circle, canvas) { /* Canvas drawing code */ }

Object.defineProperty(Circle, "circlesMade", {
  get: function() {
    return !this._count ? 0 : this._count;
  },

  set: function(val) {
    this._count = val;
  }
});

Circle.prototype = {
  area() {
    return Math.pow(this.radius, 2) * Math.PI;
  },

  get radius() {
    return this._radius;
  },
  set radius(radius) {
    if (!Number.isInteger(radius))
      throw new Error("Circle radius must be an integer.");
    this._radius = radius;
  }
};
</code></pre>

<p>显然，这代码与之前的并不完全一样。这里的对象方法定义是可以配置和可列举的，但是在开始的代码中并不没有配置和列举。在实践中，这是很少会引起注意，我为了简洁会减少之前的其中列举和配置。</p>

<p>接着，这代码是不是更好些了，对不对？不幸的是，即使有新的方法定义语法，我们还是没有很多方式来定义<code>Circle</code>，就如我们必须定义函数。没有方法当你在定义函数时，又可以访问其属性。</p>

<h4>类定义语法</h4>

<p>尽管上面代码比较开始的代码已有改进了，但是它依然未达到人们想要的结果，人们希望在JS中有一个简洁的面向对象的解决方案。其它编程语言中有一结构来处理面向对象设计，他们称这结构为类(<em>class</em>)。</p>

<p>这很合理。接着，让我们开始添加类。</p>

<p>我们希望有一个系统，它允许我们增加一个构造函数的方法，其类似于为<code>.prototype</code>增加方法一般，以至于方法能出现在这个类的所有实例中。后来，我们拥有了喜爱的定义新方法的语法，我们肯定会使用它。然后，我们只需要有一种方式来区分哪个是作用类中所有实例的，哪个是作用特定的实例。在C++或Java，其关键字是<code>static</code>，这看起来也很好，我们使用它。</p>

<p>现在，需要在众多的方法中选择一个来作为构造函数，这很有用。在C++或Java中，它是和类史一样的，并且不会返回类型。因此，JS的构造函数也不会返回类型，同时我们需要一个<code>.constructor</code>的属性，为了向后兼容，让我们把这方法叫做<code>constructor</code>。</p>

<p>把所有的东西结合一起，我们可能重新编写我们的Circle类，结果会是如下：</p>

<pre><code class="js">class Circle {
  constructor(radius) {
    this.radius = radius;
    Circle.circlesMade++;
  };

  static draw(circle, canvas) {
    // Canvas drawing code
  };

  static get circlesMade() {
    return !this._count ? 0 : this._count;
  };

  static set circlesMade(val) {
    thsi._count = val;
  };

  area() {
    return Math.pow(this.radius, 2) * Math.PI;
  };

  get radius() {
    return this._radius;
  };
  set radius(radius) {
    if (!Number.isInteger(radius))
      throw new Error("Circle radius must be an integer.");
    this._radius = radius;
  };
}
</code></pre>

<p>哇！我们不仅可以将与<code>Circle</code>有关的所有方法整合一起，而且所有事情都看起来很好很简洁。这肯定要优于我们开始做的代码。</p>

<p>尽管如此，你可能还存在部分的边界上问题。我在这里预测并定位一些问题：</p>

<ul>
<li><p><strong>分号怎么样？</strong> &#8211; 有个趋向是“使JS类更像传统中的类”，所以我们决定用更传统的分隔符(分号)。不喜欢它？它是可选的，分号不是必须的。</p></li>
<li><p><strong>如果我不想操作构造函数，但又想为已经创建好的对象增加方法，怎么办？</strong> &#8211; 这也可以。这<code>constructor</code>方法也是可选的。如果你没有定义构造函数，系统会默认如你编写<code>constructor() {}</code>。</p></li>
<li><p><strong>构造函数可以是生成器吗？</strong> &#8211; 不！如果添加的构造函数不是普通函数时会出现<code>TypeError</code>的错误，这里生成器和访问器是一样的。</p></li>
<li><p><strong>我能不能定义<code>constructor</code>为一个计算属性名称?</strong> &#8211; 很不幸，不行。那样真的很难被解释到，所以我们不能这样子。如果你为一个计算属性定义一方法，并命名为<code>constructor</code>，你也将会得到一个名为<code>constructor</code>的方法，那么你也不会得到一个类的构造函数了(想要操作方法，又想成为构造函数，那是不可能的)。</p></li>
<li><p><strong>当我修改<code>Circle</code>的值时，会不会错误地生成一个新的Circle?</strong> &#8211; 不！就像函数的表达式一样，类会为给定的名称进行内部的绑定，这绑定不能为外部操作所改变，所以无论你怎么设置Circle的内部作用域中的值，<code>Circle.circlesMade++</code>的值都会是期望中的一样。</p></li>
<li><p><strong>好吧，我可以将一个对象直接作为函数的参数，但新类语法并不能这样子</strong> &#8211; 很幸运，ES6有这类的表达式。它可以命名也可以不命名，表现的效果与上面描述的是一样的，除了ES6不会在声明的作用域创建变量。</p></li>
<li><p><strong>那它有上面提到可列举等恶作功能吗？</strong> &#8211; 人们都想做到这点，所以你可以给对象安装方法，但列举对象的属性时，你只可以获取给这对象增加的属性，这样也更为合理些。因此，类中的安装方法是配置型的，但并不可列举。</p></li>
<li><p><strong>等，哪有实例变量？那static常量？</strong> &#8211; 你打到我了，你提到的这些并没在刚才的ES6的类定义中。但是，有好消息。它些已经和其它一些特性提到规格进程中了。我是十分支持使用<code>static</code>和<code>const</code>在类语法中定义值的。实际上，它已经提到会议上了。我认为，我们可以在将来看到更多有关于此的讨论。</p></li>
<li><p><strong>好的，很好！我能使用它吗？</strong> &#8211; 并不能真正使用，但有些可用的工具(特别是 Babel )，所以今天你可以通过他们来使用类语法。很不幸运，在是所有主流的浏览器中运行还需要些时间。我已经把今天讨论到的都在<a href="https://nightly.mozilla.org/">Nightly version of Firefox</a>中实现了，同时它也在Edge和Chrome实例了，但默认是不打开的。很不幸，现在看来在Safari中并没有实现。</p></li>
<li><p><strong>Java 和 C++ 有子类和super关键字，但这里并没有提到，那JS呢</strong> &#8211; 它可以。但是，这值得另外一文章来进行讨论。注意查看我们之后的关于子类的更新文章，同时我们还将讨论更多的JS类的功能。</p></li>
</ul>


<p>如果没有 Jason Orendorff 和 Jeff Walden 负责的代码检查和指导，我将不会可能实现类。</p>

<p>下周，Jason Orendorff 会在一周的休息后回来，将讨论<code>let</code>和<code>const</code>主题。</p>
]]></content>
  </entry>
  
</feed>
