<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Liu.Shatle]]></title>
  <link href="http://shatle.github.io/atom.xml" rel="self"/>
  <link href="http://shatle.github.io/"/>
  <updated>2018-02-19T10:17:46+08:00</updated>
  <id>http://shatle.github.io/</id>
  <author>
    <name><![CDATA[liu.shatle &hearts; gmail.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[think of interview]]></title>
    <link href="http://shatle.github.io/blog/2018/01/24/think-of-interview/"/>
    <updated>2018-01-24T23:41:53+08:00</updated>
    <id>http://shatle.github.io/blog/2018/01/24/think-of-interview</id>
    <content type="html"><![CDATA[<p>去年，项目组事情比较多，每个人的工作量都有些大，经常加班深夜，导致整体团队都很累，所以，急需招入小伙伴。
在之前的前端人员离职之后，增加开发人员越加紧迫。下面，整理一下面试的体会。</p>

<h4>个人总结</h4>

<p>参与的是技术面试，应试人员过来时会有一份笔试。当应试人员完成试卷时，我们才下去进行真正的面试。
我作为一个辅助的技术面试人员，主要是补充提问。</p>

<p>在面试的过程中，上级领导也给出了些不少的建议，指出改进的地方。</p>

<p><strong>个人介绍</strong></p>

<p>初期，作为技术面试，上来就会对应试人员进行题面的提问。
这里有个问题，忽略了人的基本属性。招聘进来的是人，一个需要参与团队的人，而不是简单的一个技术机器。</p>

<p>个人介绍，通常可以提前准备，也可以没有准备。但无论如何，从中都可以看出应该的基本语言表达能力。或者，如果连这准备都没有，可以看出是否重要此次的面试。</p>

<p>在应试人员的自我介绍时，只需要简单的抓住关键点，了解其基本表达能力。同时，面试人员可以快速的浏览其做题的情况，在心里有个大概的提问方向。</p>

<p><strong>笔试提问</strong></p>

<p>前端的题面，包括js/css/jQuery的基础、算法、工作常遇到的问题等。</p>

<p>js基础，可以看出应试人员在开发过程中的细心程度，但通常工作之后的应试人员表现得都不是很理想，反而是实习生在答案上表现得优异。</p>

<p>做为过来人，是知道其原因的，也很容易理解。实习生有足够的时间来准备各种面试，而还在工作的应试人员就不一样，他们需要完成正常工作中的任务。</p>

<p>需要找到一个基础很好，又有工作经验的人，也不是简单地找一个年限够长的在职人员。关键在于，应试人员是否有意识去注意使用中的细节。</p>

<p>算法，应试人员基本都不怎么样，反而是实习生会好些。前端的工作，了解需求，对接后端的接口，并实现设计人员的交互，最大限度地提升用户体验。通常来说，后端返回的数据会避免过大的数据，以便于处理，致使前端的算法机能表现弱些。</p>

<p>在编程时还是需要注意细节，比如循环与零比较都是可以作为优化的点。现在编程中，习惯使用与underscode类似的lodash进行各操作，ES6也提供了较先进的方法，但最终还是希望有优化编辑的意识。</p>

<p>其中，令我好奇的是，有些人一直使用for循环，而不去寻找更为方便的underscore/lodash工具进行数据处理，这是不是也反应出一部分人对编程没有优化/简化的想法。</p>

<p>工作中遇到的问题，比如如何避免附件缓存等，都是常见的问题。如果实在没有遇到，也是考验应试人员的一个点。但如果面试过程良好，还会话面时进行相关提问。</p>

<p>笔试提问，可以看到应试人员基技术基础好不好，还可以看到其快速理解力，及对题目回答的表达能力等。工作中，这些都是基础的。</p>

<p><strong>话面</strong></p>

<p>抛开题目，进入话面。希望看到应试人员几点：</p>

<ul>
<li><p>生活方面是否适合当前团队。</p>

<p>  应试人员是哪里人，现居住在哪里。作为一个开发人员，工作中可能会有些意料不到事情，是否可以快速反应并到场解决问题。</p>

<p>  工作肯定会有各方面的压力，通常是怎么释放的。工作之余有什么爱好，比如运动、聚会什么的，也是值得参考的。即使碰到对编程极度热爱的人员，通常也会喜欢听歌、看电影。</p>

<p>  是否结婚，有无男女朋友，对象的工作地点，这些也会对是否成功入职有一定的影响，所以也是需要考虑的。</p></li>
<li><p>技术知识点是否是团队需要的。</p>

<p>  技术知识点太多，首先会在简历上做了一层过滤，这可以过滤大部分的不是团队需要的人员。</p>

<p>  另外，出于开放的原则，会对部分未完全匹配的简介给予面试的机会，希望能够找出优秀的人员。</p>

<p>  比如，工作中只使用过 AngularJS 或 VueJS，而现有的工作需求是 React，那么也会给予机会面试。毕竟，很多框架类的东西是相通的。但，没有 React 项目经验的人员，需要注意提问其掌握框架的大致时间，了解其学习、快速上手的能力。</p>

<p>  如果掌握需求匹配的技术，还需要深入的了解技术细节，实践过程中遇到的问题和解决方法。</p></li>
<li><p>理解问题能力</p>

<p>  理解问题，可以从笔试部分了解到。遇到些应试人员，在做笔试部分时就没有读懂题目。这原因可能是一时的疏忽，但本人觉得更多的是没有相应的知识概念，这点并不可耻，毕竟每个人的知识范围都是有限的。</p>

<p>  在话面过程中，我们也会提到一些技术或者其它的问题。通常，这些问题都是根据应试人员的经历来进行提问的，也有些关联性可能较远的问题，试图去了解到应试人员对熟悉领域中的问题是否有快速的反应能力，对不熟悉领域是否有解决和求知的欲望。</p></li>
<li><p>正常沟通能力</p>

<p>  沟通能力，这是必须的，也是很重要的。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[my_coin_work_recently]]></title>
    <link href="http://shatle.github.io/blog/2018/01/17/my-coin-work-recently/"/>
    <updated>2018-01-17T23:46:56+08:00</updated>
    <id>http://shatle.github.io/blog/2018/01/17/my-coin-work-recently</id>
    <content type="html"><![CDATA[<h2>最近的炒币</h2>

<p>最近，有同事比较热衷于炒虚拟币，都是打着区块链的技术，炒各种概念币种。</p>

<p>同事炒了国内的一个井通币，投入几千块钱，翻倍回来了，羡慕这敢行动的行为。</p>

<p>于是，自己也下载了些炒币应用，有火币、OKex、井通这三个，还有其它小的应用。</p>

<p>火币和OKex的交易应用上线美国地区的苹果商店；井通的应用没有上线苹果商店，也没有交易平台；其它只是用来跟进比较，没有使用。</p>

<p>井通币升到0.28时，我想跟进同事的脚步的，但是井通平台的充值只能通过QQ进行转账。确实比较山寨，我在联系充值客服时，没有成功，结果没有充上。结果，第二天就开始下跌了，直到今天0.06左右。</p>

<p>虽然有些庆幸没有入井通这一个坑，但是，我并不因此觉得自己多明智。我在意的是，为什么我没有进去的勇气？</p>

<p>于是上周末，我逼了自己一下，通过火币网卖了1500元的USDT币。但是，很多币币交易只能使用BTC和ETH进行交易，所以我又用USDT买了ETH，由于钱太少了，买不了多少的BTC，交易起来前面的小数点太多。</p>

<p>在买USDT之后，由于USDT的价格比国家的汇率要高很多，所以，买完之后，显示的价值已经少了100多块了。接着，交易ETH之后，手续费需要0.2%，同时当前的ETH又在下跌，整体看，少了二百多块。</p>

<p>前段时间我得到的结果时，只有新币发行时，才会有比较大的上涨幅度，类似于新股上市；发行比较久的币种上涨比较小，并且多数是在下跌的。</p>

<p>所以，<strong>只买卖新币种</strong>。</p>

<p>不幸的是，整体的币种价值在下跌，我的原始资本一直在消耗。所以，决定开始行动。</p>

<p>中午，12点有发行新币种 THETA，我晚些进场，没有赶上较低的时候，当前已经比发行价上升了30%多。我直接买进，十几分钟后，在发行价45%左右出手，换回了ETH，赚了点。</p>

<p>下午2点又有新币种LET，根据上个经验，我快手地进入效果界面，直接交易出了所有的 ETH，但是，我回头一看，当前的涨幅已经是发行价的200%以上了，不到一分钟，就这个状态了，当我意识到时，已经下跌到60%多了，价值直接扣半，后悔。</p>

<p><strong>买卖不能心急，宁愿错过，不能做错</strong></p>

<p>需要看清本质，翻两倍肯定是危险的，不可取的。三天不到，资产减过半。</p>

<p><strong>做事要勇敢，不能心急，但不要怯于尝试</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[react-dnd intro-2]]></title>
    <link href="http://shatle.github.io/blog/2016/09/27/react-dnd-intro-2/"/>
    <updated>2016-09-27T01:37:17+08:00</updated>
    <id>http://shatle.github.io/blog/2016/09/27/react-dnd-intro-2</id>
    <content type="html"><![CDATA[<h2>react-dnd 简析 2</h2>

<p>上篇文章有说到场景：卡片在不同的容器之间来回拖动。下面，对上篇文章中的代码整理一下：</p>

<h4>上期代码</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// ItemTypes</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">ItemTypes</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">CARD</span><span class="o">:</span> <span class="s1">&#39;Card&#39;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Card</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">Card</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="p">{</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">connectDragSource</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">connectDragSource</span><span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">div</span>  <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">card</span><span class="p">}</span> <span class="o">&gt;</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">text</span><span class="p">}</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">cardSource</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">beginDrag</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">id</span><span class="o">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">index</span><span class="o">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">text</span><span class="o">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">text</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">boxId</span><span class="o">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">boxid</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">isDragging</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">props</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">monitor</span><span class="p">.</span><span class="nx">getItem</span><span class="p">().</span><span class="nx">id</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">dragCollect</span><span class="p">(</span><span class="nx">connect</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">connectDragSource</span><span class="o">:</span> <span class="nx">connect</span><span class="p">.</span><span class="nx">dragSource</span><span class="p">(),</span>
</span><span class='line'>    <span class="nx">isDragging</span><span class="o">:</span> <span class="nx">monitor</span><span class="p">.</span><span class="nx">isDragging</span><span class="p">()</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">let</span> <span class="nx">DragCard</span> <span class="o">=</span> <span class="nx">DragSource</span><span class="p">(</span> <span class="nx">ItemTypes</span><span class="p">.</span><span class="nx">CARD</span><span class="p">,</span> <span class="nx">cardSource</span><span class="p">,</span> <span class="nx">dragCollect</span><span class="p">)(</span> <span class="nx">Card</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kr">export</span> <span class="k">default</span> <span class="nx">DragCard</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// CardBox</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">CardBox</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="p">{</span> <span class="nx">children</span><span class="err">，</span><span class="nx">connectDropTarget</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">connectDropTarget</span><span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">cardBox</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="p">{</span> <span class="nx">children</span> <span class="p">}</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">cardBoxTarget</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">hover</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">,</span> <span class="nx">component</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">hoverCard</span> <span class="o">=</span> <span class="nx">monitor</span><span class="p">.</span><span class="nx">getItem</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">hoverCard</span><span class="p">.</span><span class="nx">id</span> <span class="o">&amp;&amp;</span> <span class="nx">props</span><span class="p">.</span><span class="nx">boxid</span> <span class="o">!=</span> <span class="nx">card</span><span class="p">.</span><span class="nx">boxId</span><span class="p">){</span>
</span><span class='line'>      <span class="nx">props</span><span class="p">.</span><span class="nx">changeCard</span><span class="p">(</span><span class="nx">hoverCard</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span> <span class="nx">props</span><span class="p">.</span><span class="nx">boxid</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">dropCollect</span><span class="p">(</span><span class="nx">connect</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">connectDropTarget</span><span class="o">:</span> <span class="nx">connect</span><span class="p">.</span><span class="nx">dropTarget</span><span class="p">()</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">let</span> <span class="nx">DropCardBox</span> <span class="o">=</span> <span class="nx">DropTarget</span><span class="p">(</span><span class="nx">ItemTypes</span><span class="p">.</span><span class="nx">CARD</span><span class="p">,</span> <span class="nx">cardBoxTarget</span><span class="p">,</span> <span class="nx">dropCollect</span><span class="p">)(</span><span class="nx">CardBox</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kr">export</span> <span class="k">default</span> <span class="nx">DropCardBox</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Kanban</span>
</span><span class='line'>
</span><span class='line'><span class="kr">class</span> <span class="nx">Kanban</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">cards</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 1&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 2&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 3&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 4&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span>
</span><span class='line'>      <span class="p">],</span>
</span><span class='line'>      <span class="nx">boxes</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">1</span><span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">2</span><span class="p">}</span>
</span><span class='line'>      <span class="p">]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">changeCard</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">newBoxId</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">dragCard</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">cards</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dragCard</span><span class="p">){</span> <span class="k">return</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">dragCard</span><span class="p">.</span><span class="nx">boxId</span> <span class="o">=</span> <span class="nx">newBoxId</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">update</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">cards</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">$splice</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>          <span class="p">[</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span><span class='line'>          <span class="p">[</span><span class="nx">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">dragCard</span><span class="p">]</span>
</span><span class='line'>        <span class="p">]</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}));</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">div</span> <span class="o">&gt;</span>
</span><span class='line'>        <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">boxes</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="nx">box</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="nx">CardBox</span>
</span><span class='line'>              <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;cb-&#39;</span><span class="o">+</span><span class="nx">box</span><span class="p">.</span><span class="nx">boxId</span><span class="p">}</span>
</span><span class='line'>              <span class="nx">changeCard</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">changeCard</span><span class="p">}</span>
</span><span class='line'>              <span class="nx">boxid</span><span class="o">=</span><span class="p">{</span><span class="nx">box</span><span class="p">.</span><span class="nx">boxId</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>              <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">cards</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="p">(</span><span class="nx">card</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">boxId</span><span class="o">==</span><span class="nx">card</span><span class="p">.</span><span class="nx">boxId</span><span class="p">)</span>
</span><span class='line'>                  <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>                    <span class="o">&lt;</span><span class="nx">Card</span>
</span><span class='line'>                      <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;c-&#39;</span><span class="o">+</span><span class="nx">card</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">id</span><span class="o">=</span><span class="p">{</span><span class="nx">card</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">index</span><span class="o">=</span><span class="p">{</span><span class="nx">index</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">boxid</span><span class="o">=</span><span class="p">{</span><span class="nx">card</span><span class="p">.</span><span class="nx">boxId</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">text</span><span class="o">=</span><span class="p">{</span><span class="nx">card</span><span class="p">.</span><span class="nx">text</span><span class="p">}</span>
</span><span class='line'>                      <span class="o">/&gt;</span>
</span><span class='line'>                  <span class="p">)</span>
</span><span class='line'>                <span class="k">else</span> <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span><span class='line'>               <span class="p">})}</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="err">/CardBox&gt;</span>
</span><span class='line'>          <span class="p">)</span>
</span><span class='line'>        <span class="p">})}</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">export</span> <span class="k">default</span> <span class="nx">DragDropContext</span><span class="p">(</span><span class="nx">HTML5Backend</span><span class="p">)(</span><span class="nx">Kanban</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这四个文件，<code>ItemTypes.js</code>/<code>Card.js</code>/<code>CardBox.js</code>/<code>Kanban.js</code> 为基本的模型文件，样式文件应该也要有的，这里就贴了。</p>

<h4>新需求</h4>

<p>对于看板来说，不同容器间的来回拖动是必要的。同时，如果想在单个容器中上下拖动，又需要怎么实现？</p>

<p>由于上篇文章的<code>changeCard(index, newBoxId)</code>只能调整卡片的<code>boxId</code>的属性，并不能改变其同一容器中的上下位置，所以需要调整一下，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// 增加一个参数 newIndex</span>
</span><span class='line'><span class="nx">changeCard</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">newBoxId</span><span class="p">,</span> <span class="nx">newIndex</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kr">const</span> <span class="nx">dragCard</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">cards</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dragCard</span><span class="p">){</span> <span class="k">return</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">newBoxId</span> <span class="o">&amp;&amp;</span> <span class="nx">dragCard</span><span class="p">.</span><span class="nx">boxId</span> <span class="o">!=</span> <span class="nx">newBoxId</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">dragCard</span><span class="p">.</span><span class="nx">boxId</span> <span class="o">=</span> <span class="nx">newBoxId</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">update</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">cards</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">$splice</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>          <span class="p">[</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span><span class='line'>          <span class="p">[</span><span class="nx">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">dragCard</span><span class="p">]</span>
</span><span class='line'>        <span class="p">]</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}));</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">newIndex</span> <span class="o">&amp;&amp;</span> <span class="nx">index</span> <span class="o">!=</span> <span class="nx">newIndex</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// newIndex 当卡片拖动到某个卡片的上面时，</span>
</span><span class='line'>    <span class="c1">// newIndex 就是此某个卡片的 index</span>
</span><span class='line'>    <span class="c1">// 将拖动的卡片 剪切到 此位置上</span>
</span><span class='line'>    <span class="c1">//</span>
</span><span class='line'>    <span class="c1">// dragCard.index ~= newIndex</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">update</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">cards</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">$splice</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>          <span class="p">[</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span><span class='line'>          <span class="p">[</span><span class="nx">newIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">dragCard</span><span class="p">]</span>
</span><span class='line'>        <span class="p">]</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}))</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过调整 <code>index</code> 的值来达到位置上的变化。</p>

<hr />

<p>当卡片拖动到另一卡片上面时，需要获取到这一卡片的 <code>index</code> 的值，再将拖动卡片设置到新的位置上。</p>

<p>那么，需要将<code>Card</code>设置为可接受的容器<code>DropTarget</code>。</p>

<p>参考之前的<code>CardBox</code>,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">cardTarget</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">hover</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">,</span> <span class="nx">component</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">dragIndex</span> <span class="o">=</span> <span class="nx">monitor</span><span class="p">.</span><span class="nx">getItem</span><span class="p">().</span><span class="nx">index</span><span class="p">;</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">hoverIndex</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">index</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Don&#39;t replace items with themselves</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">dragIndex</span> <span class="o">===</span> <span class="nx">hoverIndex</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Determine rectangle on screen</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">hoverBoundingRect</span> <span class="o">=</span> <span class="nx">findDOMNode</span><span class="p">(</span><span class="nx">component</span><span class="p">).</span><span class="nx">getBoundingClientRect</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Get vertical middle</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">hoverMiddleY</span> <span class="o">=</span> <span class="p">(</span><span class="nx">hoverBoundingRect</span><span class="p">.</span><span class="nx">bottom</span> <span class="o">-</span> <span class="nx">hoverBoundingRect</span><span class="p">.</span><span class="nx">top</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Determine mouse position</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">clientOffset</span> <span class="o">=</span> <span class="nx">monitor</span><span class="p">.</span><span class="nx">getClientOffset</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Get pixels to the top</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">hoverClientY</span> <span class="o">=</span> <span class="nx">clientOffset</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">hoverBoundingRect</span><span class="p">.</span><span class="nx">top</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Only perform the move when the mouse has crossed half of the items height</span>
</span><span class='line'>    <span class="c1">// When dragging downwards, only move when the cursor is below 50%</span>
</span><span class='line'>    <span class="c1">// When dragging upwards, only move when the cursor is above 50%</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Dragging downwards</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">dragIndex</span> <span class="o">&lt;</span> <span class="nx">hoverIndex</span> <span class="o">&amp;&amp;</span> <span class="nx">hoverClientY</span> <span class="o">&lt;</span> <span class="nx">hoverMiddleY</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Dragging upwards</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">dragIndex</span> <span class="o">&gt;</span> <span class="nx">hoverIndex</span> <span class="o">&amp;&amp;</span> <span class="nx">hoverClientY</span> <span class="o">&gt;</span> <span class="nx">hoverMiddleY</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Time to actually perform the action</span>
</span><span class='line'>    <span class="nx">props</span><span class="p">.</span><span class="nx">changeCard</span><span class="p">(</span><span class="nx">dragIndex</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">hoverIndex</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Note: we&#39;re mutating the monitor item here!</span>
</span><span class='line'>    <span class="c1">// Generally it&#39;s better to avoid mutations,</span>
</span><span class='line'>    <span class="c1">// but it&#39;s good here for the sake of performance</span>
</span><span class='line'>    <span class="c1">// to avoid expensive index searches.</span>
</span><span class='line'>    <span class="nx">monitor</span><span class="p">.</span><span class="nx">getItem</span><span class="p">().</span><span class="nx">index</span> <span class="o">=</span> <span class="nx">hoverIndex</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上参考官方的例子，通过 <code>component</code>来获取纵向属性，来准确得到 <code>newIndex</code> 参数。
当拖动的高度没有达到卡片一半时，不会触发<code>changeCard(..)</code>方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">dropCollect</span><span class="p">(</span><span class="nx">connect</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">connectDropTarget</span><span class="o">:</span> <span class="nx">connect</span><span class="p">.</span><span class="nx">dropTarget</span><span class="p">()</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">let</span> <span class="nx">DropCard</span> <span class="o">=</span> <span class="nx">DropTarget</span><span class="p">(</span><span class="nx">ItemTypes</span><span class="p">.</span><span class="nx">CARD</span><span class="p">,</span> <span class="nx">cardTarget</span><span class="p">,</span> <span class="nx">dropCollect</span><span class="p">)(</span><span class="nx">Card</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>dropCollect</code> 基本是一样的。</p>

<p>那么，完成这点之后，<code>Card</code>是可拖动的，又是可以容器，
所以，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Card</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">Card</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="p">{</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">isDragging</span><span class="p">,</span> <span class="nx">connectDragSource</span><span class="p">,</span> <span class="nx">connectDropTarget</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">opacity</span> <span class="o">=</span> <span class="nx">isDragging</span> <span class="o">?</span> <span class="mf">0.5</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nx">connectDragSource</span><span class="p">(</span> <span class="nx">connectDropTarget</span><span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">card</span><span class="p">}</span>
</span><span class='line'>        <span class="nx">style</span><span class="o">=</span><span class="p">{</span> <span class="p">{</span><span class="nx">opactiy</span><span class="o">:</span> <span class="nx">opacity</span><span class="p">}</span> <span class="p">}</span>
</span><span class='line'>        <span class="o">&gt;</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">text</span><span class="p">}</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span><span class='line'>    <span class="p">));</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">cardSource</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">cardTarget</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">dragCollect</span><span class="p">(</span><span class="nx">connect</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">dropCollect</span><span class="p">(</span><span class="nx">connect</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">let</span> <span class="nx">DropCard</span> <span class="o">=</span> <span class="nx">DropTarget</span><span class="p">(</span><span class="nx">ItemTypes</span><span class="p">.</span><span class="nx">CARD</span><span class="p">,</span> <span class="nx">cardTarget</span><span class="p">,</span> <span class="nx">dropCollect</span><span class="p">)(</span><span class="nx">Card</span><span class="p">);</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">DragCard</span> <span class="o">=</span> <span class="nx">DragSource</span><span class="p">(</span><span class="nx">ItemTypes</span><span class="p">.</span><span class="nx">CARD</span><span class="p">,</span> <span class="nx">cardSource</span><span class="p">,</span> <span class="nx">dragCollect</span><span class="p">)(</span><span class="nx">DropCard</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kr">export</span> <span class="k">default</span> <span class="nx">DragCard</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过最后处绑定，<code>Card</code>的<code>props</code>会多出来个值来<code>connectDragSource</code>/<code>connectDropTarget</code>。</p>

<p>在<code>Card</code>类中，根据 <code>isDragging</code>来判断设置卡片的透明度，这就是为什么之前要重新定义<code>CardSource</code>中的<code>isDragging</code>方法的缘由。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">cardSource</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">beginDrag</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">isDragging</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">props</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">monitor</span><span class="p">.</span><span class="nx">getItem</span><span class="p">().</span><span class="nx">id</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为，当一个拖动卡片的<code>index</code>为<code>1</code>时，<code>dnd</code>默认会其标识为<code>isDragging=true</code>。而，拖动卡片到<code>index=0</code>时，由于<code>changeCard</code>，拖动卡片此时会从<code>1 -&gt; 0</code>，由于<code>isDdragging</code>不会重新判断，所以，显示效果会是：</p>

<blockquote><p>哪个卡片占原拖动卡片的位置，就会是有透明度</p></blockquote>

<p>但这并不是我们所要的，所以，是否能拖动，使用唯一标识<code>id</code>来判断。</p>

<p>还要注意，<code>Kanban</code>中需要传入方法给<code>Card</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//...</span>
</span><span class='line'><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">cards</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="p">(</span><span class="nx">card</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="nx">Card</span>
</span><span class='line'>      <span class="c1">//...</span>
</span><span class='line'>      <span class="nx">changeCard</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">changeCard</span><span class="p">}</span>
</span><span class='line'>     <span class="o">/&gt;</span><span class="p">)</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'><span class="c1">//...</span>
</span></code></pre></td></tr></table></div></figure>


<h4>最后</h4>

<p>真正使用时，还是需要定义<code>DropTarget</code>中的<code>drop</code>方法的，而文中只谈到了<code>hover</code>方法，这部分让大家自己去探索吧。</p>

<p>打完收功。</p>

<h4>后记</h4>

<p>其实，一个插件能不能用，除了了解其用法之外，还可能需要了解其性能。</p>

<p>就本人的5年前的小笔记本来说，200个普通文本卡片还是可以自由拖动的，效果还是可以的。</p>

<p>当到300时，部分快速拖动会失效，可能是排序和渲染上的耗时吧，
好点的机器可能会好点。</p>

<p>另外，从调试过程看出，<code>dnd</code>只会对有数据变化的卡片重新调用<code>render()</code>渲染方法，并不是所有都会重新渲染一遍的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[react-dnd intro]]></title>
    <link href="http://shatle.github.io/blog/2016/09/25/react-dnd-intro/"/>
    <updated>2016-09-25T10:32:16+08:00</updated>
    <id>http://shatle.github.io/blog/2016/09/25/react-dnd-intro</id>
    <content type="html"><![CDATA[<h2>React-dnd 简析</h2>

<p>对于开源插件或者代码来说，我更喜欢推荐其 github 地址，而不是官网地址：</p>

<blockquote><p>https://github.com/gaearon/react-dnd</p></blockquote>

<h4>安装</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>npm install react-dnd -D
</span><span class='line'>npm install react-dnd-html5-backend -D</span></code></pre></td></tr></table></div></figure>


<p><code>react-dnd-html5-backend</code> 是一个必要的可选组件，因为 html5 的拖拽API 支持拖动的阴影，总的来说，这插件是必要的。</p>

<p>详细的各名称就不在此说明了，直接介绍关键点吧。</p>

<h4>基础</h4>

<p>拖拽功能，首先需要知道两个基本的部分：拖起、放下。</p>

<p>拖起，就是鼠标放下并移动的过程；放下，就是鼠标放下拖动元素。
在这一整个过程中，需要声明哪个元素是可以拖动的，哪个元素是可以接收拖动元素的。</p>

<p><code>react-dnd</code> 中，使用 <code>DragSource</code> 来声明拖动的元素，用<code>DropTarget</code>来声明接收拖动元素的容器。</p>

<p>下面将会通过 看板 的常用功能进行相关的介绍。</p>

<p>看板 基本会涉及到 卡片的上下拖动 和 卡片在不同区间的拖动。</p>

<h4>实体 Card, CardBox, Kanban</h4>

<p>为了实现基本的功能，需要拖动的实体 Card 有两个基本属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>id
</span><span class='line'>text // 用于显示卡片
</span><span class='line'>boxId // 用于表示容器间的拖动</span></code></pre></td></tr></table></div></figure>


<p>Card 实体的简单显示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">Card</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="p">{</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">text</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">div</span>  <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">card</span><span class="p">}</span> <span class="o">&gt;</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">text</span><span class="p">}</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>CardBox 容器用来接收 Card, 其属性为</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">boxId</span>
</span></code></pre></td></tr></table></div></figure>


<p>显示代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">CardBox</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="p">{</span> <span class="nx">children</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">cardBox</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="p">{</span> <span class="nx">children</span> <span class="p">}</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>children</code> 表示显示的容器中的多个卡片。</p>

<p>最后，看板的代码就是循环了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Kanban</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">cards</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 1&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 2&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 3&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 4&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span>
</span><span class='line'>      <span class="p">],</span>
</span><span class='line'>      <span class="nx">boxes</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">1</span><span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">2</span><span class="p">}</span>
</span><span class='line'>      <span class="p">]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">div</span> <span class="o">&gt;</span>
</span><span class='line'>        <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">boxes</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="nx">box</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="nx">CardBox</span>
</span><span class='line'>              <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;cb-&#39;</span><span class="o">+</span><span class="nx">box</span><span class="p">.</span><span class="nx">boxId</span><span class="p">}</span>
</span><span class='line'>              <span class="nx">boxid</span><span class="o">=</span><span class="p">{</span><span class="nx">box</span><span class="p">.</span><span class="nx">boxId</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>              <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">cards</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="p">(</span><span class="nx">card</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">boxId</span><span class="o">==</span><span class="nx">card</span><span class="p">.</span><span class="nx">boxId</span><span class="p">)</span>
</span><span class='line'>                  <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>                    <span class="o">&lt;</span><span class="nx">Card</span>
</span><span class='line'>                      <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;c-&#39;</span><span class="o">+</span><span class="nx">card</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">id</span><span class="o">=</span><span class="p">{</span><span class="nx">card</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">index</span><span class="o">=</span><span class="p">{</span><span class="nx">index</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">boxid</span><span class="o">=</span><span class="p">{</span><span class="nx">card</span><span class="p">.</span><span class="nx">boxId</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">text</span><span class="o">=</span><span class="p">{</span><span class="nx">card</span><span class="p">.</span><span class="nx">text</span><span class="p">}</span>
</span><span class='line'>                      <span class="o">/&gt;</span>
</span><span class='line'>                  <span class="p">)</span>
</span><span class='line'>                <span class="k">else</span> <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span><span class='line'>               <span class="p">})}</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="err">/CardBox&gt;</span>
</span><span class='line'>          <span class="p">)</span>
</span><span class='line'>        <span class="p">})}</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>先用 <code>boxes</code> 进行列的划分，再通过其的<code>boxId</code>的判断，来划分 <code>cards</code>对应于哪个列中。</p>

<p>为什么这样子循环来显示卡片，而不是先进行分组，再对组进行渲染。
此处主要考虑到，只想用一个内存来存储所有的卡片。如果分组，即相当于将所有 的卡片分开为多个内存存储，本文不想让其间卡片的内存跳转频繁。</p>

<p>但这实现方法有个缺陷，页面渲染会有空元素，<code>else return ''</code> 会造成一个空的<code>span</code> DOM元素。</p>

<p>所以，注意，此处是用到了卡片的<code>index</code>的。</p>

<p>这是基本实体，它们包含关系为 <code>Kanban &gt; CardBox &gt; Card</code></p>

<h4>DragSource</h4>

<p>api</p>

<blockquote><p>DragSource(type, spec, collect)(MyComponent)</p></blockquote>

<p><code>DragSource</code>， 顾名思义，就是可拖动的元素。在本文场景中，拖动元素就是<code>Card</code>了。</p>

<p>API 中，有必要的三个参数，分别是<code>type</code>, <code>spec</code>，<code>collect</code>。</p>

<h5>type</h5>

<p><code>type</code> 就是可拖动元素的名称，这会与 <code>DropTarget</code> 的 <code>type</code> 有关联。实际中，名称就是一个字符串，
本文场景中，可以有:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">ItemTypes</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">CARD</span><span class="o">:</span> <span class="s1">&#39;Card&#39;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h5>spec</h5>

<p><code>spec</code> 拖动元素的对象，注意，它必须是对象。它定义有四个方法，分别是<code>beginDrag(props, monitor, component)</code>，
<code>endDrag(props, monitor, component)</code>，<code>canDrag(props, monitor)</code>，<code>isDragging(props, monitor)</code>，详细说明可链接到
<a href="http://gaearon.github.io/react-dnd/docs-drag-source.html">Drag Source Specification</a></p>

<p>现在，主要对 <code>beginDrag(props, monitor, component)</code> 和 <code>isDragging(props, monitor)</code> 进行说明。</p>

<p><code>beginDrag(props, monitor, component)</code> 是必须声明的，它要求返回一个普通的对象，例如<code>{ id: props.id }</code>。
其实，它就是将你用的实体，选择拖动使用的属性进行返回。</p>

<p><code>isDragging(props, monitor)</code> 是可选的，是用来判断一个元素是否是在拖动的过滤中。默认下，一个对象是否是拖动中，
dnd 只会在拖动元素的开始拖动时设置其值。为什么要在这里突出说明一下，因为在操作场景中，初始化的设置在拖动的过程中，
很可能会不正确的，所以需要重新定义其方法实现。</p>

<p>在本文场景中，可以</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">cardSource</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">beginDrag</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">id</span><span class="o">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">index</span><span class="o">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">text</span><span class="o">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">text</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">boxId</span><span class="o">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">boxid</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">isDragging</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">props</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">monitor</span><span class="p">.</span><span class="nx">getItem</span><span class="p">().</span><span class="nx">id</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>monitor</code> 和 <code>component</code> 还是需要大家了解一下的。
<code>monitor</code> 就是整合拖动实体和拖动状态的新对象，<code>component</code>粗略可以理解为 DOM 元素。
详情看 <a href="http://gaearon.github.io/react-dnd/docs-drag-source.html">Drag Source Specification</a></p>

<h5>collect</h5>

<p><code>collect</code> 为一个函数，而函数返回的是一个对象。本质起到桥接作用，将拖动元素的属性和拖动状态整合。</p>

<p>本文场景中，<code>collect</code> 可以为，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">dragCollect</span><span class="p">(</span><span class="nx">connect</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">connectDragSource</span><span class="o">:</span> <span class="nx">connect</span><span class="p">.</span><span class="nx">dragSource</span><span class="p">(),</span>
</span><span class='line'>    <span class="nx">isDragging</span><span class="o">:</span> <span class="nx">monitor</span><span class="p">.</span><span class="nx">isDragging</span><span class="p">()</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>综合以上，需要将 <code>Card</code> 声明为可拖动的元素，就是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">DragCard</span> <span class="o">=</span> <span class="nx">DragSource</span><span class="p">(</span> <span class="nx">ItemTypes</span><span class="p">.</span><span class="nx">CARD</span><span class="p">,</span> <span class="nx">cardSource</span><span class="p">,</span> <span class="nx">dragCollect</span><span class="p">)(</span> <span class="nx">Card</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时，需要调整<code>Card</code>类的代码，将绑定引入的属性声明关联到元素中，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">Card</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="p">{</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">connectDragSource</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">connectDragSource</span><span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">div</span>  <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">card</span><span class="p">}</span> <span class="o">&gt;</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">text</span><span class="p">}</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>DropTarget</h4>

<p>api</p>

<blockquote><p>DropTarget(types, spec, collect)(MyComponent)</p></blockquote>

<p>就是接收拖动元素的容器元素。</p>

<h5>types</h5>

<p>注意，第一个参数是 <code>types</code>，也就是说，它可以接收多种类型，但也可以是字符串。本文场景中，就是<code>ItemTypes.CARD</code>。</p>

<h5>spec</h5>

<p>同样是普通对象，但不同于拖动元素，容器元素中的说明参数中的方法有<code>drop(props, monitor, component)</code>，<code>hover(props, monitor, component)</code>，<code>canDrop(props, monitor)</code>。</p>

<p><code>hover(props, monitor, component)</code> 这里重点说一下此方法，因为这个比较常用，当然<code>drop</code>也很常用，但主要与后台交互时才会用到。比如，不同容器中的拖动，需要将放下时的<code>boxId</code>保存到后台，而<code>hover</code>是实时变化的，不适合与后台交互的action进行数据操作。</p>

<p>在拖动元素从一个容器元素，到另一容器元素时，其的<code>boxid</code>会发生变化，这才合理。</p>

<p>所以，需要在 <code>CardBox</code> 的中定义 <code>changeCard(index, newBoxId)</code> 的方法。
其中， <code>index</code>是所有<code>cards</code>列表中的<code>index</code>。</p>

<p>本文场景中，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">cardBoxTarget</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">hover</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">,</span> <span class="nx">component</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">hoverCard</span> <span class="o">=</span> <span class="nx">monitor</span><span class="p">.</span><span class="nx">getItem</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">hoverCard</span><span class="p">.</span><span class="nx">id</span> <span class="o">&amp;&amp;</span> <span class="nx">props</span><span class="p">.</span><span class="nx">boxid</span> <span class="o">!=</span> <span class="nx">card</span><span class="p">.</span><span class="nx">boxId</span><span class="p">){</span>
</span><span class='line'>      <span class="nx">props</span><span class="p">.</span><span class="nx">changeCard</span><span class="p">(</span><span class="nx">hoverCard</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span> <span class="nx">props</span><span class="p">.</span><span class="nx">boxid</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h5>collect</h5>

<p>类似于<code>DropSource</code>中的<code>collect</code>, 由于是容器，则没有拖动的属性了。</p>

<p>本文场景中，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">dropCollect</span><span class="p">(</span><span class="nx">connect</span><span class="p">,</span> <span class="nx">monitor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">connectDropTarget</span><span class="o">:</span> <span class="nx">connect</span><span class="p">.</span><span class="nx">dropTarget</span><span class="p">()</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>综合上面，将<code>BoxCard</code>声明为拖动容器，就是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">DropCardBox</span> <span class="o">=</span> <span class="nx">DropTarget</span><span class="p">(</span><span class="nx">ItemTypes</span><span class="p">.</span><span class="nx">CARD</span><span class="p">,</span> <span class="nx">cardBoxTarget</span><span class="p">,</span> <span class="nx">dropCollect</span><span class="p">)(</span><span class="nx">CardBox</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时，绑定后，需要在模型中关联渲染的元素，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">CardBox</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="p">{</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">connectDropTarget</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">connectDropTarget</span><span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">cardBox</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="p">{</span> <span class="nx">children</span> <span class="p">}</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>另外</h4>

<p>基本上，上面大致介绍了一个卡片在不同的容器间相互拖动的故事。</p>

<p>另外，需要指出的是，<code>react-dnd</code> 所有的元素需要使用 <code>DragDropContext</code> 来包裹起来，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">DragDropContext</span><span class="p">(</span><span class="nx">HTML5Backend</span><span class="p">)(</span><span class="nx">Kanban</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面其中有提到，卡片中容器间相互拖动，需要改变其 <code>boxId</code> 的值，
那么，需要在<code>CardBox</code>中传入<code>changeCard(index, newBoxId)</code> 方法属性。
所以，<code>Kanban</code>需要调整为</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Kanban</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">cards</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 1&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 2&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 3&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;card 4&#39;</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span>
</span><span class='line'>      <span class="p">],</span>
</span><span class='line'>      <span class="nx">boxes</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">1</span><span class="p">},</span>
</span><span class='line'>        <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">boxId</span><span class="o">:</span> <span class="mi">2</span><span class="p">}</span>
</span><span class='line'>      <span class="p">]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">changeCard</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">newBoxId</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">dragCard</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">cards</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dragCard</span><span class="p">){</span> <span class="k">return</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">dragCard</span><span class="p">.</span><span class="nx">boxId</span> <span class="o">=</span> <span class="nx">newBoxId</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">update</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">cards</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">$splice</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>          <span class="p">[</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span><span class='line'>          <span class="p">[</span><span class="nx">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">dragCard</span><span class="p">]</span>
</span><span class='line'>        <span class="p">]</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}));</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">div</span> <span class="o">&gt;</span>
</span><span class='line'>        <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">boxes</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="nx">box</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="nx">CardBox</span>
</span><span class='line'>              <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;cb-&#39;</span><span class="o">+</span><span class="nx">box</span><span class="p">.</span><span class="nx">boxId</span><span class="p">}</span>
</span><span class='line'>              <span class="nx">changeCard</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">changeCard</span><span class="p">}</span>
</span><span class='line'>              <span class="nx">boxid</span><span class="o">=</span><span class="p">{</span><span class="nx">box</span><span class="p">.</span><span class="nx">boxId</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>              <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">cards</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="p">(</span><span class="nx">card</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">boxId</span><span class="o">==</span><span class="nx">card</span><span class="p">.</span><span class="nx">boxId</span><span class="p">)</span>
</span><span class='line'>                  <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>                    <span class="o">&lt;</span><span class="nx">Card</span>
</span><span class='line'>                      <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;c-&#39;</span><span class="o">+</span><span class="nx">card</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">id</span><span class="o">=</span><span class="p">{</span><span class="nx">card</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">index</span><span class="o">=</span><span class="p">{</span><span class="nx">index</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">boxid</span><span class="o">=</span><span class="p">{</span><span class="nx">card</span><span class="p">.</span><span class="nx">boxId</span><span class="p">}</span>
</span><span class='line'>                      <span class="nx">text</span><span class="o">=</span><span class="p">{</span><span class="nx">card</span><span class="p">.</span><span class="nx">text</span><span class="p">}</span>
</span><span class='line'>                      <span class="o">/&gt;</span>
</span><span class='line'>                  <span class="p">)</span>
</span><span class='line'>                <span class="k">else</span> <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span><span class='line'>               <span class="p">})}</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="err">/CardBox&gt;</span>
</span><span class='line'>          <span class="p">)</span>
</span><span class='line'>        <span class="p">})}</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rspec practices 1]]></title>
    <link href="http://shatle.github.io/blog/2016/04/23/rspec-practices-1/"/>
    <updated>2016-04-23T18:17:16+08:00</updated>
    <id>http://shatle.github.io/blog/2016/04/23/rspec-practices-1</id>
    <content type="html"><![CDATA[<p>U should add gem <code>rspec-rails</code> in ur project&#8217;s Gemfile, then bundle.</p>

<p>Then, u need run command <code>rails g rspec:install</code>.</p>

<p>When u use rails commands, likes <code>rails g model User xx:xx</code>. It will help u to create <code>spec/models/user_spec.rb</code> file.</p>

<p>Yes, Rspec will check <code>_spec.rb</code> file as test file.</p>

<p>Give me some codes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;rails_helper&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="no">RSpec</span><span class="o">.</span><span class="n">describe</span> <span class="no">User</span><span class="p">,</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:model</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">context</span> <span class="s2">&quot;signup with&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">it</span> <span class="s2">&quot;email and password, then success.&quot;</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">expect</span><span class="p">(</span><span class="no">User</span><span class="o">.</span><span class="n">signup</span><span class="p">(</span><span class="s2">&quot;123@exmaple.com&quot;</span><span class="p">,</span> <span class="s2">&quot;123456&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="n">it</span> <span class="s2">&quot;illege email and password, then fail.&quot;</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">expect</span><span class="p">(</span><span class="no">User</span><span class="o">.</span><span class="n">signup</span><span class="p">(</span><span class="s2">&quot;123sdf&quot;</span><span class="p">,</span> <span class="s2">&quot;123456&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">it</span> <span class="s2">&quot;email and no password, then fail. &quot;</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">expect</span><span class="p">(</span> <span class="no">User</span><span class="o">.</span><span class="n">signup</span><span class="p">(</span><span class="s2">&quot;123@example.com&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">size</span> <span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>and then, u can use <code>rspec</code> to test all <code>_spec</code> files,
or u can only test <code>user_spec.rb</code> file with <code>rspec spec/models/user_spec.rb</code> command.</p>

<p>if no error, u can get</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">3</span> <span class="n">examples</span><span class="p">,</span> <span class="mi">0</span> <span class="n">failures</span>
</span></code></pre></td></tr></table></div></figure>


<p>It is not a good view. We just not work for testing, but say something to others.</p>

<p>U can run <code>rspec --format doc</code>,  will get result:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">User</span>
</span><span class='line'>  <span class="n">signup</span> <span class="n">with</span>
</span><span class='line'>    <span class="n">email</span> <span class="ow">and</span> <span class="n">password</span><span class="p">,</span> <span class="k">then</span> <span class="n">success</span><span class="o">.</span>
</span><span class='line'>    <span class="n">illege</span> <span class="n">email</span> <span class="ow">and</span> <span class="n">password</span><span class="p">,</span> <span class="k">then</span> <span class="nb">fail</span><span class="o">.</span>
</span><span class='line'>    <span class="n">email</span> <span class="ow">and</span> <span class="n">no</span> <span class="n">password</span><span class="p">,</span> <span class="k">then</span> <span class="nb">fail</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="mi">3</span> <span class="n">examples</span><span class="p">,</span> <span class="mi">0</span> <span class="n">failures</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: The Future]]></title>
    <link href="http://shatle.github.io/blog/2016/03/20/es6-in-depth-the-future/"/>
    <updated>2016-03-20T17:03:15+08:00</updated>
    <id>http://shatle.github.io/blog/2016/03/20/es6-in-depth-the-future</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-the-future/">ES6 In Depth: The Future</a></p></blockquote>

<p>上周的ES6模块结束了为期四个多月的ES6新特性的这一系列的文章。</p>

<p>这文章主要会包括我们之前未讨论过的众多新特性，它们就如这JS语言大厦中的衣柜和奇怪的房子都是十分有趣的，也许还会一个地下室，或者有两个。如果你没有阅读过这一系统的其它文章，可以看<a href="http://shatle.github.io/blog/categories/shen-ru-es6/">这里</a> 。这文章并不是好的开头。</p>

<p>额外提醒：之前提到的很多特性还没有得到广泛的支持。好了，让我们开始吧。</p>

<h4></h4>

<p>ES6部分特性的标准化来源于之前的其它标准过程，或者部分得到广泛的实现支持而没有标准化。</p>

<ul>
<li><strong>类型数组(Typed arrays)/ArrayBuffer/DataView</strong> 这些是WebGL标准化的一部分，但现在也会运用于其它许多地方的API，包括Canvas、网络音频API和WebRTC。无论你处理多大的二进制文件或者数值数据，都是很方便的。</li>
</ul>


<p>例如，如果你<code>Canvas</code>需要渲染内容时没有你想要的，或者你希望手动操作更为高效时，你可以自己实现它：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;2d&quot;</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">image</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">getImageData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">pixels</span> <span class="o">=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span> <span class="c1">// a Uint8ClampedArray object ect</span>
</span><span class='line'><span class="c1">// ... Your code here!</span>
</span><span class='line'><span class="c1">// ... Hack n the raw bits in `pixels`</span>
</span><span class='line'><span class="c1">// ... and then write them back to th canvas;</span>
</span><span class='line'><span class="nx">context</span><span class="p">.</span><span class="nx">putImageData</span><span class="p">(</span><span class="nx">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在标准化过程中，类型数组(Typed arrays)包括有常见了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">方法</a>，如<code>.slice()</code>，<code>.map()</code>，<code>.filter()</code>。</p>

<ul>
<li><p><strong>Promises</strong>  仅用一个自然段来描写promise，就像是吃饭只能吃一个薯片。不用管它有多难，这甚至是什么任何意义的事情。说什么？Promise可以用来对JS进行异步编程来构建代码块。它的作用会在后面提到。比如，当你调用<code>fetch()</code>时，不像普通代码块，它会立即返回一个promise对象，其数据获取会在后台进行。当有返回值时，它会调用你的相应代码。promise优于普通的callback函数，因为它的操作链真心很好。promise有很多有趣的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">操作</a>，通常会是第一选择，你可以简单进行错误处理而不需要做过多的学习。它们已经在浏览器支持了。如果你还不一点都不知道promise，可以查看 <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">Jake Archibald 的文章</a>。</p></li>
<li><p><strong>函数在代码块的作用域中</strong> 你不应该让这情况出现，但是，你可能已经无意地存在相关代码了。</p></li>
</ul>


<p>在ES1-5中，下面的代码在技术上说是有问题的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">temperature</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">function</span> <span class="nx">chill</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">fan</span><span class="p">.</span><span class="nx">switchOn</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">obtainLemonade</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">chill</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数声明是在<code>if</code>代码块中的，这理念上是不允许的。函数声明只能在顶级中，或者在函数体内的最外层。</p>

<p>但是，上面代码几乎能在所有主流的浏览器中运行，从某种程度上是这样子的。</p>

<p>但又不完全一样，在每个浏览器中其处理细节有些不一样。但是，某种程度上都是可以工作的，并且很多网页还在使用它。</p>

<p>不幸的是，Firefox和Safari还没有实现新的标准。对现在来说，可以使用一个函数的表达式来替代：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">temperature</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">chill</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">fan</span><span class="p">.</span><span class="nx">switchOn</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">obtainLemonade</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="nx">chill</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>多年来，代码块作用域函数(block-scoped function)没有标准化是因为向后兼容的限制并非常复杂。没有人认为他们可以解决这一问题。ES6处理这种<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics">奇怪规则</a>的线程只能在非严格模式中使用。我不能在这里解释，但请相信我，使用严格模式。</p>

<ul>
<li><strong>函数名称</strong> 所有的主流JS引擎都会在函数中有个非标准的<code>.name</code>属性来表示其名称。ES6对此进行了标准化，它会明智地对某些没有名称的函数推测出<code>.name</code>的属性：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">lessThan</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="o">&lt;</span><span class="nx">b</span><span class="p">;}</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">lessThan</span><span class="p">.</span><span class="nx">name</span>
</span><span class='line'>    <span class="s2">&quot;lessThan&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>好事</h4>

<ul>
<li><strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign(target, &#8230;sources)</a></strong> 标准库中的新函数，类似于Underscore中的<code>.extend()</code></li>
<li><strong>函数调用中的展开操作符(spread operator，实际是省略号，翻译为展开操作符因为作用就是将数据展开为多个值)</strong>  在这里Nutella并没有做什么，尽管Nutella尝着美味。但是，它依然是个美味的特性，我认为你们会喜欢的。</li>
</ul>


<p>在之前的五月中，我们介绍了<a href="http://shatle.github.io/blog/2015/10/25/es6-in-depth-rest-parameters-and-defaults/">rest parameters</a>，这为函数提供了一个可能接收任意数量的参数方式，它比那随意、笨拙的<code>arguments</code>对象更为友好。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">log</span><span class="p">(...</span><span class="nx">stuff</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// stuff is the rest parameter.</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">rendered</span> <span class="o">=</span> <span class="nx">stuff</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">renderStuff</span><span class="p">);</span> <span class="c1">// It&#39;s a real array.</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="s2">&quot;#log&quot;</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="nx">rendered</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那时我们并没有对函数中传递任意数量的参数的匹配语法进行说明，它相比<code>fn.apply()</code>更为友好。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// log all the vlaues from an array</span>
</span><span class='line'><span class="nx">log</span><span class="p">(...</span><span class="nx">myArray</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>好的，它可以作用于任意的<a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">迭代对象</a>，所以你可以通过<code>log(...mySet)</code>来记录所有的事情。</p>

<p>并不像剩余参数，它可以在一个参数列表中使用多个展开操作符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// kicks are before trids</span>
</span><span class='line'><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Kicks:&quot;</span><span class="p">,</span> <span class="p">...</span><span class="nx">kicks</span><span class="p">,</span> <span class="s2">&quot;Trids:&quot;</span><span class="p">,</span> <span class="p">...</span><span class="nx">trids</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>展开操作符可以二维数组压平为一维数组：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">smallArrays</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[],</span> <span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;twos&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">onBigArray</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(...</span><span class="nx">smallArrays</span><span class="p">);</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">oneBigArray</span>
</span><span class='line'>    <span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;twos&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>但也许只有我有这一个迫切的需求，如果是这样，我真要责骂Haskell了。</p>

<ul>
<li><strong>构建数组时的展开操作符</strong> 同样回到五月，我们谈到解构中的&#8221;rest“剩余模式。这是一个可以将一数组中的任意数量值取出来的方式。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="o">&gt;</span> <span class="kd">var</span> <span class="p">[</span><span class="nx">head</span><span class="p">,</span> <span class="p">...</span><span class="nx">tail</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">head</span>
</span><span class='line'>    <span class="mi">1</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">tail</span>
</span><span class='line'>    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>猜测一下下面代码。这匹配的语法会将任意数量的元素整合为一个数组：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">reunited</span> <span class="o">=</span> <span class="p">[</span><span class="nx">head</span><span class="p">,</span> <span class="p">...</span><span class="nx">tail</span><span class="p">];</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">reunited</span>
</span><span class='line'>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样的，你可以在函数调用中拥有相同的规则：你可以在同一数组中使用多次展开操作符，等等。</p>

<ul>
<li><strong>适时的尾部调用</strong>  如果让我在这里解释这个，对我来说还是难的。</li>
</ul>


<p>为了更好地理解这一特性，没有比这<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-9.html#%_chap_1">计算机编程的结构和解析</a>更合适开始学习的了。如果你感兴趣，你可以坚持读它。尾部调用会在 <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.1">1.2.1部分 线性递归与迭代</a>中有解释。ES6标准化中要求的实现是线性递归的方式，也就是那文章提到的。</p>

<p>没有任一主流的浏览器实现这一特性，这很难实现，但是所有的事情都在往好的方向发展。</p>

<h4>文本(Text)</h4>

<ul>
<li><strong>Unicode 版本升级</strong> ES5要求实现至少支持Unicode的3.0版本字符。ES6则要求至少是Unicode 5.1.0。你可以在函数名称上使用<a href="https://en.wikipedia.org/wiki/Linear_B">Linear B</a>。</li>
</ul>


<p>[Linear A]使用上还有点问题，因为它在Unicode7.0版本之前没有支持，也因为很难管理没有破译的语言进而的代码编写。</p>

<p>(尽管JS引擎支持在Unicode6.1版本中的emoji，但你还是不能使用这些表情作为变量的名称。出于某种原因，Unicode联盟不支持使用它们作为身份标识字符。)</p>

<ul>
<li><strong>长的Unicode转义序列</strong> 如早期版本一样，ES6支持4个数值的Unicode转义序列。它们看着如<code>\u212A</code>。它们很好用，你可以在字符串中使用它们。或者，如果你想耍幽默同时你无论什么时候也不同进行代码检查，你可以使用它们作为变量的名称。但是，对于一个字符如<code>U+1a3021</code>，一个用头倒立的人的埃及象形文字，明显是有问题的。<code>13021</code>有五个数值，已经超过了四个。</li>
</ul>


<p>在ES5中，你不得不编写两个转义符号，因为UTF-16的代理对(surrogate pair)。这实际上就感觉生活在暗黑时代：寒冷、悲惨、野蛮的。ES6就像是意大利的文化复兴，带来了巨大的变化：你现在可以编写<code>\u{13021}</code>。</p>

<ul>
<li><strong>对BMP字符有更好支持</strong> <code>.toUpperCase()</code>和<code>.toLowerCase()</code>方法现在可以用于犹太字符中了。</li>
</ul>


<p>同样的，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint"><code>String.fromCodePoint(...codePoints)</code></a>函数与老式的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode"><code>String.fromCharCode(...codeUnits)</code></a>差不多，只是前者会支持BMP的点编码。</p>

<ul>
<li><strong>Unicode 正则</strong> ES6的正则表达式支持新的标签，<code>u</code>标签，因为除在BMP中正则表达式认为会将其认为是个单独的字符，而不是两个分离的编码单元。例如，没有<code>u</code>时，<code>/./</code>只会匹配半个字符“ ”，但<code>/./u</code>会匹配整个。</li>
</ul>


<p>在正则在增加<code>u</code>的标签，还可以处理unicode的非大小写和长类型的unicode转义序列。至于完整的说明，可参考<a href="https://mathiasbynens.be/notes/es6-unicode-regex">Mathias Bynens 非常详尽的文章</a></p>

<ul>
<li><p><strong>Sticky正则</strong> 对于非unicode的可以使用<code>y</code>标签，详情在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky">此可查看</a>。sticky正则表达式只会从由<code>.lastIndex</code>指定的偏移位开始查找，如果不要指定的位置找到，不会一直向下找，而是直接返回<code>null</code>。</p></li>
<li><p><strong>官方的国际化指引</strong> ES6实现了对国际化的支持，<a href="http://www.ecma-international.org/publications/standards/Ecma-402.htm">ECMA-402 the ECMAScript 2015 国际化说明</a>，这额外的标准中指定了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl"><code>Intl</code>对象</a>。Firefox，chorme 和 IE 11+ 已经支持它了，Node 0.12 也支持。</p></li>
</ul>


<h4>数值(Numbers)</h4>

<ul>
<li><strong>二进制和八进制</strong> 如果你觉得数字 8,675,309 和 <code>0x845fed</code>并不适合你，而想要一种更为特殊的方式表达，你现在可以编写<code>0o41057755</code>（八进制）或者 <code>0b100001000101111111101101</code>（二进制）。</li>
</ul>


<p><code>Number(str)</code>现在也可以识别这格式<code>Number("0b101010")</code>字符串，会返回42。</p>

<p>（快速提醒：<code>number.toString(base)</code>和<code>parseInt(stsring, base)</code>还是可以如原来一样转化数字，无论是转出还是转入，转换的过程中会根据base。）</p>

<ul>
<li><strong>新<code>Number</code>函数和常量</strong> 这是非常好的地方。如果你对此感兴趣，你可以自己查看标准文档，可以从<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-number.epsilon"><code>Number.EPSILON</code></a>开始。</li>
</ul>


<p>也许，这最有意思的新想法是“安全的整型”，它可以从<code>-(2**25-1)</code>到<code>+(2**53-1)</code>，包含边界值 。JS中的数值存在着范围。这一个在此范围中的整型都可以用JS数字表示，进而可以查看其临近的数字。简单来说，在这范围中操作<code>++</code>和<code>--</code>得到的效果是期望所得的。超出这范围时，奇数是不能表示的，就如64位浮点的数字，同样这些数字的增加和减少也不能得到正确的结果（偶数也一样）。为了解决你代码中的这些问题，标准委员会提供了常量<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER"><code>Number.MIN_SAFE_INTEGER</code></a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER"><code>Number.MAX_SAFE_INTEGER</code></a>，和一个判断方法<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger"><code>Number.isSafeInteger(n)</code></a>。</p>

<ul>
<li><strong>新的<code>Math</code>函数</strong>  ES6增加了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh">曲线三角函数</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh">它们的相反值</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt"><code>Math.cbrt(x)</code></a> 会计算立方，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot"><code>Math.hypot(x,y)</code></a> 会计算直角三角形的斜边长，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log2"><code>Math.log2(x)</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10"><code>Math.log10(x)</code></a> 会计算常见的对数值，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32"><code>Math.clz32(x)</code></a>可帮忙求对数（其基本等于<code>32-log2(x)</code>，还有些其它的。</li>
</ul>


<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign"><code>Math.sign(x)</code></a> 可获取数字的符号（1,0,-1对应于正零负）。</p>

<p>ES6还添加了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul"><code>Math.imul(x, y)</code></a>，它就是32位的带符号乘法。这是十分奇怪的需求，除非你实际工作中没有64位的整型或者大数值的整型。如果是这样，这还是挺方便的， 这有助于编译器，Emscripten 可以利用此函数在JS中计算64位的乘法。</p>

<p>类似的，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround"><code>Math.fround(x)</code></a>可助于编译器对32位浮点数值的支持。</p>

<h4>结束语</h4>

<p>这就是所有特性了？</p>

<p>不。我还没有提到在所有内置迭代器中的对象通用原型，还有生成器函数的构造函数，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is(v1, v2)</code></a>。<code>Symbol.species</code>可以帮助进行子类内置操作，如数组和Promise。ES6 还有许多没有标准化的目标正在进行中。</p>

<p>我可以确认的是我肯定遗失些事情没有提到。</p>

<p>但是，如果你一直都跟着下来，你会对整体有个很好的印象。你可以知道今天你可以能用上的特性，如果你还这么做了，那么你正迈向更好的语言。</p>

<p>几天前，Josh Mock 提醒我说，他只只用的50行代码就说完了八个不同的ES6特性，但没有深入的想法。<a href="https://gist.github.com/JoshMock/98f187c7a8bf745e4cf6">文章</a>包含有模块、类、默认参数、Set、Map、模板字符串、前头函数、和let。（他忘记了for-of循环）</p>

<p>这也就是我的经验所得到的。文章对于新的特性在一块处理得很好，它们会真正影响到你日常编写的每一行代码。</p>

<p>同时，每个JS引擎都在积极跟进和优化这些我们之前几个月一直在讨论的特性。</p>

<p>只要我们的工作完成了，这语言也就完善好了。我们将不会不得不再次调整代码了，而我将不得不找其它工作了。</p>

<p>只是开个玩笑。ES7的提案已经提交了。这里可以暴露一点：</p>

<ul>
<li><p><strong>幂操作符</strong> <code>2**8</code>将会返回 256，这会是Firefox中的日版本中更新。</p></li>
<li><p><strong>Array.prototype.includes(value)</strong> 如果这数组包含有指定的值时，会返回true。此会通过polyfill的方式在Firefox的日版本中。</p></li>
<li><p><strong>SIMD</strong>  将128位的SIMD指令集提供给先进的CPU。这些指令集会对相邻的数组元素进行算术计算，可以动态地提升大范围的各种算术，对于流媒体音频、视频、密码、游戏、图片处理等都是相当有用的。更加底层的操作，更为强大。此会通过polyfill的方式在Firefox的日版本中。</p></li>
<li><p><strong>异步函数</strong> 我们在之前的生成器的文章中隐藏这一特性。异步函数类似于生成器，但区别时同步编程。当你调用一个生成器时，它会返回一个迭代器。当你调用一个异步函数时，它会返回一个promise。生成器可以使用yield的关键字来暂停和产出一个值；同步函数则会使用<code>await</code>关键字来暂停和等待一个promise。</p></li>
</ul>


<p>这是很难用几句话来说完的。但异步函数会在ES7中有重大的调整和意义。</p>

<ul>
<li><strong>类型化对象</strong>  这就是之前的类型数组。类型数组的元素拥有其类型，一个类型的对象是一个其属性被类型化后的对象。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Create a new struct type. Every Point has two fields</span>
</span><span class='line'><span class="c1">// named x and y.</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">Point</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TypedObject</span><span class="p">.</span><span class="nx">StructType</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">x</span><span class="o">:</span> <span class="nx">TypedObject</span><span class="p">.</span><span class="nx">int32</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">y</span><span class="o">:</span> <span class="nx">TypedObject</span><span class="p">.</span><span class="nx">int32</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Now create an instance of that type.</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">800</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">600</span><span class="p">});</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 800</span>
</span></code></pre></td></tr></table></div></figure>


<p>你为了性能的原因会编写此代码。类似类型数组，类型对象会增加些编程的优势（减少内存的使用和提升速度），但是其每个对象、每个输入选项，相对于之前语言所有事情都会被静态地类型化，也就是被类型会之后，其值必须是那个类型。</p>

<p>这是作为JS的综合目标，并会在Firefox的日版本中实现。</p>

<ul>
<li><strong>类和原型装饰器</strong>  装饰器就是一个属性、类、方法中的标签。通过一个例子来说明其是什么样子的：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">import</span> <span class="nx">debug</span> <span class="nx">from</span> <span class="s2">&quot;jsdebug&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">@</span><span class="nx">debug</span><span class="p">.</span><span class="nx">logWhenCalled</span>
</span><span class='line'>  <span class="nx">hasRoundHead</span><span class="p">(</span><span class="nx">assert</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="k">instanceof</span> <span class="nx">Spheroid</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>@debug.logWhenCalled</code>就是所谓的装饰器，你可以想象这方法是做什么的。</p>

<p><a href="https://github.com/wycats/javascript-decorators/blob/master/README.md">这里的提案</a>有解释其详细工作的过程，同时还包含许多的例子。</p>

<p>还有一个令人兴奋的特性我不得不提到，但它还在开发阶段并且不是语言的特性。</p>

<p>TC39, 这个ECMAScript的标准委员会，将会更为频繁地发布版本和有更多的公开进度。在ES5和ES6之间已经有六年。委员会对ES7的目标是在ES6的12个月之后，随后的标准版本会以12个月的节奏进行发布。上面提到的部分特性已经准时完成了，它们会跟上这火车并成为ES7的一部分的。那些还没有完成的，会在下列火车的时间表中。</p>

<p>很高兴分享了很多的ES6的好的新特性，同时也很高兴能够花时间来讨论这些特性，可能以后再也没有这时间了。</p>

<p>很高兴参与深入ES6的文章，我希望你们能喜欢它。保持联系。; )</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: Modules]]></title>
    <link href="http://shatle.github.io/blog/2016/03/20/es6-in-depth-modules/"/>
    <updated>2016-03-20T17:01:19+08:00</updated>
    <id>http://shatle.github.io/blog/2016/03/20/es6-in-depth-modules</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/">ES6 In Depth: Modules</a></p></blockquote>

<p>当我在2007年加入到Mozilla的JS团队时，有一笑话是经典的JS程序只有一行代码。</p>

<p>那时已经是Google Map开始的两年之后了。在此之前，最为卓越的JS代码就是表单的验证，那么你在<code>&lt;input onchange=&gt;</code>上的平均处理代码也就是一行，对的，已经足够了。</p>

<p>事情已经发生了变化。JS项目已经成长为令人惊奇的量级，同时社区中也开发了一些工具来适应规模的变化。其中一个最为基本的事情是你需要模块系统，它可以将你的工作分离到多个文件和目录中，但是它依然保证在必要时能访问其他部分，同时使得加载所有代码更为有效。所以实际上，JS已经有了模块系统，并且有几种。同时，还有些包管理工具来安装软件和复制其高层的依赖。你可能会想到ES6，它为JS带来了新的模块系统，确实有点晚了些。</p>

<p>好的，今天我们就开始来看ES6为这已经存在的系统增加了些什么功能，同时看一下可以使用它来做些什么标准和工具吧。但是首先，让我们开始查看ES6模块长什么样子吧。</p>

<h4>模块基础</h4>

<p>ES6的模块是一个包含有JS代码的模块。它没有<code>module</code>的关键字，一个模块几乎可以看成为一个脚本。这里有两个区别：</p>

<ul>
<li>ES6模块会自动启用 严格模式，即使你没有在代码中使用&#8221;use strict&#8221;</li>
<li>你可以在模块中使用<code>import</code>和<code>export</code></li>
</ul>


<p>让我们先来说一下<code>export</code>。在模块中的任何声明，默认都只会作用于此模块。如果你想在模块中的声明公开出去，也就是其它模块能使用它，你必须<em>暴露</em>这个特性(变量、函数等）。有些方式可以做到这点，最为简单的方式就是添加一个<code>export</code>的关键字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// kittydar.js - Find the locations of all the cats in an image.</span>
</span><span class='line'><span class="c1">//(Heather Arthur wrote this library for real)</span>
</span><span class='line'><span class="c1">// (but she didn&#39;t use modules, because it was 2013)</span>
</span><span class='line'>
</span><span class='line'><span class="kr">export</span> <span class="kd">function</span> <span class="nx">delectCats</span><span class="p">(</span><span class="nx">cavas</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">kittydar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Kittydar</span><span class="p">(</span><span class="nx">options</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">kittydar</span><span class="p">.</span><span class="nx">detectCats</span><span class="p">(</span><span class="nx">canvas</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">export</span> <span class="nx">clas</span> <span class="nx">Kittydar</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span> <span class="nx">several</span> <span class="nx">methods</span> <span class="nx">doing</span> <span class="nx">image</span> <span class="nx">processing</span> <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// This helper function isn&#39;t exported.</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">resizeCanvas</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以<code>export</code>任何顶级的<code>function</code>、<code>class</code>、<code>var</code>、<code>let</code>、<code>const</code>。</p>

<p>这也就是你需要知道有关模块的所有信息。你并不需要使用IIFE或者一个回调函数。你只要正常地声明你所需要的任何事情。因此，这代码就是模块，不是脚本，所有的声明的作用域都会在此模块中，并不会在全局所有的脚本和模块是可见的。将这些声明暴露出去，会使这成为此模块对外的公开API，这就是你想要的。</p>

<p>与暴露代码不同，在模块中的代码仅仅只是普通的代码。你可以使用全局字面量，如<code>Object</code>和<code>Array</code>。如果你模块运行于浏览器中，你可以使用<code>document</code>和<code>XMLHttpRequest</code>。</p>

<p>在一个分离的文件中，我们可能导入并使用<code>detectCats()</code>函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// domo.js - Kittydar demo program</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="p">{</span><span class="nx">detectCats</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;kittydar.js&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">go</span><span class="p">(){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;catpix&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">cats</span> <span class="o">=</span> <span class="nx">detectCats</span><span class="p">(</span><span class="nx">canvas</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">drawRectangles</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span> <span class="nx">cats</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了从一个模块中导入多个名称，你可以编写:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">import</span> <span class="p">{</span><span class="nx">detectCats</span><span class="p">,</span> <span class="nx">Kittydar</span><span class="p">)</span> <span class="nx">from</span> <span class="s2">&quot;kittydar.js&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你运行一个含有<code>import</code>声明的模块时，需要导入的模块会先被加载，每个模块的代码体会根据整个依赖图进行深度遍历执行，并跳过已经执行的模块来避免循环加载。</p>

<p>这就是模块的基础内容了，这确实是十分简单的，;-)</p>

<h4>导出列表</h4>

<p>相比于在每个特性中进行导出的标记，你可以编写一个简单的列表来指出你想导出的所有名称，并放到大括号中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">export</span> <span class="p">{</span><span class="nx">detectCats</span><span class="p">,</span> <span class="nx">Kittydar</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// no export keyword required here</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">detectCats</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">Kittydar</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>export</code>的列表并不一定需要在文件的第一行，它可以出现在模块的顶级的任意地方。你可以拥有多个<code>export</code>列表，或者与其它的<code>export</code>混合起来用，只要保证导出的名称不超过一次就好。</p>

<h4>对导入导出重命名</h4>

<p>有时，一个导入的名称可能会与其它你同样需要使用的名称是一样的，所以ES6允许你对导入的名称进行重命名：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// suburbia.js</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Both these modules export something named `flip`.</span>
</span><span class='line'><span class="c1">// To import them both, we must rename at least one.</span>
</span><span class='line'><span class="kr">import</span> <span class="p">{</span><span class="nx">flip</span> <span class="nx">as</span> <span class="nx">flipOmelet</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;eggs.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kr">import</span> <span class="p">{</span><span class="nx">flip</span> <span class="nx">as</span> <span class="nx">flipHouse</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;real-estate.js&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>类似的，你可以对导出的名称进行重命名。有时可能会出现，你希望以不同的名称导出相同的值，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// unlicensed_nuclear_accelerator.js - media streaming without drm</span>
</span><span class='line'><span class="c1">// (not a real library, but maybe it should be)</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">v1</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">v2</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">export</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">v1</span> <span class="nx">as</span> <span class="nx">streamV1</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">v2</span> <span class="nx">as</span> <span class="nx">streamV2</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">v2</span> <span class="nx">as</span> <span class="nx">streamLatestVersion</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h4>默认导出</h4>

<p>设计的新标准是能与已经存在的CommonJS和AMD模块能正常溶合，所以当你一个Node项目，并且完成命令<code>npm install lodash</code>。你的ES6代码可以从<code>lodash</code>导入单独的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">import</span> <span class="p">{</span><span class="nx">each</span><span class="p">,</span> <span class="nx">map</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;lodash&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nx">each</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="nx">x</span><span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，你可能已经习惯看到<code>_.each</code>而不是<code>each</code>，并且你希望编写代码依然保持这方式。或者自从有 <a href="https://lodash.com/docs#_">这个</a>，你还想使用<code>_</code>作为一个函数。</p>

<p>为了做到这点，你可以稍微地调整为不同的语法：导入模块时不使用大括号：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">import</span> <span class="nx">_</span> <span class="nx">from</span> <span class="s2">&quot;lodash&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这其实就是等价于<code>import {default as _} from "lodash"</code>。所有的CommonJS和AMD模块都会为ES6提供一个<code>default</code>的导出名称，这其实就类似于你<code>require()</code>这模块，也就是<code>exports</code>对象。</p>

<p>ES6模块被设计为可以让你导出多个事物，但在已经存在的CommonJS模块中，默认的导出是包含所有事物。例如，有名的<a href="https://github.com/Marak/colors.js">colors</a>包在我说之前并没有任何对ES6的支持。它就是一个CommonJS的集合，就像很多在npm的包一样。但是，你可以明确地告诉ES6代码需要导入的内容。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// ES6 equivalent of `var colors = require(&quot;colors/safte&quot;);`</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">colors</span> <span class="nx">from</span> <span class="s2">&quot;colors/safe&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你希望你的ES6模块有个默认的导出，那很容易。这并没有什么魔法性的操作，它就像其它的导出操作，只是将其命名为<code>"default"</code>。你可以使用我们之前提到的重命名的语法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">field1</span><span class="o">:</span> <span class="nx">value1</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">field2</span><span class="o">:</span> <span class="nx">value2</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kr">export</span> <span class="p">{</span><span class="nx">myObject</span> <span class="nx">as</span> <span class="k">default</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者使用缩写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">field1</span><span class="o">:</span> <span class="nx">value1</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">field2</span><span class="o">:</span> <span class="nx">value2</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关键字<code>export default</code>后面可以接任意的值：一个函数，一个类，一个你命名的对象字面量。</p>

<h4>模块对象</h4>

<p>十分抱歉，这部分内容有些长。但是，这并不仅仅是JS特有的。因为某些原因，所有语言中的模块系统都试图做到足够的小、方便。幸运，还剩一个特性。好吧，是两个。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">cows</span> <span class="nx">from</span> <span class="s2">&quot;cows&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你使用<code>import *</code>时，它导入的是一个模块命名对象。它的属性是这一模块的所有导出。所以，如果&#8221;cow&#8221;模块导出有一个名为<code>moo()</code>的函数，那么在此行代码导入&#8221;cows&#8221;之后，你可以使用<code>cows.moo()</code>。</p>

<h4>聚合模块</h4>

<p>有时，主模块可能会将其它模块的包导入进来，同时会将它们又以非统一的方式导出。为了简化这一类的代码，下面有个聚合的从导入到导出的缩写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// world-foods.js - good stuff from all over</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// import &quot;sri-lanka&quot; and re-export some of its exports</span>
</span><span class='line'><span class="kr">export</span> <span class="p">{</span><span class="nx">Tea</span><span class="p">,</span> <span class="nx">Cinnamon</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;sri-lanka&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// import &quot;equatorial-guinea&quot; and re-export some of its exports</span>
</span><span class='line'><span class="kr">export</span> <span class="p">{</span><span class="nx">Coffee</span><span class="p">,</span> <span class="nx">Cocoa</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;equatorial-guinea&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// import &quot;singapore&quot; and export ALL of its exports</span>
</span><span class='line'><span class="kr">export</span> <span class="o">*</span> <span class="nx">from</span> <span class="s2">&quot;singapore&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>每个这些<code>export-from</code>的表达式都类似于<code>import-from</code>，只是调整为<code>export</code>。并不像导入一样，这并不会重新添加导出的绑定到主模块的作用域中。所以，如果你想在<code>world-foods.js</code>中编写代码使用<code>Tea</code>，就不要使用这一缩写。你会发现找不到这字面量。</p>

<p>如果在导出&#8221;singapore&#8221;时会与其它的导出有冲突，会产生一个错误，所以请小心使用<code>export *</code>。</p>

<p>好了，我们介绍完语法了。让我们开始些有趣的事情。</p>

<h4><code>import</code>实际上做了什么</h4>

<p>你会相信 它没什么吗？</p>

<p>好吧，你不是那么好欺骗的。好的，你会相信标准委员会几乎没有对<code>import</code>进行说明？这是好事吗？</p>

<p>ES6的模块加载的整个详情可以移步到 <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hostresolveimportedmodule">其实现</a>，它的实现详情可移步于 <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toplevelmoduleevaluationjob">详细说明</a>。</p>

<p>粗略来讲，当你告诉JS引擎在运行一个模块时，它不得不进行如下四个步骤：</p>

<ul>
<li>1、解析：读取模块资源的实现代码并检查语法错误</li>
<li>2、加载：递归地加载所有需要导入的模块，这一部分还没有标准化。</li>
<li>3、链接：对于每个加载完成的模块，会为其创建一个作用域，并将此模块声明绑定到此作用域中，包括从其它模块导入过来的事物。</li>
</ul>


<p>这就是<code>import {cake} from "paleo"</code>的部分。但是，如果&#8221;paleo&#8221;模块并没有导出任何名为&#8221;cake&#8221;的字面量，你将会得到一个错误。这是很坏的体验，因为你已经实际上运行了一些JS代码了。</p>

<ul>
<li>4、运行：最后，开始运行每个新加载的模块体。这时候，<code>import</code>的处理进程已经完成了，所以当代码执行到含有<code>import</code>声明的代码行时，没有什么会发生。</li>
</ul>


<p>看？我之前就告诉你答案是“没什么”。我对编程语言并不会撒谎。</p>

<p>但是，现在我们开始接触这模块系统的有趣部分了，这是个感觉好玩的点。因为模块系统并没有指定怎么加载模块，你可以在开始时候，找出在资源代码中所有的<code>import</code>声明。ES6的其中一个实现方式，是将所有的工作都放到编译阶段，并将所有的模块捆绑放入一个文件中，才发送给网络上。webpack这工具实际上就是这么做的。</p>

<p>这是个大的话题，因为加载脚本会花费网络的时间。当你每次获取时，你会查找其<code>import</code>的声明，时间就会成倍增长了。比较天真的加载方式是会发送多个网络请求，但通过webpack，这不仅仅是今天使用ES6模块，你会自动得到所有软件工程所要到达的运行时优点。</p>

<p>ES6模块加载的详情还是与原始计划的一样，并构建起来的。其中一个原因就是因为没有统一怎么实现此特性，所以它并不是最后的标准。我希望某人能够指出来，因为就如我们看到的，模块的加载确实需要标准化，而且打包非常有用，是不能放弃的。</p>

<h4>静态 vs 动态，或者：规则或打破规则</h4>

<p>作为动态语言，JS已经拥有其令人惊奇的静态模块系统。</p>

<ul>
<li><p>所有的<code>import</code>和<code>export</code>都只允许在模块的顶级声明，导入导出没有额外的限制条件，但你不能在函数作用域中使用。</p></li>
<li><p>所有的导出定义必须是在资源代码中存在有明确的名称。你不能通过编程来循环一个数组并导出一堆的名称。</p></li>
<li><p>模块对象是冻结的。不能通过hack的方式来操作模块对象，polyfill方式的也不行。</p></li>
<li><p>在任一模块代码运行之前，所有模块依赖必须加载完成、解析和关联上。按照要求，不允许<code>import</code>导入模块懒加载的。</p></li>
<li><p>对于<code>import</code>的错误没有任何的恢复机制。一个App可能会有上百的模块，如果有任何的加载或者关联失败，所有代码将不会运行。你不能在<code>try/catch</code>中使用<code>import</code>。（这里有个优点，因为这模块系统是静态的，所以webpack可以在编译阶段检查出可能存在的错误。）</p></li>
<li><p>在没有加载完依赖之前，不允许运行模块中的任何代码。这意味着如果依赖没有加载完成时，模块本身不知道怎么控制代码的运行。</p></li>
</ul>


<p>如果你需求是静态的话，这模块系统是十分好的。但是，有时你可能需要些hack，是不是？</p>

<p>这就是为什么你需要编程API来处理与ES6的<code>import/export</code>语法相违背的模块系统加载机制。例如，<a href="http://webpack.github.io/docs/code-splitting.html">webpack includes an API</a> 你可以使用“code splitting&#8221;，按需求对某些模块进行懒加载。这个API可以让你打破上面所提到的多数规则。</p>

<p>ES6的模块语法是十分静态的(晕，什么叫十分静态），同时它也是好的，因为这样可以缩短其编译工具的时间。但是，通过编程后的加载API，这静态的语法已经可以动态操作了。</p>

<h4>什么时候可以使用这ES6的模块？</h4>

<p>现在为了使用模块，你需要一个编译器，如 Traceur 或者 Babel。早些时候，Gaston I. Silva 有一<a href="http://shatle.github.io/blog/2015/12/16/es6-in-depth-using-es6-today-with-babel-and-broccoli/">文章</a> 来说明怎么为Web编译ES6代码。在这一文章中，Gaston 已经有一个例子是有关ES6模块的。这有个Axel Rauschmayer 编写的<a href="http://www.2ality.com/2015/04/webpack-es6.html">例子</a>，它使用Bable和webpack。</p>

<p>模块系统主要由 Dave Herman 和 Sam Tobin-Hochstadt 设计，他们为此模块系统的静态化辩护，同时为此长年与包括我在内的很多人抗争着。Jon Coppeard 实现了 Firefox 中的模块。另外的<a href="https://github.com/whatwg/loader">JS 加载器标准化</a>也正在进行中，人们所希望的在HTML中添加<code>&lt;script type=module&gt;</code>的特性也会随之而来。</p>

<p>这就是ES6。</p>

<p>这些实在是太有意思了，以致我并不想结束。也许，我们只是完成了部分的故事情节。我们可以讨论些ES6说明中零碎的特性，但它们又不能足够单独写成文章。也许，将来会对这些进行讨论。请在下周加入我们，一起对深入ES6进行个完美的总结吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: Subclassing]]></title>
    <link href="http://shatle.github.io/blog/2016/03/20/es6-in-depth-subclassing/"/>
    <updated>2016-03-20T17:00:04+08:00</updated>
    <id>http://shatle.github.io/blog/2016/03/20/es6-in-depth-subclassing</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/">ES6 In Depth: Subclassing</a></p></blockquote>

<p>两周之前，我们介绍了ES6中新增加的一个类的系统，它可以用来做面向对象式的创建对象。我们可以展示一下，你可以怎么使用它来编写代码，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Circle</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">Circle</span><span class="p">.</span><span class="nx">circlesMade</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kr">static</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">circle</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// Canvas drawing code</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kr">static</span> <span class="nx">get</span> <span class="nx">chiclesMade</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">_count</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">_count</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="kr">static</span> <span class="nx">set</span> <span class="nx">circlesMade</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">_count</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">radius</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">get</span> <span class="nx">radius</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_radius</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="nx">set</span> <span class="nx">radius</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="nx">radius</span><span class="p">))</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Circle radius must be an integer.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">_radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>很不幸的是，就如一些人指出的，这并没有体现ES6中类的其它作用。就像传统的类系统(如，C++ 或者 Java)，ES6允许继承，也就是一个类可以将另外一个作为基类，然后为自己增加更多的特性进而实现扩展。让我们更为接近这一新特性，查看其操作的可能性。</p>

<p>在我们开始讨论子类化之前，还需要花些时间来复习一下属性的继承和动态的原型链。</p>

<h4>JS的继承</h4>

<p>当我们创建一个对换昌，我们可以为其增加属性，同时它继承于其本身原型对象的属性。JS程序大大应该会很熟悉存在的<code>Object.create</code>这个API，它让我们可以简单地做到这点：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">value</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">method</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">14</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">proto</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span> <span class="c1">//4</span>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">method</span><span class="p">();</span> <span class="c1">//14</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着，当我们为<code>obj</code>添加在<code>proto</code>拥有相同名称的属性时，这些<code>obj</code>属性就相当于<code>proto</code>的影子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span> <span class="c1">//5</span>
</span><span class='line'><span class="nx">proto</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span> <span class="c1">//4</span>
</span></code></pre></td></tr></table></div></figure>


<h4>子类化的基础</h4>

<p>这时，我们应该知道我们应该怎么通过类来处理对象创建时的原型链。再次重复一下，当我们创建一个类时，我们在类定义的内部为<code>constructor</code>方法创建一个新的函数，它可以处理所有的静态方法。我们也可以为创建好的函数增加一个包含原型属性的对象，它可以处理实例对象的方法。为了创建一个能继承所有静态属性的新类，我们不得不创建一个函数对象来继承基类的函数对象。类似的，对于实例方法，我们不得不为创建一个新的原型链上的函数，并继承于基类的原型类对象。</p>

<p>这描述有点让人迷惑，让我们来看一个例子，它会显示我们是怎么不用新语法来实现继承，接着进行些细小的扩展来让其更美观些。</p>

<p>继续我们之前例子，假设我们有一个类<code>Shape</code>，我们希望其可以子类化：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Shape</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">get</span> <span class="nx">color</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_color</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">set</span> <span class="nx">color</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">_color</span> <span class="o">=</span> <span class="nx">parseColorAsRGB</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">markChanged</span><span class="p">();</span>  <span class="c1">// repaint the canvas later</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们试图编写这样的代码时，对于<code>static</code>的属性我们依然会遇到之前文章同样的问题：没有语法来改变原型链的函数定义。当你可以有一方法类如<code>Object.setPrototypeOf</code>来解决这问题时，这方法比那些直接在原型链上创建函数要显得性能更为低劣。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Circle</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// As above</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Hook up the instance properties</span>
</span><span class='line'><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">Shape</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Hook up the static properties</span>
</span><span class='line'><span class="nx">Ojbect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">Circle</span><span class="p">,</span> <span class="nx">Shape</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这代码是十分丑陋的。我们增加了类的语法，可以让我们将对象的所有逻辑都封装在一个地方中，而不是像刚才的包括其它的&#8221;hooking things up(使用勾子方法提升功能)&#8221;的逻辑。Java、Ruby和其它的面向对象的语言中，都有一个方式来声明一个子类化的类，并指出来源于哪个类，所以我们也应该这样。我们使用关键字<code>extends</code>，所以我们可以编写成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Circle</span> <span class="kr">extends</span> <span class="nx">Shape</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// As above</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以在<code>extends</code>的后面添加任意的表达式，只要它是一个合法的<code>prototype</code>的原型构建器，如：</p>

<ul>
<li>其它类</li>
<li>由存在的继承框架产生的与类相似的函数</li>
<li>一个普通的函数</li>
<li>一个包含一个函数或者类的变量</li>
<li>一个对象的访问属性(obj[name])</li>
<li>一个函数调用</li>
</ul>


<p>如何你不想实例继承于<code>Object.prototype</code>，你甚至可以使用 <code>null</code>。</p>

<h4>Super 属性</h4>

<p>所以现在我们可以进行子类化，同时我们可以继承属性，可以通过我们的继承为方法创建影子方法。但是，如果你想避免这些影子方法呢？</p>

<p>想象一下我们希望为我们的<code>Circle</code>编写一个子类，它可以通过某些因素进行缩放。为了做到这点，我们可以编写下面显得不太自然的类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">ScalableCircle</span> <span class="kr">extends</span> <span class="nx">Circle</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">get</span> <span class="nx">radius</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">scalingFactor</span> <span class="o">*</span> <span class="kr">super</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">set</span> <span class="nx">raadius</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;ScalableCircle radius is constants.&quot;</span> <span class="o">+</span>
</span><span class='line'>                                   <span class="s2">&quot;Set scaling factor instead.&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Code to handle scalingFactor</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意在<code>radius</code>的getter方法中使用了<code>super.radius</code>。这个<code>super</code>的关键字可以让我们忽略自身的属性，而开始从我们的原型链中查找属性，因此也会过滤所有之前我们提到的影子方法。</p>

<p>我们可以在任意方法的函数定义中访问super属性(随便提醒，<code>super[expr]</code>也能工作)。当这些函数从原始对象中脱离出来后，super的方法访问实际上关联的是方法第一次定义的对象。这就意味着将一个方法脱离原有操作并定义到一个本地变量中，并不会改变<code>super</code>的方法访问产生的行为。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">&quot;MyObject: &quot;</span> <span class="o">+</span> <span class="kr">super</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">// MyObject: [object Object]</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">toString</span><span class="p">;</span>
</span><span class='line'><span class="nx">a</span><span class="p">();</span> <span class="c1">// MyObject: [object Object]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>子类化后的内置操作(基类方法的继承)</h4>

<p>另外，你们可能希望在JS语言内部编写些扩展功能。JS内部的数据结构赋予其巨大的能力，可以利用这些能力来创建新的数据类型，其也是子类化设计中的基础。JS支持你编写一个具有版本的数组。（我知道，相信我，我知道）。版本数组应该可以修改，可能提交修改，回退到之前的提交变化。有一种方式来快速的编写版本数组，就是创建<code>Array</code>的子类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">VersionedArray</span> <span class="kr">extends</span> <span class="nb">Array</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">();</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">history</span> <span class="o">=</span> <span class="p">[[]];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">commit</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Save changes to history</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">history</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">slice</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">revert</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">history</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">history</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>VersionedArray</code>的实例保持有数组中的一些重要属性，它们可以说是<code>Array</code>的实例，方法包括有<code>map</code>，<code>filter</code>和<code>sort</code>。<code>Array.isArray()</code>会将其实例认为是数组，它们还可以自动地更新数组的<code>length</code>属性。再者，返回数组的函数此时会返回一个<code>VersionedArray</code>（如<code>Array.prototype.slice()</code>）！</p>

<h4>类构建器的派生</h4>

<p>你可能已经注意到了上面的例子中的<code>constructor</code>方法有<code>super()</code>。</p>

<p>在传统的类模型中，构建器是用来初始化类实例的内部状态的。每个连续的子类负责初始化状态和相关的具体子类(什么叫连续的子类？晕)。我们希望这些能起作用，所以需要子类可以通过扩展来操作相同的初始化代码。</p>

<p>为了调用基类的构建器，我们可以再次使用<code>super</code>这关键字，它是操作就是个函数。这语法只有在使用<code>extends</code>的类的<code>constructor</code>的方法中是合法的，我们可能重新编写我们形状（Shape）类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Shape</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">_color</span> <span class="o">=</span> <span class="nx">color</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">class</span> <span class="nx">Circle</span> <span class="kr">extends</span> <span class="nx">Shape</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">color</span><span class="p">,</span> <span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">color</span><span class="p">);</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// As from above</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在JS中，我们通过编写构建器，来操作<code>this</code>对象、安装属性和初始化内部的状态。一般来说，当我们通过<code>new</code>调用构建器时<code>this</code>对象就创建成功了，就像是<code>Object.create()</code>会处理其构建器的<code>prototype</code>的属性。但是，有些内置操作会在不同的内部对象布局上。例如，数组在内存中的位置不同于常规的对象。因为，我们想看到子类的内置操作，我们需要让基类分配到<code>this</code>对象。如果它是内置操作，我们会得到我们想要的对象行为，如果它是普通的构建器，我们会得到期望中的默认的<code>this</code>对象。</p>

<p>可能会得到个奇怪的结论，认为<code>this</code>绑定的是子类的构建器。当我们运行到基类的构建器时，允许其指定<code>this</code>对象，但<strong>我们子类实际上并不会有<code>this</code>的值</strong>。因此，在没有调用基类构建器之前，所有访问子类构建器会导致一个<code>ReferenceError</code>错误。</p>

<p>就如之前的文章，你可以省略掉<code>contructor</code>方法，派生出来的构建器也是可能省略的，它就如你编写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">constructor</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kr">super</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有时，构建器并不能作用于<code>this</code>对象。相反，它们会通过其它的方式来创建对象，并初始化，接着直接返回此对象。如果是这一情况，那就不用使用<code>super</code>了。所有的构建器都会直接返回一个对象，不依赖于其基类构建器是否调用。</p>

<h4><code>new.target</code></h4>

<p>基类指定<code>this</code>对象时会有其它怪异的效果，那就是有时基类并不知道指定哪类的对象。假设，你正在编写一个对象框架的库，你希望有个基类<code>Collection</code>，某些子类会是数组，某些子类会是映射(Map)。然后，这时你运行<code>Collection</code>构建器，你并不会被告知是创建了哪类对象。</p>

<p>因此我们在进行内置操作时，当我们运行内置的构建器，我们需要知道其原始类的<code>prototype</code>。没有原型，我们是不能创建一个对象，使其有相应的实例方法的。为了解决这<code>Collection</code>的怪异情况，我们需要增加语法来暴露其信息给JS代码。我们已经增加了一个新的<em>元属性(Meta Property)</em> <code>new.target</code>，它关联构建器，可能直接调用<code>new</code>。通过<code>new</code>调用一个函数时，<code>new.target</code>会设置到其调用的函数中。调用<code>super</code>的函数中的<code>new.target</code>会作用<code>new.target</code>的值 。</p>

<p>这很难理解，所以让我用代码来解释我说的意思吧：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">class</span> <span class="nx">bar</span> <span class="kr">extends</span> <span class="nx">foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// This is included explicitly for clarity. It is not necessary</span>
</span><span class='line'>  <span class="c1">// to get these results.</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//foo directly invoked, so new.target is foo</span>
</span><span class='line'><span class="k">new</span> <span class="nx">foo</span><span class="p">();</span> <span class="c1">// foo</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 1) bar directly invoked, so new.target is bar</span>
</span><span class='line'><span class="c1">// 2) bar invokes foo via super(), so new.target is still bar</span>
</span><span class='line'><span class="k">new</span> <span class="nx">bar</span><span class="p">();</span> <span class="c1">// bar</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们已经解决了上面<code>Collection</code>所描述的问题，因为<code>Collection</code>构建器只检查<code>new.target</code>，就可以知道其类的家族，查看其是否是内置操作。</p>

<p><code>new.target</code>在任何的函数中都是合法的，如果一个方法没有由<code>new</code>调用时，它会被设置了<code>undefined</code>。</p>

<h4>最好的两个世界(多继承)</h4>

<p>希望你已经从这新特性的头脑风暴中生还出来，十分感谢能一直走到现在。现在，让我们花点时间来讨论，这些新特性怎么解决我们的问题。很多人很直率地质疑在JS加入继承这一特性是否好的。你可能会认为继承在创建对象上并不如<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">组合</a>一般好，或者认为相比于旧式的原型链模型，这精简的新语法会减少其设计上的灵活性。不容质疑的是，混入(mixin)通过扩展的方式来分享代码从而创建对象已经成为惯用手法。同时，它还有个好的原因：它提供了简单方式来将不相关的代码放置到同一个对象中，而不需要理解这两部分不相关代码是否适合在同一继承结构中。</p>

<p>在这主题上有很多不同的激烈信仰，但是我认为这并不值得讨论。首先，对一个语言增加类的特性，并不一定要求开发人员使用。第二，也同等的重要，语言中有类这一特性并不意味着它总是解决继承问题的最好方法！实际上，部分问题使用原型链继承的方式更为合适。到今天为此，类只是为你提供了额外的工具；它并不是唯一的，也不是最为必要的。</p>

<p>如果你想继续使用混入的方式，你可以理解那些由不同事情整合继承出来的类，才能通过混入来实现继承，以保证每件事能正常进行。不幸的是，现在这方式可能会修改继承模型，这显得十分刺耳。所以，JS并不对继承多个类进行实现。不过，它还是有一混合的方式来允许在类框架中使用混入方式的。详细看一下下面的函数，它是基于众所周知的<code>extend</code>混入的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">mix</span><span class="p">(...</span><span class="nx">mixins</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kr">class</span> <span class="nx">Mix</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Programatically add all the methods and accessors </span>
</span><span class='line'>  <span class="c1">// of the mixins to class Mix.</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">mixin</span> <span class="nx">of</span> <span class="nx">mixins</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">copyProperties</span><span class="p">(</span><span class="nx">Mix</span><span class="p">,</span> <span class="nx">mixin</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">copyProperties</span><span class="p">(</span><span class="nx">Mix</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">mixin</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">Mix</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">copyProperties</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="nx">of</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">source</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span> <span class="nx">key</span> <span class="o">!==</span> <span class="s2">&quot;constructor&quot;</span> <span class="o">&amp;&amp;</span> <span class="nx">key</span><span class="o">!==</span> <span class="s2">&quot;prototype&quot;</span> <span class="o">&amp;&amp;</span> <span class="nx">key</span> <span class="o">!==</span> <span class="s2">&quot;name&quot;</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="kd">let</span> <span class="nx">desc</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
</span><span class='line'>      <span class="nb">Object</span><span class="p">.</span><span class="nx">definProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">desc</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们可以使用<code>mix</code>函数还创建一个组合型的超级类，通过变量mixins，我们不需要创建详细的继承关系。细想一下，当你编写一个协作编辑工具时，需要记录编辑的动作，同时需要将其内容序列化。你可以使用<code>mix</code>函数来编写一个<code>DistributedEdit</code>的类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">DistributedEdit</span> <span class="kr">extends</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">Loggable</span><span class="p">,</span> <span class="nx">Serializable</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//Event methods</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这对两个世界都很好。通过这例子，可以简单地看到怎么处理使得模型可以混入多个基类：我们可以简单地将基类放到<code>mix</code>函数中，并用类进行扩展继承。</p>

<h4>当前可用性</h4>

<p>好了，我们已经谈到许多有关子类化的内置等所有新功能，但是你是否现在可能使用它呢？</p>

<p>好吧，部分吧。在主要的浏览器商家中，Chrome已经支持我们今天所讨论到大部分的内容。在严格模式中，你可以我们讨论过的所有所有事情，除了<code>Array</code>的子类化。其它内置操作也可以使用，但是<code>Array</code>会出现一些额外的问题，所以可以不奇怪地确定还没有完成。我在firefox实现此功能，并快要接近尾声了（所有除了<code>Array</code>）。可以检查一下 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1141863">bug 1141863</a> 看到更多的信息，但是它会在几周后的日更新版本中出现。</p>

<p>再者，Edge已经支持<code>super</code>，但并不支持子类化的内置操作。Safari并不支持任何函数功能。</p>

<p>转换编译器在部分会有些不利的地方。它们可能创建类，可能使用<code>super</code>，但它们并没有一种方式来子类化内部操作，因为你需要一个引擎来支持一个类的实例能回溯到内置的操作方法(参考<code>Array.prototype.splice</code>)。</p>

<p>好了，这真是长啊。下周，Jason Orendorff 会回来并一起讨论ES6的模块系统。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: let and const]]></title>
    <link href="http://shatle.github.io/blog/2016/03/12/es6-in-depth-let-and-const/"/>
    <updated>2016-03-12T10:47:20+08:00</updated>
    <id>http://shatle.github.io/blog/2016/03/12/es6-in-depth-let-and-const</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/">ES6 In Depth: let and const</a></p></blockquote>

<p>今天我要讨论的特性刚第一眼可能显得很简单，但实际上是很强大的。</p>

<p>当BrenDan Eich在1995年开始设计JS的第一个版本时，它做了很多错误的事情，这些事情还包括之后的语言发展中。例如，当你不小心错误处理<code>Date</code>和其它对象时，会自动转为<code>NaN</code>。但是，有些重要的事情他是正确的，有先见之明：对象、原型、第一类函数有词法作用域（就是函数是有作用域的）、默认是可变的。这语言基础是十分良好的，它优于大家对它的第一印象。</p>

<p>同时，Brendan 创建了个特别的设计并影响到今天的文章 &#8211; &#8211; 我认为他这决定是可以称为一个错误的。它是个小事情，十分微小的事情，你可能使用JS多年还没注意到它。但是，它是重要的，因为从这语言来看，这个错误的设计部分在今天来看，我们认为它是好的部分。</p>

<p>它不得不与变量一起处理。</p>

<h4>问题1：代码块没有作用域</h4>

<p>这问题看起来很无辜：<strong>在JS函数中进行<code>var</code>声明时，变量作用域是可以在整个函数体中的</strong>。其中，有两个方式来看到此问题引起的后果。</p>

<p>一个是在代码块中声明的变量的作用域不仅仅是在此代码块中，它会作用于整个函数。</p>

<p>你之前也许并不会注意到这点，但我担心这一点可能会你并不想看到的。让我们通过一场景来看一下这个狡猾的Bug。</p>

<p>你在某些代码中使用一个名称为<code>t</code>的变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function runTowerExperiment(tower, startTime) {
</span><span class='line'>  var t = startTime;
</span><span class='line'>
</span><span class='line'>  tower.on('click', function() {
</span><span class='line'>    ... code that uses t ...
</span><span class='line'>  });
</span><span class='line'>  ... more code ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>目前，每件事都工作得很好。现在，你想增加保龄球的测速功能，所以，你在内部的callback函数中增加些<code>if</code>表达式。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function runTowerExperiment(tower, startTime) {
</span><span class='line'>  var t = startTime;
</span><span class='line'>
</span><span class='line'>  tower.on('click', function() {
</span><span class='line'>    ... code that uses t ...
</span><span class='line'>    if (bowlingBall.altitude() &lt;= 0 ) {
</span><span class='line'>      var t = readTachymeter();
</span><span class='line'>      ...
</span><span class='line'>    }
</span><span class='line'>  });
</span><span class='line'>  ... more code ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>噢，你无意地增加了第二个名称为<code>t</code>的变量。现在，之前正常工作的<code>t</code>，与一个新的内部的变量<code>t</code>关联上了，替代了外部早已存在的那个变量。</p>

<p>JS中<code>var</code>的作用域类似于PS中的桶刷工具，它会从声明、向前、向后各方向得到扩展，直到它碰到函数的边界，否则一直会起作用。因此，此处目前的<code>t</code>的作用域是向后兼容的，它就是我们在开始进行函数时创建的，这称作为变量升域(hoisting)。我几乎认为，JS引擎通过一个微小的代码起重机，将每个<code>var</code>和<code>function</code>提升到函数闭域的顶部。</p>

<p>现在，升域也是有它好处的。没有这一特性，很多在全局作用域中能很好工作的完美的好的技术将不能在<a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">即时调用函数表达式(IIFE)</a> 使用。但与此同时，升域会导致一个恶心的Bug： 当你使用<code>t</code>去计算时可能会得到<code>NaN</code>，这时你很难去追踪到它，特别是当你的代码大于此时的小例子时。</p>

<p>添加一个新的代码块会导致之前的代码块出现意想不到的错误。它只影响到我？它是不是真的怪异？我们并不想影响到之前的结果。</p>

<p>但是，相对于<code>var</code>的第二个问题，这个问题还是小的。</p>

<h4>问题2：变量在循环中会过度地分享</h4>

<p>你可以先猜测一下，当你运行这代码时会出现什么情况。它很简单：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">messages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hi!&quot;</span><span class="p">,</span> <span class="s2">&quot;I&#39;m a web page!&quot;</span><span class="p">,</span> <span class="s2">&quot;alert() is fun!&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">messages</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">;){</span>
</span><span class='line'>  <span class="nx">alert</span><span class="p">(</span><span class="nx">messages</span><span class="p">[</span><span class="nx">i</span><span class="p">]);;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你看了这一系列的文章，你会知道我很喜欢在例子代码中使用<code>alert()</code>。也许，你也知道<code>alert()</code>是个糟糕的API，它是同步操作的。所以，当一个警告提示窗出现时，输入事件是不会传递的。在你的JS代码、实际在你的整个UI界面基本会是暂停的，直到用户点击确定选项。</p>

<p>多数时候，你在网页中使用<code>alert()</code>是个错误的选择，我之所以使用它，是因为我只觉得<code>alert()</code>是个很好的教学工具。</p>

<p>同时，我还应该被劝说放弃所有的杂乱和坏的行为，它意味着我可以这样创造一个说话的猫：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">messages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Meow!&quot;</span><span class="p">,</span> <span class="s2">&quot;I&#39;m a taling cat!&quot;</span><span class="p">,</span> <span class="s2">&quot;callbacks are fun!&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">messages</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">cat</span><span class="p">.</span><span class="nx">say</span><span class="p">(</span><span class="nx">messages</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</span><span class='line'>  <span class="p">},</span> <span class="nx">i</span> <span class="o">*</span> <span class="mi">1500</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是这会出错。这并不会顺序地说出三个消息，这代码猫会说出三次的&#8221;undefined&#8221;。</p>

<p>你能指出这个问题吗？</p>

<p>这问题出现在唯一的变量<code>i</code>中，它会作用于循环内部和三个延时的返回函数。但当循环完成时，<code>i</code>的值会变成3，因为<code>messages.length</code>等于3，但任一返回函数并没有被调用。</p>

<p>所以，当第一个延时函数工作时，会调用<code>cat.say(messages[i])</code>，它实际会是<code>messages[3]</code>，而这会导致出现<code>undefined</code>。</p>

<p>有很多的方法来解决这一问题，但这个是<code>var</code>的作用域规则导致的第二个问题。首先，确保代码不会有这一问题是十分好的。</p>

<h4>let 新于 var</h4>

<p>在很多时候，JS在设计上的缺陷是不能弥补的（其它语言也会设计缺陷，但JS犹为突出）。向后兼容意味着不能改变已经存在的Web中JS代码行为。甚至，标准委员会也没致力于此，认为解决这些怪异的问题就是自动插入分号(意思是注意细节？)。浏览器制作人并不想对这种破坏性的改变进行实现，因为这些改变会成为其用户的惩罚（也可能会因此失去部分用户）。</p>

<p>所以，大概十年之前，当 Brendan Eich 决定解决这问题时，那时只有一种方式来实现。</p>

<p>他添加了一个新的关键字<code>let</code>，它可以用来声明变量，就像<code>var</code>一样，但其作用域规则更好。</p>

<p>它看起来这样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">readTachymeter</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">messages</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>let</code>和<code>var</code>是不一样的。如果你只是需要在你代码中做个全局的搜索和替换，又可以在你的部分代码中进行中断（有可能是无意的），那么你可以使用怪异的<code>var</code>。但是在更多时候，在ES6中，你应该在任何地方都要停止使用<code>var</code>，而使用<code>let</code>。正因为如此，标题为“let 新于 var”。</p>

<p><code>let</code>和<code>var</code>到底有哪些不一样呢？很高兴你会提问：</p>

<ul>
<li><strong><code>let</code>变量是代码块作用域的</strong>  使用<code>let</code>来声明一个变量，其作用域只会在包含的作用域中，而不是整个函数的内部。</li>
</ul>


<p><code>let</code>也会有一定的升域情况，但是它并不是任意的。用<code>let</code>替换<code>var</code>，可以简单地解决<code>runTowerExperiment</code>例子中的问题。如果你在任何的地方都使用<code>let</code>，你将不会再遇到此类问题。</p>

<ul>
<li><p><strong>全局的<code>let</code>变量并不会成为全局对象的属性</strong> 是的，你不能通过编写<code>window.variableName</code>来访问它们。相反，它们运行在网页中的一个不可见的包含所有JS代码的块中。</p></li>
<li><p><strong>在<code>for (let x ...)</code>的每次循环中会创建新的绑定的变量<code>x</code></strong>。这会有些微小的不同的，意味着<code>for (let ...)</code>循环执行多次时，每次其内部包含一个闭包。就像之前我们的猫例子，每个闭包会得到循环的不同的一个复本，而不是每次闭包得到同一个循环变量。</p></li>
</ul>


<p>所以，对于猫这例子说，将<code>var</code>修改为<code>let</code>就可以解决之前的问题。</p>

<p>这作用于所有的三类<code>for</code>循环表达式：for-of, for-in 和老式C语言的分号方式。</p>

<ul>
<li><strong>在没有遇到<code>let</code>声明之前使用变量会出错</strong>  当控制流没有到达变量声明的代码行时，其是未初始化的。例如：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">update</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;current time:&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">);</span> <span class="c1">//ReferenceError</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">readTachymeter</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这一规则可以帮助你抓取到Bug。结果并不是<code>NaN</code>，你将会在出现问题的代码行中得到一个异常。</p>

<p>这个变量在作用域但并没有被初始化的这一区域，被称为 <em>temporal deal zone</em>(临时死区间)。我一直等待更为专业的术语来描述这事情，就像在写科幻小说一样，然而没有。</p>

<p>（性能详情：在多数情况下，（在变量查找方式中）你可以告知变量是否声明，或者不仅仅去查找相关代码。所以，JS引擎实际上并不是每次都会进行额外的检查，以确认变量是否初始化。但是，在闭包中有时是不明确的，在这些情况下，就意味着使用<code>let</code>会比<code>var</code>慢。）</p>

<p>（作用域详情：在某些编程语言中，变量的作用域开始于其声明的地方，而不是在整个闭合的代码中向后查找。标准委员会认为可以通过<code>let</code>来使用这作用域规则。如此，当<code>t</code>在<code>let t</code>的语句后面调用时，会简单得到一个引用错误，所以，它也不会关联到任一变量。它应该在闭合的作用域中关联到变量<code>t</code>上，但这方法对于闭包或者函数式的升域都是无效的，所以它实际上会被忽略掉。）</p>

<ul>
<li><strong>重复声明变量会引起语法错误</strong> 这一规则也是利于检测细小的错误。同时，它的不同点还有：当你试图将全局的<code>let</code>转化为<code>var</code>，会导致些问题，因为它曾经是个全局<code>let</code>的变量。</li>
</ul>


<p>如果你的某些脚本声明了相同的全局变量，你最好保持使用<code>var</code>。如果你试图转化为<code>let</code>时，那些第二个用到此变量的脚本会出错的。</p>

<p>或者，使用ES6的模块，但是那是之后某天的故事了。</p>

<p>（语法详情：<code>let</code>是在严格的代码模式下是保留关键它。在非严格代码模式下，为了向后兼容，你依然可以声明变量、函数和参数的名称为<code>let</code>。你可以编写<code>var let = 'q';</code>，但你最好不要这让做。同时，<code>let let;</code>也是不允许的。）</p>

<p>除了这些不一样的地方，<code>let</code>和<code>var</code>其实是一样的。它们可以通过逗号来分开声明多个变量，例如，他们也都支持解构(释构？destructuring)。</p>

<p>注意，类<code>class</code>的声明类似于<code>let</code>，而不<code>var</code>。如果你在加载的脚本中多个声明一个类<code>class</code>，在第二次时你会因为重复声明类而得到一个错误。</p>

<h4>常量(const)</h4>

<p>是的，新的东西。</p>

<p>ES6介绍了一个三方的关键字，它可以在<code>let</code>的旁边使用: <code>const</code>。</p>

<p>使用<code>const</code>声明变量类似于<code>let</code>，但不能在声明之外对它进行赋值，这会引起一个语法错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">MAX_CAT_SIZE_KG</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span> <span class="c1">//</span>
</span><span class='line'>
</span><span class='line'><span class="nx">MAX_CAT_SIZE_KG</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span> <span class="c1">// SyntaxError</span>
</span><span class='line'><span class="nx">MAX_CAT_SIZE_KG</span><span class="o">++</span><span class="p">;</span> <span class="c1">// nice try, but still a SyntaxError</span>
</span></code></pre></td></tr></table></div></figure>


<p>明显够了，你不能只声明一个<code>const</code>变量而不赋值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">theFairest</span><span class="p">;</span> <span class="c1">// SyntaxError, you troublemaker</span>
</span></code></pre></td></tr></table></div></figure>


<h4>命名空间的秘密</h4>

<p><em>&#8220;命名空间是一个非常好的主意 &#8211; 让我们更多地使用它&#8221; &#8211; Tim Peters，&#8221;Python 的秘决&#8221;</em></p>

<p>在私底下，内嵌式的作用域是始终围绕编程语言的一个核心概念。自从<a href="https://en.wikipedia.org/wiki/ALGOL">ALGOL</a> 出来后一直就是这样，已经大概有57年了，但对今天来说，此结论更为正确。</p>

<p>在ES3之前，JS只有全局的任务域和函数作用域。（让我们忽略掉<code>with</code>表达式。）ES3介绍了<code>try-catch</code>的表达式，它会增加一个新类型的作用域，此作用域只用来操作异常的变量并作用于<code>catch</code>代码块。ES5通过调用<code>eval()</code>会产生一个新的作用域。ES6添加了代码块作用域，for循环作用域，新的全局<code>let</code>作用域，模块作用域，还有用来解释参数中默认参数的额外作用域。</p>

<p>所有在ES3之后添加的作用域都是必要的，它们使得JS在程序上和面向对象特性上更合理、精确、直观，就如闭包一样；同时，可以和闭包无缝协作。也许你之前并没有注意到这些作用域的规则，如果是这样，说明JS做的工作并没有困扰你。</p>

<h4>现在我能使用<code>let</code>和<code>const</code>吗？</h4>

<p>可以。为了在Web中使用它们，你不得不使用ES6的编译器，如Babel, Traceur, 或者 TypeScript。（Babel 和 Traceur 并不支持 <em>temporal deal zone</em>(临时死区间)。）</p>

<p>io.js 支持<code>let</code>和<code>const</code>，但只能在严格模式下使用，Node.js 在支持上是一样的，但参数<code>--harmony</code>也是必要的。</p>

<p>Brendan Eich 在九年前实现了Firefox中<code>let</code>的第一个版本，这一特性在其标准化进程中进行了彻底的重新设计。为了符合标准，Shu-yu Guo 更新了此实现方式，代码审核由Jeff Walden和其它人完成。</p>

<p>好了，我们展开双手来欢迎新特性。ES6史诗级的特性到现在结束了。在之前两周中，我们完成了多数人渴望在ES6看到的特性的文章。但是首先要说明，下周我们将对之前早些时间提到的新特性：super。所以，和Eric Faust 一块加入我们，深入了解ES6的子类化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: Classes]]></title>
    <link href="http://shatle.github.io/blog/2016/02/23/es6-in-depth-classes/"/>
    <updated>2016-02-23T23:04:55+08:00</updated>
    <id>http://shatle.github.io/blog/2016/02/23/es6-in-depth-classes</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/07/es6-in-depth-classes/">ES6 In Depth: Classes</a></p></blockquote>

<p>今天，我们可以从这一系列的之前复杂的文章中得到些喘息的机会。现在没有新的、没见过的 生成器、代理，这些会影响JS内部运算逻辑的hook，没有新的数据结构可去除用户自己的需求解决方案。相反，我们来讨论些语法性的、惯用的、待解释清楚的旧问题：JS中的对象构建器。</p>

<h4>问题</h4>

<p>我们想要创建一个最为精典的面向对象原则的例子：圆形类。想象一下，我们为一个画布的库编写一个圆形类。在所有事情中，我们需要知道怎么做到以下项：</p>

<ul>
<li>在一画布中画一个圆形</li>
<li>记录画布中圆形的所有数量</li>
<li>记录每一圆形的半径，并确定如何读写这值</li>
<li>计算圆形的面积</li>
</ul>


<p>这用JS的语言可以这么说：我们首先应该创建一个函数构建器，然后为这个函数增加必要的属性，接着使用一个对象来替换构建器中的<code>prototype</code>的属性。当我们开始创建一个实例对象时，这个<code>prototype</code>对象会包含所有属性。即使一个简单的例子，当你输入所有数据时，多数这样的模板也就完成了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">Circle</span><span class="p">.</span><span class="nx">circlesMade</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Circle</span><span class="p">.</span><span class="nx">draw</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">circle</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Canvas drawing code */</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">Circle</span><span class="p">,</span> <span class="s2">&quot;circlesMade&quot;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">_count</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">_count</span><span class="p">;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">_count</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">area</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">radius</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_radius</span><span class="p">;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="nx">radius</span><span class="p">))</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Circle radius must be an integer&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">_radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>这代码不仅仅很繁琐，它还离理想的有些远。它要求对函数的工作方式拥有很好的理解，这很重要，同时，了解各种将属性设置到创建的实例对象中。如果这方法看起来很复杂，不要担心。这整篇文章的目的就是展示一种很简单的方式来做到这些事情。</p>

<h4>定义方法的语法</h4>

<p>在第一次尝试新方法之前，ES6提供了一种新的语法来为一个对象增加特殊的属性。对于上面的例子，它可以很容易地为<code>Circle.prototype</code>添加<code>area</code>的方法，它会让 <code>radius</code>的setter/getter方法更为有效些。作为JS一个面向对象的新方法，人们很乐意去使用一个设计更为精简的对象访问方式。我们需要一个新的方式来为一个对象增加方法，比如添加时如<code>obj.prop = method</code>，而不需要<code>Object.defineProperty</code>这么笨重。人们希望可以让下列的事情更为简单：</p>

<ol>
<li>为一个对象增加普通的函数属性。</li>
<li>为一个对象增加生成器函数属性。</li>
<li>为一个对象增加普通的访问函数属性。</li>
<li>为一个已经完成的对象，通过<code>[]</code>来进行以上三种的操作。我们将这称为 <em>计算属性名称</em>(<em>Computed property names</em>)。</li>
</ol>


<p>有些事情在之前不能操作的。例如，没有一种方式来为<code>obj.prop</code>定义setter和getter方法。因此，新的语法是必定要添加的。你现在可以类似编写如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Methods are now added without a function keyword, using the name of the</span>
</span><span class='line'>  <span class="c1">// property as the name of the function.</span>
</span><span class='line'>  <span class="nx">method</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// To make a method that&#39;s a generator instead, just add a &#39;*&#39;, as normal.</span>
</span><span class='line'>  <span class="o">*</span><span class="nx">genMethod</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Accessors can now go inline, with the help of |get| and |set|. You can</span>
</span><span class='line'>  <span class="c1">// just define the functions inline. No generators, though.</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Note that a getter installed this way must have no arguments</span>
</span><span class='line'>  <span class="nx">get</span> <span class="nx">propName</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Note that a setter installed this way must have exactly one argument</span>
</span><span class='line'>  <span class="nx">set</span> <span class="nx">propName</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// To handle case (4) above, [] syntax is now allowed anywhere a name would</span>
</span><span class='line'>  <span class="c1">// have gone! This can use symbols, call functions, concatenate strings, or</span>
</span><span class='line'>  <span class="c1">// any other expression that evaluates to a property id. Though I&#39;ve shown</span>
</span><span class='line'>  <span class="c1">// it here as a method, this syntax also works for accessors or generators.</span>
</span><span class='line'>  <span class="p">[</span><span class="nx">functionThatReturnsPropertyName</span><span class="p">()]</span> <span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>利用新的语法，我们可以编写如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">Circle</span><span class="p">.</span><span class="nx">circlesMade</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Circle</span><span class="p">.</span><span class="nx">draw</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">circle</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Canvas drawing code */</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">Circle</span><span class="p">,</span> <span class="s2">&quot;circlesMade&quot;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">_count</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">_count</span><span class="p">;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">_count</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">radius</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">get</span> <span class="nx">radius</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_radius</span><span class="p">;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">set</span> <span class="nx">radius</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="nx">radius</span><span class="p">))</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Circle radius must be an integer.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">_radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>显然，这代码与之前的并不完全一样。这里的对象方法定义是可以配置和可列举的，但是在开始的代码中并不没有配置和列举。在实践中，这是很少会引起注意，我为了简洁会减少之前的其中列举和配置。</p>

<p>接着，这代码是不是更好些了，对不对？不幸的是，即使有新的方法定义语法，我们还是没有很多方式来定义<code>Circle</code>，就如我们必须定义函数。没有方法当你在定义函数时，又可以访问其属性。</p>

<h4>类定义语法</h4>

<p>尽管上面代码比较开始的代码已有改进了，但是它依然未达到人们想要的结果，人们希望在JS中有一个简洁的面向对象的解决方案。其它编程语言中有一结构来处理面向对象设计，他们称这结构为类(<em>class</em>)。</p>

<p>这很合理。接着，让我们开始添加类。</p>

<p>我们希望有一个系统，它允许我们增加一个构造函数的方法，其类似于为<code>.prototype</code>增加方法一般，以至于方法能出现在这个类的所有实例中。后来，我们拥有了喜爱的定义新方法的语法，我们肯定会使用它。然后，我们只需要有一种方式来区分哪个是作用类中所有实例的，哪个是作用特定的实例。在C++或Java，其关键字是<code>static</code>，这看起来也很好，我们使用它。</p>

<p>现在，需要在众多的方法中选择一个来作为构造函数，这很有用。在C++或Java中，它是和类史一样的，并且不会返回类型。因此，JS的构造函数也不会返回类型，同时我们需要一个<code>.constructor</code>的属性，为了向后兼容，让我们把这方法叫做<code>constructor</code>。</p>

<p>把所有的东西结合一起，我们可能重新编写我们的Circle类，结果会是如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Circle</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">Circle</span><span class="p">.</span><span class="nx">circlesMade</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kr">static</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">circle</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Canvas drawing code</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kr">static</span> <span class="nx">get</span> <span class="nx">circlesMade</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">_count</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">_count</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kr">static</span> <span class="nx">set</span> <span class="nx">circlesMade</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">thsi</span><span class="p">.</span><span class="nx">_count</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">radius</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">get</span> <span class="nx">radius</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_radius</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="nx">set</span> <span class="nx">radius</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="nx">radius</span><span class="p">))</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Circle radius must be an integer.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">_radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>哇！我们不仅可以将与<code>Circle</code>有关的所有方法整合一起，而且所有事情都看起来很好很简洁。这肯定要优于我们开始做的代码。</p>

<p>尽管如此，你可能还存在部分的边界上问题。我在这里预测并定位一些问题：</p>

<ul>
<li><p><strong>分号怎么样？</strong> &#8211; 有个趋向是“使JS类更像传统中的类”，所以我们决定用更传统的分隔符(分号)。不喜欢它？它是可选的，分号不是必须的。</p></li>
<li><p><strong>如果我不想操作构造函数，但又想为已经创建好的对象增加方法，怎么办？</strong> &#8211; 这也可以。这<code>constructor</code>方法也是可选的。如果你没有定义构造函数，系统会默认如你编写<code>constructor() {}</code>。</p></li>
<li><p><strong>构造函数可以是生成器吗？</strong> &#8211; 不！如果添加的构造函数不是普通函数时会出现<code>TypeError</code>的错误，这里生成器和访问器是一样的。</p></li>
<li><p><strong>我能不能定义<code>constructor</code>为一个计算属性名称?</strong> &#8211; 很不幸，不行。那样真的很难被解释到，所以我们不能这样子。如果你为一个计算属性定义一方法，并命名为<code>constructor</code>，你也将会得到一个名为<code>constructor</code>的方法，那么你也不会得到一个类的构造函数了(想要操作方法，又想成为构造函数，那是不可能的)。</p></li>
<li><p><strong>当我修改<code>Circle</code>的值时，会不会错误地生成一个新的Circle?</strong> &#8211; 不！就像函数的表达式一样，类会为给定的名称进行内部的绑定，这绑定不能为外部操作所改变，所以无论你怎么设置Circle的内部作用域中的值，<code>Circle.circlesMade++</code>的值都会是期望中的一样。</p></li>
<li><p><strong>好吧，我可以将一个对象直接作为函数的参数，但新类语法并不能这样子</strong> &#8211; 很幸运，ES6有这类的表达式。它可以命名也可以不命名，表现的效果与上面描述的是一样的，除了ES6不会在声明的作用域创建变量。</p></li>
<li><p><strong>那它有上面提到可列举等恶作功能吗？</strong> &#8211; 人们都想做到这点，所以你可以给对象安装方法，但列举对象的属性时，你只可以获取给这对象增加的属性，这样也更为合理些。因此，类中的安装方法是配置型的，但并不可列举。</p></li>
<li><p><strong>等，哪有实例变量？那static常量？</strong> &#8211; 你打到我了，你提到的这些并没在刚才的ES6的类定义中。但是，有好消息。它些已经和其它一些特性提到规格进程中了。我是十分支持使用<code>static</code>和<code>const</code>在类语法中定义值的。实际上，它已经提到会议上了。我认为，我们可以在将来看到更多有关于此的讨论。</p></li>
<li><p><strong>好的，很好！我能使用它吗？</strong> &#8211; 并不能真正使用，但有些可用的工具(特别是 Babel )，所以今天你可以通过他们来使用类语法。很不幸运，在是所有主流的浏览器中运行还需要些时间。我已经把今天讨论到的都在<a href="https://nightly.mozilla.org/">Nightly version of Firefox</a>中实现了，同时它也在Edge和Chrome实例了，但默认是不打开的。很不幸，现在看来在Safari中并没有实现。</p></li>
<li><p><strong>Java 和 C++ 有子类和super关键字，但这里并没有提到，那JS呢</strong> &#8211; 它可以。但是，这值得另外一文章来进行讨论。注意查看我们之后的关于子类的更新文章，同时我们还将讨论更多的JS类的功能。</p></li>
</ul>


<p>如果没有 Jason Orendorff 和 Jeff Walden 负责的代码检查和指导，我将不会可能实现类。</p>

<p>下周，Jason Orendorff 会在一周的休息后回来，将讨论<code>let</code>和<code>const</code>主题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: Proxies]]></title>
    <link href="http://shatle.github.io/blog/2016/02/18/es6-in-depth-proxies/"/>
    <updated>2016-02-18T23:04:43+08:00</updated>
    <id>http://shatle.github.io/blog/2016/02/18/es6-in-depth-proxies</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/07/es6-in-depth-proxies-and-reflect/">ES6 In Depth: Proxies</a></p></blockquote>

<p>这是我们今天要做的事情：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">getting</span> <span class="nx">$</span><span class="p">{</span><span class="nx">key</span><span class="p">}</span><span class="o">!</span><span class="err">`</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">setting</span> <span class="nx">$</span><span class="p">{</span><span class="nx">key</span><span class="p">}</span><span class="o">!</span><span class="err">`</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于这第一个例子可能有些复杂，我将会下面进行各部分的说明。现在，先来检查一下我们创建的对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&gt;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">setting</span> <span class="nx">count</span><span class="o">!</span>
</span><span class='line'><span class="o">&gt;</span> <span class="o">++</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">getting</span> <span class="nx">count</span><span class="o">!</span>
</span><span class='line'>    <span class="nx">setting</span> <span class="nx">count</span><span class="o">!</span>
</span><span class='line'>    <span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里发生了什么？我们拦截了这个对象的属性访问，重载了&#8221;.&#8221;操作符。</p>

<h4>它是怎么工作的？</h4>

<p>计算机领域中最好技巧为<em>虚拟化</em>，这是用非常普通的技术来做不可思议的事情。这里说明是怎么做的。</p>

<ol>
<li>使用任意图片</li>
</ol>


<p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/power-plant.jpg" alt="img1" /></p>

<ol>
<li>在图片中的某部分周围画个轮廓</li>
</ol>


<p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/power-plant-with-outline.png" alt="img2" /></p>

<ol>
<li>现在，使用意外的东西，来替换所有轮廓里面或者外面的部分。这里只有一个规则，那就是向后兼容的规则。你的替换操作需要做到的是，之前在其它地方使用的人不会感觉到它的改变。</li>
</ol>


<p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/wind-farm.png" alt="img3" /></p>

<p>通过计算机科学的电影如楚门的世界(The Truman Show)和黑客帝国(Teh Matrix)，你可能非常熟悉这类型的hack。电影中，一个人在轮廓的内部，但是剩余的其它世界都已经被近乎合理的替代了。</p>

<p>为了满足向后兼容的规则，你的替代方式需要巧妙的设计，但真正的关键点在于画好轮廓。</p>

<p>对象轮廓，我理解为一个API的边界，一个接口。接口定义了两部分代码是怎么交互的，每部分期望其它提供什么信息。所以，如果在系统中存在一个接口，也就是说这个轮廓已经画好给你了。你知道，你可以替换这一部分，而其它部分就不用关心了。</p>

<p>当没有存在已有接口时，那么你就不得不创建了。一些酷酷的软件hack所有时间都在没有API的系统中画API的边界，同时将接口编写入现有系统中是个巨大的工程。</p>

<p>虚拟内存(https://en.wikipedia.org/wiki/Virtual_memory )、硬件虚拟化(https://en.wikipedia.org/wiki/Hardware_virtualization )、Docker(https://en.wikipedia.org/wiki/Docker_%28software%29 )、Valgrind(http://valgrind.org/ )、rr(http://rr-project.org/ ) &#8212;- 这些所有的项目在不同层次上将新的和甚至非期望的接口编写对现有系统中。在某些时候，它会消耗多年，然后一个新的操作系统特性、甚至一个新的硬件会出现，从而使得新边界工作得更好。</p>

<p>最好的虚拟化hack需要理解清楚虚拟化什么东西。在为某个事物编写API时，你不得不理解它。只要你理解了，你才能做出令人惊奇的事情。</p>

<p>ES6 为JS推出了虚拟化的最为基础的概念：对象。</p>

<h4>什么是对象</h4>

<p>不，真的，需要等等。想一下，当你知道对象是什么之后再往下看。</p>

<p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/thinker.jpg" alt="img4" /></p>

<p>这问题对我来说太难了，我从来没有听到过一个真正满意的定义。</p>

<p>这是不是很奇怪？定义一个基础的概念总是很难的 &#8212;- 有时可以查看一下 <a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/bookI.html">Euclid 的元素</a>。ECMAScript 指导说明书或许是个好伴侣，但是，它定义一个对象为“类型对象的成员”，完全没有帮助的定义！</p>

<p>后来，说明书添加到“对象是属性的集合”，这也不怎么坏。如果你想要一个定义，现在可以做，但我们将在以后回来讨论它。</p>

<p>我之前有说过，要为某个事物编写API，需要了解它。所以，按照这道理，我认为如果我们做到所有的这些事情，我们需要深入了解对象，这样我们才能可能做些惊奇的事情。</p>

<p>所以，让我们跟随着ECMAScript委员会的步骤，来看看它是怎么使用对象来定义一个API、一个接口的。我们需要哪些方法？对象可能做些什么？</p>

<p>这些依赖于具体的对象。DOM元素对象可以做些确定的事情，AudioNode对象则可以做其它事情。但是，所有的对象都有那么一些基础的能力：</p>

<ul>
<li>对象拥有属性。你可以获取和设置属性，删除它们，等等。</li>
<li>对象拥有原型。这是JS继承的原因。</li>
<li>某些对象是函数或者构建器，你可以调用它们。</li>
</ul>


<p>几乎所有的JS代码，使用属性、原型和函数就可以了。甚至，某些特殊的Element或AudioNode对象行为可以通过调用方法来作用，但这只不过是继承其函数属性。</p>

<p>所以，ECMAScript标准委员会定义了一堆、也就是14个内置的方法，所有的对象都会拥有的接口。这些并不令人感到奇怪，他们最终还是关注于这三个基本点上。</p>

<p>完整的接口方法可以在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#table-5">版本5和6的标准库</a> 找到。这里，我将会对部分进行说明。怪异的双中括号，<code>[[]]</code>，用于强调其是内部的方法，对普通的JS代码是隐藏的。不同于普通方法，你不能调用、删除或者重写这些方法。</p>

<ul>
<li><strong>obj.<a href="key,%20receiver">[Get]</a></strong>  &#8211; &#8211;  获取属性的值</li>
</ul>


<p>当JS代码使用<code>obj.prop</code>或者<code>obj[key]</code>时，其会被调用。</p>

<p>obj 是当前查找的对象，receiver 是第一个查找对象属性的对象。有时，我们不得不查找多个对象，obj可能会是receiver对象原型链上的对象。</p>

<ul>
<li><strong>obj.<a href="key,%20value,%20receiver">[Set]</a></strong> &#8211; &#8211; 为一个对象的属性指派值</li>
</ul>


<p>当JS代码使用<code>obj.prop - value</code>或者<code>obj[key] = value</code>时，其会被调用。</p>

<p>在如<code>obj.prop += 2</code>的指派值中，<code>[[GET]]</code>方法会先调用，接着才调用<code>[[Set]]</code>方法。同理于<code>++</code>和<code>--</code>。</p>

<ul>
<li><strong>obj.<a href="key">[HasProperty]</a></strong> &#8211; &#8211; 检查一个属性是否存在</li>
</ul>


<p>当JS代码使用<code>key in obj</code>时，会调用。</p>

<ul>
<li><strong>obj.<a href="">[Enumerate]</a></strong> &#8211; &#8211; 列出obj对象的可列举的属性。</li>
</ul>


<p>当JS代码使用<code>for (key in obj) ...</code>时，会调用。</p>

<p>这方法会返回一个迭代器对象，这就是<code>for-in</code>循环获得一个对象属性名称的原因。</p>

<ul>
<li><strong>obj.<a href="">[GetPrototypeOf]</a></strong> &#8211; &#8211; 返回对象obj的原型。</li>
</ul>


<p>当JS代码使用<code>obj.__proto__</code>或者<code>Object.getPrototypeOf(obj)</code>时，会调用。</p>

<ul>
<li><strong>functionObj.<a href="thisValue,%20arguments">[Call]</a></strong> &#8211; &#8211; 调用一个函数。</li>
</ul>


<p>当JS代码使用<code>functionObj()</code>或者 <code>x.method()</code>，会调用。这是可选的，并不是每个对象都是函数。</p>

<p>*<strong>constructerObj.<a href="arguments,%20newTarget">[Construst]</a></strong> &#8211; &#8211; 调用一个构造器。</p>

<p>例如，当JS代码使用<code>new Date(2890, 6, 2)</code>时，会调用。这是可选的，并不是每个对象都是个构造器。</p>

<p>其中，newTarget 会在子类中参数扮演着一个角色，我们将会再之后的文章中进行说明。</p>

<p>也许，你可以猜测一下其它的七个方法。</p>

<p>贯穿着ES6的标准库，无论如何，针对对象的任意小语法或者内置函数，都是根据这内置的十四个方法来具体化的。ES6 为一个对象的核心划定了一个边界，而通过任意的JS代码作为代理，来替代各种核心方法。</p>

<p>当我们开始讨论重写这些内置的方法时，记住，我们正在讨论是 重写核心代码的方法，如<code>obj.prop</code>，内置的函数，如<code>Object.keys()</code>，还有更多。</p>

<h4>代理</h4>

<p>ES6 定义了一个新的全局构造器，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>。它有两个参数：一个target对象，一个handler对象。所以，一个简单的例子看起来如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>让我们先把handler对象放一会儿，关注proxy和target对象是怎么关联的。</p>

<p>我可以用一句话来说明proxy是怎么工作的：所有的proxy的内部方法都会面向target。例如，如果某时调用<code>proxy.[[Enumerate]]()</code>，它将会返回<code>target.[[Enumerate]]()</code>。</p>

<p>让我们试一下，我们做些事，它将会触发<code>proxy.[[Set]]()</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">proxy</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="s2">&quot;pink&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>好了，刚才发生了什么？<code>proxy.[[Set]]()</code>应该会调用<code>target.[[Set]]()</code>，所以，target应该有一个新的属性，是不是呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&gt;</span> <span class="nx">target</span><span class="p">.</span><span class="nx">color</span>
</span><span class='line'>    <span class="s2">&quot;pink&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>是的，它是这样子的。还有，其它的内部方法也是一样的。在大多时候，proxy代理对象的行为也和target一样。</p>

<p>这样高保真的操作是受到限制的，是错觉。你可以发现<code>proxy !== target</code>。同时，当target通过类型检查时，其proxy代理对象有时并不能通过。甚至，例如，如果target是一个DOM元素，代理对象proxy并不是真正的一个元素，所以，有时如<code>document.body.appendChild(proxy)</code>会出现<code>TypeError</code>的错误。</p>

<h4>代理处理器(Proxy handlers)</h4>

<p>现在，让我们返回讨论handler对象，它是让代理proxy可用的原因。</p>

<p>这个handler对象的方法可以重载做任意proxy中的内部方法。</p>

<p>例如，如果你想拦截所有设置对象属性的操作，你可以定义<code>handler.set()</code>来做到。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Please don&#39;t set properties on this object.&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;angelina&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">Error</span><span class="o">:</span> <span class="nx">Please</span> <span class="nx">don</span><span class="err">&#39;</span><span class="nx">t</span> <span class="nx">set</span> <span class="nx">properties</span> <span class="nx">on</span> <span class="k">this</span> <span class="nx">object</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>所有的handle方法可以在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Methods_of_the_handler_object">MDN的Proxy文档</a> 看到。这里有十四个方法，这十四个方法也被提到ES6定义为内置方法中。</p>

<p>所有的handler方法都是可选的，如果一个内置方法没有被拦截，那么它将会传递给target，就如之前我们看到的一样。</p>

<h4>例子：“不可能” 自动流对象</h4>

<p>现在，我们对proxy代理已经有足够的了解了，在试用时有时显得很怪异，但有些又不可能离开proxy。</p>

<p>这里，有我们第一个训练的例子。让函数<code>Tree()</code>可以做到：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">tree</span> <span class="o">=</span> <span class="nx">Tree</span><span class="p">();</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">tree</span>
</span><span class='line'>    <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">branch1</span><span class="p">.</span><span class="nx">branch2</span><span class="p">.</span><span class="nx">twig</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">;</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">tree</span>
</span><span class='line'>    <span class="p">{</span> <span class="nx">branch1</span><span class="o">:</span> <span class="p">{</span> <span class="nx">branch2</span><span class="o">:</span> <span class="p">{</span> <span class="nx">twig</span><span class="o">:</span> <span class="s2">&quot;green&quot;</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">branch1</span><span class="p">.</span><span class="nx">branch3</span><span class="p">.</span><span class="nx">twig</span> <span class="o">=</span> <span class="s2">&quot;yellow&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">{</span> <span class="nx">branch1</span><span class="o">:</span> <span class="p">{</span> <span class="nx">branch2</span><span class="o">:</span> <span class="p">{</span> <span class="nx">twig</span><span class="o">:</span> <span class="s2">&quot;green&quot;</span> <span class="p">},</span>
</span><span class='line'>                        <span class="nx">branch3</span><span class="o">:</span> <span class="p">{</span> <span class="nx">twig</span><span class="o">:</span> <span class="s2">&quot;yellow&quot;</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，这些所有的内部对象 branch1/branch2/branch3 当需要时会神奇地自动创建。很方便，是不是？它可能是怎么工作的？</p>

<p>直到现在，并没有方法可以做到。但是，通过proxy代理，只需要几行代码。我们只需要控制<code>tree.[[Get]]()</code>方法。如果你喜欢挑战，你也许可以试图在阅读下面内容之前自己实现它。</p>

<p>这里是我的解决方案：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Tree</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="nx">Proxy</span><span class="p">({},</span> <span class="nx">handler</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">key</span> <span class="k">in</span> <span class="nx">target</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">target</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Tree</span><span class="p">();</span> <span class="c1">// auto-create a sub-Tree</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，最后有<code>Reflect.get()</code>的调用，这证明其非常普通的需求。在这里的 handler 方法中，它代表的意思是“现在只要授权给target进行默认操作”。所以，ES6定义了一个新的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect 对象</a> 并包含有14个方法，你可以真正地使用起来。</p>

<h4>例子：一个只读视图</h4>

<p>我想，我可能会给人一种错误的印象，proxy代理是容易使用的。让我们做更多的一个例子，看看这看板是否正确吧。</p>

<p>这次，我们的分配更加复杂些：我们需要实现这个函数<code>readOnlyView(object)</code>，它可接收任意对象并返回一个proxy代理，代理行为看起来像接收对象一样，除了代理对象是不可变的。所以，例如，它应该看起来这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">newMath</span> <span class="o">=</span> <span class="nx">readOnlyView</span><span class="p">(</span><span class="nb">Math</span><span class="p">);</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">newMath</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="mi">54</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
</span><span class='line'>    <span class="mi">40</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">newMath</span><span class="p">.</span><span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">Error</span><span class="o">:</span> <span class="nx">can</span><span class="s1">&#39;t modify read-only view</span>
</span><span class='line'><span class="s1">&gt; delete newMath.sin;</span>
</span><span class='line'><span class="s1">    Error: can&#39;</span><span class="nx">t</span> <span class="nx">modify</span> <span class="nx">read</span><span class="o">-</span><span class="nx">only</span> <span class="nx">view</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们应该怎么实现它呢？</p>

<p>第一步，我们需要修改穿过方法的目标对象，截获它所有的内部方法。这里需要修改五个内部方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">NOPE</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;can&#39;t modify read-only view&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Override all five mutating methods</span>
</span><span class='line'>  <span class="nx">set</span><span class="o">:</span> <span class="nx">NOPE</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">defineProperty</span><span class="o">:</span> <span class="nx">NOPE</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">deleteProperty</span><span class="o">:</span> <span class="nx">NOPE</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">preventExtensions</span><span class="o">:</span> <span class="nx">NOPE</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">sePrototypeOf</span><span class="o">:</span> <span class="nx">NOPE</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">readOnlyView</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="nx">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是可行的，通过这只读视图，它会阻止设值、属性定义等。</p>

<p>这结构有什么漏洞吗？</p>

<p>这里最大的问题是<code>[[Get]]</code>方法，还有其它，可能会返回可变的对象。所以，当某个对象 x 是个只读的视图，x.prop 是可变的。这是个大大的漏洞。</p>

<p>为了修补它，我们需要添加一个<code>handler.get()</code>方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Wrap other results i read-only veiws.</span>
</span><span class='line'>  <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Start by just doing the default behavior.</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Make sure not to return a mutable object!</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="o">===</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// result is an object.</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">readOnlyView</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// result is a primitive, so already immutable.</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样依然没有达到效果，类似的代码需要在其它方法中实现，包含<code>getPrototypeOf</code>和<code>getOwnPropertyDescriptor</code>。</p>

<p>然后，会有些更多的问题。当一个 getter 或者 方法在这类的代理中被调用时，这个<code>this</code>值会传递给proxy代理对象本身。但是，就像之前我们看到的，proxy代理对象在很多的接收器(accessors)和方法的类型检查中是不会通过的，这里最好是对目标对象来替代代理对象。你能指出怎么做吗？</p>

<p>这文章看到创建一个代理对象是十分方便的，但是想创建一个拥有直觉行为的代理对象是十分困难的。</p>

<h4>零碎的东西</h4>

<ul>
<li><strong>proxy代理善于做什么</strong></li>
</ul>


<p>当你想监视或者记录一个对象的访问时，它确实是有用的。这样，它可以用来调试。测试框架可以用它来创建<a href="https://en.wikipedia.org/wiki/Mock_object">模拟对象(Mock object)</a></p>

<p>当你希望的行为只是一个普通可以做的，proxy代理是有用的，如：懒惰的流行属性设置。</p>

<p>尽管我很不喜欢这方式，但是，当使用代理时，想要知道其代码是怎么运行的，最好的办法之一是将代理中的handler对象使用另外一个代理进行包裹起来，从而用来记录每次handler方法的访问。</p>

<p>代理可以限制一个对象的访问，就像我们刚才做的<code>readOnlyView</code>。这类型的使用场景在应用代码中比较少见，但是Firefox使用代理对不同域名中的<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Gecko/Script_security">安全边界</a> 进行了内部实现。代理是我们(Firefox)安全模型的一个关键点。</p>

<ul>
<li><strong>代理 结合 WeakMaps</strong> 。在我们的<code>readOnlyView</code>例子中，每次的对象访问中我们会创建一个新的代理。使用 WeakMap 来创建每个代理对象，其可以缓存并减少内存的消耗，所以，虽然<code>readOnlyView</code>会传递很多的对象，但是真正只有一个代理对象被创建。</li>
</ul>


<p>这是一个刺激使用<code>WeakMap</code>的使用场景。</p>

<ul>
<li><p><strong>可废除的代理</strong>。ES6 还定义另外的函数<code>Proxy.revocable(target, handler)</code>，它会创建一个代理，就像<code>new Proxy(target, handler)</code>，但这个代理对象在之后是可以废除的。(<code>Proxy.revocable</code>返回一个包含有<code>.proxy</code>属性和<code>.revoke</code>方法的对象。)只要一个代理对象被废除，它就不能再工作了；所有的内部方法都会抛出(错误提示？)。</p></li>
<li><p><strong>对象不变量</strong>。在某些场景中，ES6会要求proxy的处理方法得出的结果包含有target对象的状态，这是为了想得到强制性的对所有对象的不可变的规则，甚至包括代理对象。例如，一个代理不能声明为不可扩展的，除非它的target对象是真正不能扩展的。</p></li>
</ul>


<p>准确的规则在这里来说是比较复杂的，但是，如果你看到一个错误的信息如<code>"proxy can't report a non-existent property as non-configurable"</code>时，这就是原因。这有点像补救而改变代理对象怎么输出它自己；另外的可能是改变target对象用来进行反射，而不理会代理对象怎么输出。</p>

<h4>现在对象是什么？</h4>

<p>我想，我们已经偏离了“对象是属性的集合”。</p>

<p>我并不乐意这个定义，即使当然地包括原型(prototypes)和callability。我认为 “集合”这一词太笼统了，它并不能表明代理对象是什么，代理对象的处理方法可以做任意事情，它可以返回任意的结果。</p>

<p>为了说明一个对象能做什么，对对象方法进行标准化、虚拟化第一类的特性以至于每一个人都能使用，ECMAScript标准委员会正扩展其可能性。</p>

<p>现在，对象可能是任何事物。</p>

<p>也许，更为诚实的问题是“什么是一个对象？”，现在是，其有十二个内部方法，一个对象在JS程序中有<code>[[Get]]</code>操作，有<code>[[Set]]</code>操作，等等。</p>

<p>现在，我们是否理解了对象真正是什么了吗？我并不确定！我们做了不可思异的事情？是的，我们做了之前JS不可能做的事情。</p>

<h4>今天我可以使用代理吗？</h4>

<p>不。无论如何，它并不能在Web开发中使用。只有Firefox和微软的Edge浏览器支持代理，也没有额外的转换工具。</p>

<p>自从V8现实了代理的旧版本后，要在 Node.js 和 io.js 使用代理，需要使用默认关闭的选项(<code>-- harmony_proxies</code>) 和 <a href="https://github.com/tvcutsem/harmony-reflect">harmony-reflect</a> 工具。</p>

<p>所以，可以尝试使用代理。创建一个大的镜子，里面包括有成千的对象复制品，所有都是类似的，都是很难调试的。现在是时候使用代理了，但对于生产环境你的代理代码可能还是会有些危险的。</p>

<p>代理的第一次实现是在2010年，由Andreas Gal实现，Blake Kaplan进行代码审查。接着，标准委员会又完全重新设计了这一特性。Eddy Bruel 在2012年根据新的说明重新实现了。</p>

<p>我实现了<code>Reflect</code>，代理审查由 Jeff Walden 进行，它将会在这周末的Firefox的Nightly版本中出现 &#8211; &#8211; 除了<code>Reflect.enumerate()</code>没有实现。</p>

<p>下一步，我们将讨论ES6中最富有争议的特性，一个在Firefox内部的提出人更优于实现人的特性。所以，在于下周加入我们，Mozilla工程师 Eric Faust 展示 <em>深入ES6 的类</em>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: Generators, continued]]></title>
    <link href="http://shatle.github.io/blog/2016/01/27/es6-in-depth-generators/"/>
    <updated>2016-01-27T22:35:21+08:00</updated>
    <id>http://shatle.github.io/blog/2016/01/27/es6-in-depth-generators</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/07/es6-in-depth-generators-continued/">ES6 In Depth: Generators, continued</a></p></blockquote>

<p>欢迎回到 深入ES6。我希望你们能在我们的暑假期间也很快乐，但是编程大大的生活不能总是烟花和柠檬水，现在是时候拾起我的丢下的 &#8212;- 重新开始我已经讨论完美的主题(深入ES6)。</p>

<p>在5月份，我写到生成器，这是ES6中的新功能。我在ES6中称它为最为魔法的特性，谈到它是怎么影响将来的异步编程的。然后，我写到：</p>

<blockquote><p>对于生成器还有更多的东西要说的。&#8230; 但是，我认为这文章已经够长的了，现在足够引起疑惑了。就如生成器一般，我们应该暂停一下，在以后的时间再继续 。</p></blockquote>

<p>现在，是时候了。</p>

<p>你可以在<a href="http://shatle.github.io/blog/2015/09/26/es6-in-depth-generators/">这里看第一部分的内容</a>。在阅读现在这篇文章时，最好先读一下链接中文章。继续，这里很有意思，它有有点长、有点令人困惑。但，它是个会说话的猫(?)。</p>

<h4>快速场景</h4>

<p>上次，我们关注生成器的基本用法，它也许可能有点奇怪，但是并不难理解。一个生成器函数看起来像个普通的函数，主要的不同点在于生成器函数的内容并不仅仅运行一次。每次运行时，会暂停而去执行<code>yield</code>的表达式。</p>

<p>这具体的细节已经在之前的文章已经说明，但是，我们并没有做个彻底的把所有部分都整合在一起的例子。让我们现在开始做吧。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">someWords</span><span class="p">(){</span>
</span><span class='line'>  <span class="k">yield</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">yield</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">word</span> <span class="nx">of</span> <span class="nx">someWords</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">alert</span><span class="p">(</span><span class="nx">word</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这脚本够直接的了，但是，如果你注意到代码之间发生的事情，它就像是所有不同代码组成的一台戏，这时就是个不同的脚本了，它可能看起来会是这样：</p>

<p><em>(略)</em></p>

<p>这并不是什么<em>哈姆雷特</em>，但你可以想象一下这场景。</p>

<p>就如你在这戏中看到的，当一个生成器对象第一次出现时，它会暂停。每次当方法<code>.next()</code>被调用时，它就会醒来。</p>

<p>这动作是同步的、单线程的。注意，这里只有一个角色是可以在任意时间做任何事情，这角色不会互相打断对方，也不会与他人进行交互。他们轮流说话，而且，只要他们想，他们就可以想说多久就多久。(就像是莎士比亚!)</p>

<p>在这戏剧的一些版本中，生成器每次相当于被喂食给<code>for-of</code>循环。在这过程中，会有<code>.next()</code>方法在按序地执行，但并不会出现在你的任何代码中。这里，我把它放到舞台中，但对你们和你们的程序来说，所有的这些是在后台发生的，因为生成器和<code>for-of</code>循环在设计时是一起工作的，他们通过<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-iterator-interface">这个迭代接口</a> 实现的。</p>

<p>所以，总结这里的点：</p>

<ul>
<li>生成器对象是个听话的机器人，它可以产出值；</li>
<li>每次这机器人的程序包括一个简单的代码块，生成器的主体函数会生成这代码块。</li>
</ul>


<h4>怎么关闭一个生成器</h4>

<p>生成器有一些非常巧妙的特性，我并没有在第一部分进行说明：</p>

<ul>
<li><code>generator.return()</code></li>
<li><code>generator.next()</code>可选参数</li>
<li><code>generator.throw(error)</code></li>
<li><code>yield*</code></li>
</ul>


<p>我跳过这些主要是因为没有理解为什么这些特性会存在。我们很难注意到这些特性，在你们的脑子里并没有直接的印象。但是，当我们细想我们的程序是怎么使用生成器时，我们就能看到原因。</p>

<p>这里有些你可能会碰到过：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">doThings</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">setup</span><span class="p">();</span>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ..do some things ...</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">cleanup</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">doThings</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个cleanup方法可能会关闭连接或者是文件，释放系统资源，或者只是更新DOM去关闭“处理中&#8221;的加载图标。我们希望无论我们的工作是否成功完成都能执行它，所以它会出现在<code>finally</code>代码块中。</p>

<p>那么在生成器中会是怎么样的呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">produceValues</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">setup</span><span class="p">();</span>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ... yield some values ...</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">cleanup</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">produceValues</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">work</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这看起来很好，但是这里有点小问题：<code>work(value)</code>的调用并不在try的代码块中，如果有异常抛出，我们 cleanup 的时候会发生什么呢？</p>

<p>或者，当 <code>for-of</code> 循环中包含有 break 或者 return 语句时，cleanup的时候又会发生什么呢？</p>

<p>无论它怎么执行，你都可以控制它。</p>

<p>当我们谈到<a href="http://shatle.github.io/blog/2015/09/09/es6-in-depth-iterators-and-the-for-of-loop/">迭代器和for-of循环</a> 时，我们说到迭代器的接口里有一个可选的 <code>.return()</code>的方法，当每次迭代完成之前它都会被自动调用。生成器也支持些方法。调用<code>myGenerator.return()</code>方法，会最终运行任意的<code>finally</code>的代码块，然后退出，就像是当前<code>yield</code>当作为return的返回语句一样。</p>

<p>注意，<code>.return()</code>并不会被JS的所有内容所调用，只有当JS使用到了迭代器的协议时才会。所以，一个生成器在没有运行 finally 代码块时有可能会被垃圾回收掉。</p>

<p>为什么这特性没有在剧本中体现呢？当一个任务正在依赖其它步骤完成的时候，生成器会被冻结，就像建造一幢大楼一样。突然，某人抛出了一个错误！<code>for</code>循环会抓取到它，并把它放到一边，并告诉生成器调用 <code>.return()</code>方法。生成器会安静地拆除整个建筑架子并关闭它。然后，<code>for</code>循环会获取到错误，一个普通的异常会继续处理中。</p>

<h4>生成器管理</h4>

<p>目前，我们看到了生成器与其用户之间的会话的其中一方面，先打断一下之前的剧场类比：</p>

<p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/generator-messages-small.png" alt="img" /></p>

<p>用户是主管，生成器会按照要求工作。但是，这并不是生成器的唯一编程方式。</p>

<p>在第一部分的文章中，我说过，生成器可以用于异步编程，也就是你可以用生成器来替代 异步的返回函数或者 promise 链。你可能会对它如何支持工作感到迷惑，为什么yield的能力那么有效(毕竟这是生成器特殊的能力)？毕竟，异步代码不仅是yield而已，它会触发更多的事情。然后，它返回到循环的事件中，等待处理那些异步进程，并完成它们。生成器是怎么做到这些的？没有返回函数，当数据 从文件、数据库和服务器中 返回时，生成器是怎么接收的呢？</p>

<p>为了接近答案并开始工作，如果我们通过仅能调用的<code>.next()</code>方法传递参数来给生成器，通过这交易，我们可以看到整个新类型的会话：</p>

<p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/generator-messages-2-small.png" alt="img" /></p>

<p>生成器的<code>.next()</code>方法实际上可以接收一个可选的参数，同时，它会聪明地将这参数作为value值返回到生成器中的yield的表达式中。是的，yield 并不类似于 return，这包含于个value值，生成器会获取一次。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">getDataAndLatte</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">areaCode</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面一行简单的代码做了很多的事情：</p>

<ul>
<li>它会调用 <code>getDataAndLatter()</code>，此函数会返回一个我们在屏幕中看到的字符串“get me the database records for area code &#8230; &#8220;。</li>
<li>它会暂停生成器，yield 这字符串值</li>
<li>这时，许多时间会过去</li>
<li>最终，某人调用<code>.next({data: ..., coffee: ...})</code>。我们存储相应的对象到本地的变量<code>results</code>中，并继续下一行代码。</li>
</ul>


<p>为了展示其内容，下面的代码显示了的整个会话：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">request</span><span class="p">){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">getDataAndLatter</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">areaCode</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">results</span><span class="p">.</span><span class="nx">coffee</span><span class="p">.</span><span class="nx">drink</span><span class="p">();</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">mostUrgentRecord</span><span class="p">(</span><span class="nx">results</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
</span><span class='line'>  <span class="k">yield</span> <span class="nx">updateStatus</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="s2">&quot;ready&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，yield 仍然是之前的意思：暂停生成器并传递个value值给调用者。但是，事情发生了变化。生成器希望从其调用者中得到具体的支持性的行为，这意味着其希望调用者扮演着一个管理助手。</p>

<p>普通的函数并不会这样。它们倾向于服务它们调用者的需求。但是，你可以为生成器指定会话的代码，从而加大生成器与其调用者之间的联系。</p>

<p>管理助手式的生成器运行会是什么样？它并不是个复杂的事情，它可能看起来如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">runGeneratorOnce</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">status</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">status</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span> <span class="c1">// phew!</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// The generator has asked us to fetch something and</span>
</span><span class='line'>  <span class="c1">// call it back when we&#39;re done.</span>
</span><span class='line'>  <span class="nx">doAsynchronousWorkIncludingEspressMachineOperations</span><span class="p">(</span>
</span><span class='line'>    <span class="nx">status</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span>
</span><span class='line'>    <span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">nextResult</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">runGeneratorOnece</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">nextResult</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了保证运行，我们不得不创建一个生成器并运行一次，类似：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">runGeneratorOnce</span><span class="p">(</span><span class="nx">handle</span><span class="p">(</span><span class="nx">request</span><span class="p">),</span> <span class="kc">undefined</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在五月份，我提到<code>Q.async()</code>就是个例子，这库中的生成器会被看作为异步进程，并在需要时自动运行。<code>runGeneratorOnce</code>就是做这种事。实际上，生成器不会并不会处理其yield的值，这应该由其调用者来做。生成器只会yield Promise对象。</p>

<p>如果你已经懂得promise，现在又理解了生成器，你可以会想试着修改<code>runGeneratorOnce</code>来支持promise。这会是个困难的实践，但只要你做成了，你将可以直接使用promise来编写复杂的异步逻辑的算法，而不是<code>.then()</code>或者一个返回函数了。</p>

<h4>怎么扩展生成器</h4>

<p>你是否看到<code>runGeneratorOnce</code>是怎么处理错误的？它忽略了他们。</p>

<p>好的，这并不是好主意。我们总得需要生成器报告错误出来，生成器其实是支持的：你可以调用<code>generator.throw(error)</code>而不用<code>generator.next(result)</code>。这会导致<code>yield</code>的表达式会被抛出，就如<code>.return()</code>，生成器会被杀死。但是，如果当前yield的地方在一个try代码块中，然后then和finally代码块会被尊重，生成器会继续恢复运行。</p>

<p>修改<code>runGeneratorOnce()</code>并适应地使用<code>.throw()</code>是另外一个好的实践，这样可以保证异常在生成器内部抛出，并传播给调用者。所以，<code>generator.throw(error)</code>会正常抛出 error 错误，除非你在生成器中获取了它。</p>

<p>当一生成器遇到<code>yield</code>表达式并停止时，可能会有的操作：</p>

<ul>
<li>某些人会调用<code>generator.next(value)</code>，这时，生成器会从上次结束执行的地方再次恢复执行。</li>
<li>某些人会调用<code>generator.return()</code>，传递的值是可选的。这情况，无论生成器在做什么，将不会恢复执行，而只会执行 <code>finally</code>代码块。</li>
<li>某些人会调用<code>generator.throw(error)</code>，这生成器就会表现如<code>yield</code>表达式调用一个函数并返回错误一样。</li>
<li>或者，没有人做任何事情。生成器会永远处理冻结状态。(是的，这可能会导致一个生成器进入<code>try</code>代码块之后，而不会去执行<code>finally</code>代码块。当生成器处于此状态时，它甚至可以从垃圾回收器那里重新恢复使用。)</li>
</ul>


<h4>一起工作的生成器</h4>

<p>让我多展示一个特性，我们可以编写一个简单的生成器函数，作用是连接两个迭代对象集：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">concat</span><span class="p">(</span><span class="nx">iter1</span><span class="p">,</span> <span class="nx">iter2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">iter1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">yield</span> <span class="nx">value</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">iter2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">yield</span> <span class="nx">value</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>ES6还支持缩写的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">concat</span><span class="p">(</span><span class="nx">iter1</span><span class="p">,</span> <span class="nx">iter2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">yield</span><span class="o">*</span> <span class="nx">iter1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">yield</span><span class="o">*</span> <span class="nx">iter2</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个普通的<code>yield</code>表达式会 yield 一个简单值，一个<code>yield*</code>表达式会消费整个迭代器并yield所有的值。</p>

<p>这个语法还解决另外一个有趣的问题：在一个生成器内部应该怎么调用生成器的问题。在普通的函数中，我们可以从一个函数中抽取一部分的代码，并重构成为一个单独的函数，而不会修改其行为。很明显，我们也将会重构生成器，但是我们需要找出一个方法来调用分解出去的子程序，同时需要确认在每次原有yield值之前，处理好子程序的yield操作，尽管那子程序也会生产出值。<code>yield*</code>就是处理这情况的方式。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">factoredOutChunkOfCode</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">refactoredFunction</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="k">yield</span><span class="o">*</span> <span class="nx">factoredOutChunkOfCode</span><span class="p">();</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以类比想象一下，一个管道程序将部分子任务授予给其它进行操作。当编写大型的基于生成器的项目时，需要保持代码的清晰和易管理，你可以看到这方法是十分重要的，就类似函数在同步代码中的重要一般。</p>

<h4>退场</h4>

<p>好了，这就是生成器。我希望你也能够和我一样喜欢它，很高兴回过头再次提到它。</p>

<p>下周，我们将讨论另外让人脑洞大开的特性，也是ES6中新的特性。这是新类型，它是微小又狡猾的，在你还没有在这里了解它时可能你已经使用到它了。请在下周加入我们，一起开始<strong>深入ES6代理</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: Collections]]></title>
    <link href="http://shatle.github.io/blog/2016/01/27/es6-in-depth-collections/"/>
    <updated>2016-01-27T22:33:13+08:00</updated>
    <id>http://shatle.github.io/blog/2016/01/27/es6-in-depth-collections</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/06/es6-in-depth-collections/">ES6 in Depth: Collections</a></p></blockquote>

<p>在本周早些时候，ES6的规格说明文档，官方名称为<em>ECMA-262, 6th Edition, ECMAScript 2015 Language Specification</em>，已经解决所有问题并得到了Ecma标准委员会的认可，感谢 TC39 及每一位为此做出贡献的人。庆祝ES6。</p>

<p>更为令人兴奋的消息：下一版本将不超过六年的时间。标准委员会现在的目标是在每十二月出一个粗略的版本，<a href="https://github.com/tc39/ecma262">第七版本的计划</a>已经在开发中。</p>

<p>为了庆祝这一事件，我将适宜地讨论些特性，这特性是我很长时间内、一直渴望在JS看到的。同时，我认为它仍然在将来存在着提升的空间。</p>

<h4>JS进化的难点</h4>

<p>JS并不像其它编程语言，它在有些方面影响着JS语言的发展。</p>

<p>ES6 模块是一个好的例子。其它语言都有模块的系统，Racket有个好的，Python也有。当标准委员会决定为ES6加入模块时，为什么不直接复制现有的系统呢？</p>

<p>JS是不一样的，因为它运行于网页浏览器中，输入输出(I/O)可能会需要很长的时间。因此，JS需要一个的模块系统是能够支持异步加载代码的，同时它也不同连续地在不同的目录中检索模块。复制现有的系统是好的，但ES6的模块需要做些新的东西。</p>

<p>这是怎么影响到最终的设计的呢？这是个有意思的故事。但是，我们并不在这文章中讨论模块。</p>

<p>这文章讨论的是ES6的Keyed collections: Set、Map、WeakSet、WeakMap。这特性在很多程度上说类似于其它语言的Hash Table。但是，标准委员会做了些折中的方法，因为JS是不同的。</p>

<h4>为什么集合</h4>

<p>每个人都很熟知JS中已经内置了类似于哈希表(hash table)的结构：对象(object)。</p>

<p>毕竟，一个普通的对象并没有什么奇特的，只是一个打开的key-value的键值对。你可以获取、设置，还有删除属性，还可迭代它们 &#8211; 所有哈希表能做的事情。但为什么还要加这个新的特性呢？</p>

<p>好了，许多程序使用普通的对象存储k/v的键值对，对程序来说这是可行的，所以没有特殊的原因去转换到Map或者Set中。同时，使用对象存在着此众所周知的问题：</p>

<ul>
<li>对象在查找表时并不会查找对象中的方法，这可以避免些冲突</li>
<li>因此，程序必须使用<code>Object.create(null)</code>(而不是普通的<code>{}</code>)或者编码时特别小心，从而避免无意的内置方法(如<code>Object.prototype.toString)</code>被当成数据。</li>
<li>属性的关键字永远是字符串，在ES6中也可以是标志符(symbol)。对象不能当作是关键字。</li>
<li>没有有效的方法查询一个对象拥有多少个属性。</li>
</ul>


<p>ES6添加个新点：普通的对象并不作为迭代器，所以它不能使用<code>for-of</code>循环、<code>...</code>操作符，等等。</p>

<p>再次，大多数程序并不会有什么问题，普通的对象将是个继续可用的方案。<code>Map</code>和<code>Set</code>可作为其它的选择。</p>

<p>因为它们被设计为 避免用户数据和内置方法的冲突。ES6的集合不会用属性暴露它们的数据，这意味着表达式如<code>obj.key</code>或者<code>obj[key]</code>并不能访问哈希表数据，你将不得不编写<code>map.get(key)</code>。哈希表的实体，并不像属性，它并不会继承原型链。</p>

<p>这样的优势，它不像<code>Object</code>s，<code>Map</code>和<code>Set</code>可以拥有方法，它可以在标准库中或者你自己的子类中可以添加更多的方法，并不会冲突。</p>

<h4>Set</h4>

<p>Set 是值的集合，它是可变的，所以你的程序可以在任意时候添加或删除值。目前，它就像是数组。但是，就像相同点，set和数组中也有许多不同点。</p>

<p>首先，不像数组，Set不会包括两个相同的值。如果你试图添加一个已经存在的值，并不会影响到什么。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">desserts</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="s2">&quot;🍪🍦🍧🍩&quot;</span><span class="p">);</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">desserts</span><span class="p">.</span><span class="nx">size</span>
</span><span class='line'>    <span class="mi">4</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">desserts</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s2">&quot;🍪&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">Set</span> <span class="p">[</span> <span class="s2">&quot;🍪&quot;</span><span class="p">,</span> <span class="s2">&quot;🍦&quot;</span><span class="p">,</span> <span class="s2">&quot;🍧&quot;</span><span class="p">,</span> <span class="s2">&quot;🍩&quot;</span> <span class="p">]</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">desserts</span><span class="p">.</span><span class="nx">size</span>
</span><span class='line'>    <span class="mi">4</span>
</span></code></pre></td></tr></table></div></figure>


<p>这例子使用的是字符串，但是Set可以包含任意JS的值。类似字符串，多次添加同一对象或者数值也是没有影响的。</p>

<p>其次，Set 有自己的数据管理，可以使得其一的操作更加快速：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&gt;</span> <span class="c1">// Check whether &quot;zythum&quot; is a word.</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">arrayOfWords</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s2">&quot;zythum&quot;</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// slow</span>
</span><span class='line'>    <span class="kc">true</span>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">setOfWords</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s2">&quot;zythum&quot;</span><span class="p">)</span> <span class="c1">// fast</span>
</span><span class='line'>    <span class="kc">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>你不能通过index索引访问：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&gt;</span> <span class="nx">arrayOfWords</span><span class="p">[</span><span class="mi">15000</span><span class="p">]</span>
</span><span class='line'>    <span class="s2">&quot;anapanapa&quot;</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">setOfWords</span><span class="p">[</span><span class="mi">15000</span><span class="p">]</span> <span class="c1">// sets don&#39;t support indexing</span>
</span><span class='line'>    <span class="kc">undefined</span>
</span></code></pre></td></tr></table></div></figure>


<p>以下是Set的操作：</p>

<ul>
<li><code>new Set</code>创建一个新的、空的Set。</li>
<li><code>new Set(iterable)</code>可以创建一个新的set，并将迭代器的值放到set中。</li>
<li><code>set.size</code> 得到set的值的数量</li>
<li><code>set.has(value)</code>如果set中包含有给定的值，它返回<code>true</code>。</li>
<li><code>set.add(value)</code> 添加一个值到set中。如果set中已经存在这个值，就不会有作用。</li>
<li><code>set.delete(value)</code> 从set中移除一个值。如果这个值并不在set中，不会有作用。<code>.add()</code>和<code>.delete()</code>都会返回set的本身，所以你可以链式地使用它们。</li>
<li><code>set[Symbol.iterator]()</code>会返回一个包含set的值的迭代器，你通常不用显示地调用，但是它是通过此方法来实现set的迭代器的。这意味着你可以使用<code>for (v of set){ ... }</code>，等等。</li>
<li><code>set.forEach(f)</code>是最简单解释的代码，它就像是缩写：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">set</span><span class="p">)</span>
</span><span class='line'>   <span class="nx">f</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">set</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法类似于数组中的<code>.forEach()</code>方法。</p>

<ul>
<li><code>set.clear()</code> 删除set中的所有值。</li>
<li><code>set.keys()</code>，<code>set.values()</code> 和<code>set.entires()</code>返回相应的迭代器。它们可以适配于<code>Map</code>，所以我们将在下面提到Map。</li>
</ul>


<p>众多特性，<code>new Set(iterable)</code>这个构建器是十分出众的，因为它操作着整个数据结构。你可以使用它来将数组转为一个set，用一行代码来消除重复的值。或者，传递一个生成器：它会完整的运行这个生成器并收集所有处理过的值放到一个set中。这构建器还可以让你复制一个已经存在的set。</p>

<p>上周我们承诺会提到ES6集合中的一些让人抱怨的地方，我将在这里提到。正如Set有各种的好处，但它同时也缺失部分方法，这些方法将会在以后工作增加：</p>

<ul>
<li><p>功能性的帮助方法已经在现在有数组中存在了，如 <code>.map()</code>、<code>.filter()</code>、<code>.some()</code>和<code>.every()</code>。</p></li>
<li><p>不作变化的 <code>set1.union(set2)</code>和<code>set1.intersection(set2)</code>。</p></li>
<li><p>可以操作多个值的方法：<code>set.addAll(iterable)</code>、<code>set.removeAll(iterable)</code>、<code>set.hasAll(iterable)</code>。</p></li>
</ul>


<p>好消息是可以通过ES6的特性可以有效地实现这些方法。</p>

<h4>Map</h4>

<p>Map 是一个 key/value的键值对的集合，Map可以做：</p>

<ul>
<li><code>new Map</code>返回一个新的、空的map</li>
<li><code>new Map(pairs)</code>创建一个新的map，并把存在的<code>[key, value]</code>键值对集合填充到这里面。键值对可以是一个已经存在的map对象，一个两个元素的数组，一个处理两个元素的数组的生成器，等等。</li>
<li><code>map.size</code>返回map的实体数量。</li>
<li><code>map.has(key)</code>测试是否包含有key，类似 <code>key in obj</code>。</li>
<li><code>map.get(key)</code>获取关联key的值，或者，如果没有这个实体，会返回 undefined，类似<code>obje[key] = value</code>。</li>
<li><code>map.set(key, value)</code>为 map 添加一个实体，包含key和value。如果已经存在有相同的key，旧实体会被覆盖，类似 <code>obj[key] = value</code>。</li>
<li><code>map.delete(key)</code>删除一个实体，类似<code>delete obj[key]</code>。</li>
<li><code>map.clear()</code>删除map的所有实体。</li>
<li><code>map[Symbol.iterator]()</code>返回map中所有实体的迭代器，这迭代器的每个实体是一个<code>[key, value]</code>数组。</li>
<li><code>map.forEach(f)</code>工作如：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="nx">of</span> <span class="nx">map</span><span class="p">)</span>
</span><span class='line'>    <span class="nx">f</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">map</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这奇怪的参数是有顺序的，同样的，其类似于<code>Array.prototype.forEach()</code>。</p>

<ul>
<li><code>map.keys()</code> 返回map的所有key的一个迭代器。</li>
<li><code>map.values()</code> 返回map的所有值的一个迭代器。</li>
<li><code>map.entries()</code> 返回map的所有实体的一个迭代器，就像<code>map[Symbol.iterator]()</code>。实际 上，这只是另一个名称而已。</li>
</ul>


<p>那么有哪些不满意的呢？下面有些ES6没有的特性，但我觉得有用的：</p>

<ul>
<li><p>默认值的工厂，如 Python 中的 <a href="https://docs.python.org/3/library/collections.html#defaultdict-examples">collections.defaultdict</a>。</p></li>
<li><p><code>Map.fromObject(obj)</code>一个帮助的方法，可以将一个对象方便地写到map中，这样可以使用object-literal的方法。</p></li>
</ul>


<p>好了。回到文章开始谈到的我们所关心的点，在浏览器中运行是怎么影响到这些JS特性的设计？这是我们开始所提到的。我有三个例子，这里讨论前两个。</p>

<h4>JS是特殊的，部分一：哈希表没有哈希码？</h4>

<p>这是一个有用的特性，然而ES6集合类并没有支持，至少目前我可以这么说。</p>

<p>比如，我们这里有 URL 对象的Set。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">urls</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">;</span>
</span><span class='line'><span class="nx">urls</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="k">new</span> <span class="nx">URL</span><span class="p">(</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">));</span> <span class="c1">// two URL objects.</span>
</span><span class='line'><span class="nx">urls</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="k">new</span> <span class="nx">URL</span><span class="p">(</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">));</span> <span class="c1">// are the the same?</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">urls</span><span class="p">.</span><span class="nx">size</span><span class="p">);</span> <span class="c1">//2</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两个URL对象应该被认为是相等的，它们拥有相同的字段。但是，在JS中，这里的两个对象是不同的，这里也没有方法重写JS语言的相等比较方法。</p>

<p>其它语言则支持重写，在Java、Python、Ruby中，独立的类可以重写相等比较方法。在许多的实现机制中，独立的哈希表可以创建并使用不同的相等比较方法，C++就支持。</p>

<p>但是，这些所有的处理机制都是要求用户自己去实现哈希函数，和所有的暴露在外面的默认的哈希函数。委员会的选择是不暴露JS的哈希码，至少现在还没有。因为现在考虑的是数据的操作和安全，关注的而不是优于其它语言。</p>

<h4>JS是特殊的，部分二：惊奇又可预测</h4>

<p>你可能会认为从计算机出现的确定性的特为没有什么可以令人惊奇的，但是当我告知他们，Map和 Set 在迭代时会按照它们的插入顺序来访问实体，他们都觉得很惊奇，而且这特性是确定的。</p>

<p>我们习惯于哈希表是不确定的，我们学习并接受了这点。但是，我们有理由来避免这一点，就如我在2012年写道的：</p>

<ul>
<li><p>首先，有很多证据证明一些编程人员对不确定的迭代顺序感到怪异或者困惑。<a href="http://stackoverflow.com/questions/2453624/unsort-hashtable">1</a> <a href="http://stackoverflow.com/questions/1872329/storing-python-dictionary-entries-in-the-order-they-are-pushed">2</a> <a href="https://groups.google.com/group/comp.lang.python/browse_thread/thread/15f3b4a5cd6221b1/1b6621daf5d78d73">3</a> <a href="http://bytes.com/topic/c-sharp/answers/439203-hashtable-items-order">4</a> <a href="http://stackoverflow.com/questions/1419708/how-to-keep-the-order-of-elements-in-hashtable">5</a> <a href="http://stackoverflow.com/questions/7105540/hashtable-values-reordered">6</a></p></li>
<li><p>ECMAScript并没有对枚举的属性进行详细的说明，同时为了网络上的兼容性，所有主流的实现是强制为插入的顺序。但是，某些比如TC39并没有明确迭代的顺序，“对我们来说，网络会逐渐具体的”<a href="https://mail.mozilla.org/pipermail/es-discuss/2012-February/020576.html">7</a></p></li>
<li><p>哈希表的迭代顺序会暴露些对象哈希码，这会导致哈希实现函数的部分怪异的安全问题。比如，当一个对象暴露其哈希码时，其寻址方式必须是不可恢复的。(当展示对象的地址是由非信任的ECMAScript代码操作的，而不是ECMAScript主动操作的，这会是一个坏坏的安全Bug。)</p></li>
</ul>


<p>所有的这些在2012年二月已经被讨论过了，我当时是赞成迭代器可以任意顺序。然后，我根据经验展示了根据插入顺序进行排序的哈希表是有多慢，我用C++做了测试，结果令人惊讶&#8211;<a href="https://wiki.mozilla.org/User:Jorend/Deterministic_hash_tables">文章</a>。</p>

<p>所以，我们在JS中结束以插入顺序排序的哈希表。</p>

<h4>使用弱集合是有决定性原因的</h4>

<p>上周，我们讨论了例子涉及到JS的动画库，我们希望在每个DOM元素中存储一个布尔的标志，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">isMoving</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">smoothAnimations</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">element</span><span class="p">.</span><span class="nx">isMoving</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>不幸的是，为DOM元素设置一个可读写的属性是个不好主意，在之前的文章已经讨论过了。</p>

<p>那文章展示了怎么使用标志符来解决这一问题，但是，我们难道不能使用Set来做同样的事情吗？它看起来会如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">movingSet</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">element</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">smoothAnimations</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">movingSet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样只有一个缺点：Map 和 Set 对象会在它们中的每个key和value中建立强关联。这意味着，如果文档中的一个DOM元素被移除时，垃圾回收器并不能回收内存，而是需要<code>movingset</code>被移除才行。典型的类库包括复杂的功能，在最好的情况下，它会进行根据用户需求进行复杂的clean-up-after-yourself，但，这可能会导致内存的泄露。</p>

<p>ES6提供了一惊奇的方法来解决它。将<code>movingSet</code>作为<code>WeakSet，而不是</code>Set`，内存泄露的问题就公被解决。</p>

<p>对于这特殊的问题，可以使用一个弱的集合或者标志符来解决。但是，哪个会更好呢？所有的讨论都是个权衡的过程，很不幸，在这文章说的话会有些长。如果你可以在整个网页的生命周期中使用简单的标志符，那可能是好的。如果你只想结束些生命周期短的标志符，会有个危险的地方，这时，考虑使用 WeakMap 可能避免内存泄露。</p>

<h4>WeakMap 和 WeakSet</h4>

<p>WeakMap 和 WeakSet 具体操作实际上类似于 Map 和 Set，但有些限制：</p>

<ul>
<li>WeakMap 仅支持 <code>new</code>、<code>.has()</code>、<code>get()</code>、<code>.set()</code>和<code>.delete()</code>。</li>
<li>WeakSet 公支持 <code>new</code>、<code>.has()</code>、<code>add()</code>和<code>.delete()</code>。</li>
<li>存在在 WeakSet 中的值和 WeakMap 中的关键字必须是对象。</li>
</ul>


<p>这些限制性的条件可以保证垃圾回收器正常地回收 弱集合 中的超期的死亡对象。这类似于你可以获取弱关联或者弱key的字典，但ES6的弱集合的内存管理并不是这样子，而是决定于GC的脚本。</p>

<h4>JS是特殊的，部分三：隐藏GC操作是不确定性的</h4>

<p>在上面的场景中，这些弱的集合的实现方式类似于<a href="http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak/jucs_14_21_3481_3497_barros.pdf">蜉蝣表ephemeron tables</a>。</p>

<p>简单来说，一个WeakSet不会对其包含的对象保持着链接。当一个WeakSet中的对象被回收时，就会被简单从WeakSet中移除。WeakMap也类似这样子。它不会与其任意的关键字key建立强链接，只要key是活动的，这关联就是可用的。</p>

<p>为什么要接受这些限制？为什么不为JS增加一个弱链接？</p>

<p>再次，标准委员会还非常不情愿将不确定的行为暴露给外部脚本，较低的跨浏览器兼容性是网站开发的毒药。弱链接会暴露垃圾回收器底层的实现细节，也就是，特定平台的可确定的任意行为。应用不应该依赖于特定平台的细节，同时，弱链接也很难让你知道，你当前的在浏览器中的测试是怎么依赖于GC行为操作的。它们是很难推断的。</p>

<p>相反，ES6的弱集合有一堆受限的特性，并且这些特性是确定的。实际上，当一个Key或者value被回收是不会受到监视的，所以一个应用是否结束并不依赖于它，即使是出现事故。</p>

<p>这也是为了网站开发，从而致使的一个令人惊奇的设计决定，它可以让JS成为更好的语言。</p>

<h4>什么时候可以使用集合</h4>

<p>现在，所有的集合类都在 Firefox、Chrome、Microsoft Edge、Safari 得到支持，为了在旧的浏览器中使用，可以使用工具，如 <a href="https://github.com/WebReflection/es6-collections">es6-collections</a>。</p>

<p>WeakMap 在Firefox中刚开始是由Andreas Gal实现的，他后台做了Mozilla的CTO。Tom Schuster实现了WeakSet，我实现了 Map 和 Set。感谢 Tooru Fujisawa 对这些地方提供也补丁包。</p>

<p>下周，深入ES6系列文章会中断两周，可以戏称为暑假吧。这系列文章已经包含了ES6的很多特性，但是一些更为强大的特性即将要到来。所以，请在7月9号我们归来时，加入我们吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 In Depth: Using ES6 today with Babel and Broccoli]]></title>
    <link href="http://shatle.github.io/blog/2015/12/16/es6-in-depth-using-es6-today-with-babel-and-broccoli/"/>
    <updated>2015-12-16T21:23:09+08:00</updated>
    <id>http://shatle.github.io/blog/2015/12/16/es6-in-depth-using-es6-today-with-babel-and-broccoli</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/06/es6-in-depth-babel-and-broccoli/">ES6 In Depth: Using ES6 today with Babel and Broccoli</a></p></blockquote>

<p>ES6已经存在了，还有些人已经开始谈论 ES7了。新的标准中有哪些特性会被保留，又有哪些闪亮的特性提供？作为一位网络开发人员，我们会对怎么使用它产生疑问。不仅一次，在之前的 <a href="http://shatle.github.io/blog/categories/shen-ru-es6/">深入ES6系列</a>  中，我们一直在鼓励你们开始使用 ES6 来编码，通过用些有意思的工具来实现，我们之前已经有提到这方法：</p>

<blockquote><p>If you’d like to use this new syntax on the Web, you can use <a href="https://babeljs.io/">Babel</a> or <a href="https://github.com/google/traceur-compiler">Google’s Traceur</a> to translate your ES6 code to web-friendly ES5.</p></blockquote>

<p>今天，我们将一步步地向你展示它是怎么做的。之前提到的工具都称为是 <em>transpilers(transcompiler暂译为 转换编译器)</em>。转换编译器是为人熟知的 资源到资源的编译器，这编译器在不同的编程语言之间进行抽象层面中的转换。转换编译器可以让我们编写ES6的代码，同时也保证代码能够在每个浏览器中运行。</p>

<h4>转换编译器是我们的救赎</h4>

<p>转换编译器十分易用，你可以按以下描述进行，只要两步：</p>

<ol>
<li>我们用ES6语法编写代码</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">q</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">myVariable</span> <span class="o">=</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">q</span><span class="p">}</span> <span class="nx">bottles</span> <span class="nx">of</span> <span class="nx">beer</span> <span class="nx">on</span> <span class="nx">the</span> <span class="nx">wall</span><span class="p">,</span> <span class="nx">$</span><span class="p">{</span><span class="nx">q</span><span class="p">}</span> <span class="nx">bottles</span> <span class="nx">of</span> <span class="nx">beer</span><span class="p">.</span><span class="err">`</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>我们使用上面的代码作为转换编译器的输入，它会处理这代码，并产出下面的代码：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">myVariable</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="o">+</span> <span class="nx">q</span> <span class="o">+</span> <span class="s2">&quot; bottles of beer on the wall, &quot;</span> <span class="o">+</span> <span class="nx">q</span> <span class="o">+</span> <span class="s2">&quot; bottles of beer.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们知道这是旧JS的写法，它能运行于任意的浏览器。</p>

<p>转换编译器内部是怎么从输入到产生，这是是复杂的过程，也超出了这文章的范围。让我们就像开车，而不要去管其所有的内部机械引擎。今天，我们把转换编译器看作是一个黑盒子，来处理我们的代码。</p>

<h4>Babel的作用</h4>

<p>在项目中使用Bable有不几种不同的方法，首先是命令行工具，你可以通过下面的命令来实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">babel</span> <span class="nx">script</span><span class="p">.</span><span class="nx">js</span> <span class="o">--</span><span class="nx">out</span><span class="o">-</span><span class="nx">file</span> <span class="nx">script</span><span class="o">-</span><span class="nx">compiled</span><span class="p">.</span><span class="nx">js</span>
</span></code></pre></td></tr></table></div></figure>


<p>在浏览器中预置Babel的版本也是可用的，你可以将Babel作为常规的js库文件，然后你可以将ES6的代码中的script标签中的类型修改为&#8221;text/babel&#8221;。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="err">\</span><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&quot;node_modules/babel-core/browser.js&quot;</span><span class="o">&gt;&lt;</span><span class="err">/script&gt;</span>
</span><span class='line'><span class="err">\</span><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&quot;text/babel&quot;</span><span class="o">&gt;</span>
</span><span class='line'><span class="c1">// Your ES6 code</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，这方法不能扩展：你的代码增长时，你会将代码分离成多个文件和目录，这方法是不允许的。这时，你需要一个构建工具，通过管道式来整合Babel。</p>

<p>在下面的部分，我们将Babel整合到一个构建工具中，<a href="http://broccolijs.com/">Broccoli.js</a>，接着我们将通过几个例子来编写并执行我们的ES6代码。当你运行出现错误时，你可以在这里回头查看完整的资源代码：<a href="https://github.com/givanse/broccoli-babel-examples">broccoli-babel-examples</a>。在这资源库中，你将找到三个例子项目：</p>

<ol>
<li>es6-fruits</li>
<li>es6-website</li>
<li>es6-modules</li>
</ol>


<p>每个会建立在之前的例子之上(没发现)。我们开始会代码最小化，并且会是个一般的解决方案，它可以胜任于为个伟大的项目打关阵。在这文章中，我们将详细地讨论前两个例子。在我们做完之后，你自己可以去阅读、去理解第三个例子中的代码。</p>

<p>如果你认为，你可以等待浏览器支持这些特性，你将会被甩到后面。完全的浏览器支持，如果这会实现，那它将是个漫长的过程。转换编译器已经在这里，新的ECMAScript标准也将计划在年内发布。所以 ，我们将继续、经常地看到新的标准发布出来，而这会先于统一的浏览器平台。跳起来吧，利用这些新的ES6特性吧。</p>

<h4>我们的第一个Broccoli 和 Babel项目</h4>

<p>Broccoli是个被设计为尽量快的速度来构建项目的工具。你可以压缩和最小化文件，通过这些<a href="https://www.npmjs.com/browse/keyword/broccoli-plugin">插件</a>  操作的使用，还有其它很多其它的功能。它帮助我们负担了一大堆的事情，包括处理文件、目录，还有当我们每次修改项目时需要执行的命令。可以把它当成为：</p>

<blockquote><p>在一定范围上，它类似 Rails 的资源文件的管理，只是它运行于Node，也没有纯粹的后端。</p></blockquote>

<h5>开始项目</h5>

<p><strong>Node</strong></p>

<p>正如你猜测一样，你将不得不<a href="https://nodejs.org/">安装 Node</a> 0.11 或者更高版本。</p>

<p>如果你是在unix系统，避免使用包管理工具，如apt, yum。这样可以避免在安装过程中使用root权限。最好的方法是，从刚才提供的链接地址中，使用你当前的用户手动下载二进制文件。你可以在<a href="http://givan.se/do-not-sudo-npm/">这里</a> 看到为什么不建议使用 root 权限。你也可以在<a href="http://givan.se/do-not-sudo-npm/#install-npm-properly">这里</a> 选择其它的安装方式。</p>

<p><strong>Broccoli</strong></p>

<p>我们首先将建立我们的Broccoli的项目：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>mkdir es6-fruits
</span><span class='line'><span class="nb">cd </span>es6-fruits
</span><span class='line'>npm init
</span><span class='line'><span class="c"># Create an empty file called Brocfile.js</span>
</span><span class='line'>touch Brocfile.js
</span></code></pre></td></tr></table></div></figure>


<p>现在，我们安装 broccoli 和 broccoli-cli</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># the broccoli library</span>
</span><span class='line'>npm install --save-dev broccoli
</span><span class='line'><span class="c"># command line tool</span>
</span><span class='line'>npm install -g broccoli-cli
</span></code></pre></td></tr></table></div></figure>


<h5>编写些ES6代码</h5>

<p>我们创建 src 目录，接着在里面编辑文件 fruits.js：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>mkdir src
</span><span class='line'>vim src/fruits.js
</span></code></pre></td></tr></table></div></figure>


<p>在我们的新文件中，我们使用 ES6 的语法编写些小的脚本：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">let</span> <span class="nx">fruites</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>  <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;strawberry&#39;</span><span class="p">},</span>
</span><span class='line'>  <span class="p">{</span><span class="nx">id</span><span class="o">:</span> <span class="mi">101</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;grapefruit&#39;</span><span class="p">},</span>
</span><span class='line'>  <span class="p">{</span><span class="nx">id</span><span class="p">;</span><span class="mi">102</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;plum&#39;</span><span class="p">}</span>
</span><span class='line'><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">fruit</span> <span class="nx">fo</span> <span class="nx">fruits</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="err">`</span><span class="nx">ID</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">fruit</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span> <span class="nx">Name</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">fruit</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="err">`</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">lgo</span><span class="p">(</span><span class="err">`</span><span class="nx">List</span> <span class="nx">total</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">fruits</span><span class="p">.</span><span class="nx">length</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码使用到了 ES6 的三个特性：</p>

<ol>
<li><code>let</code>，用于本作用域内的声明(在之前的文章中已经有讨论过)</li>
<li>for-of 循环</li>
<li>模板字符串</li>
</ol>


<p>保存文件，并试着执行它。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>node src/fruits.js
</span></code></pre></td></tr></table></div></figure>


<p>它还不能运行，但我们希望它可以在Node和任意的浏览器中都能够执行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">fruits</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>     <span class="o">^^^^^</span>
</span><span class='line'><span class="nx">SyntaxError</span><span class="o">:</span> <span class="nx">Unexpected</span> <span class="nx">identifier</span>
</span></code></pre></td></tr></table></div></figure>


<h5>到转换代码的时间了</h5>

<p>现在，我们将使用 Broccoli 来加载我们的代码，并通过Babel来处理。我们将编辑文件 Brocfile.js 并添加以下的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// import the babel plugin</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">babel</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;broccoli-babel-transpiler&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// grab the source and transpile it in 1 step</span>
</span><span class='line'><span class="nx">fruits</span> <span class="o">=</span> <span class="nx">babel</span><span class="p">(</span><span class="nx">src</span><span class="err">&#39;</span><span class="p">);</span> <span class="c1">// src/*.js</span>
</span><span class='line'>
</span><span class='line'><span class="nx">module</span><span class="p">.</span><span class="kr">export</span> <span class="o">=</span> <span class="nx">fruits</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意到，我们加载了 <code>broccoli-babel-transpiler</code>，这是个 Broccoli 的插件，它包括了 Babel 的库，所以我们必须安装它：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>npm install --save-dev broccolli-babel-transpiler
</span></code></pre></td></tr></table></div></figure>


<p>现在我们可以构建我们的项目，并通过下面代码来执行脚本：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>broccoli build dist <span class="c"># compile</span>
</span><span class='line'>node dist/fruits.js <span class="c"># execute ES5</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个输出会看到：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ID: <span class="m">100</span> Name: strawberry
</span><span class='line'>ID: <span class="m">101</span> Name: grapefruit
</span><span class='line'>ID: <span class="m">102</span> Name: plum
</span><span class='line'>List total: 3
</span></code></pre></td></tr></table></div></figure>


<p>这十分的简单！你可以打开 <code>dist/fruits.js</code>来看看，转换后的代码文件是什么样子。Babel转换编译器的其中一个好的特性就是可产生良好可读性的代码。</p>

<h4>为网站编写ES6代码</h4>

<p>在第二个例子中，我们将提升个等级。首先，退出 es6-fruits 目录，并参照之前的【项目开始】的步骤来创建一个新的目录 <code>es6-website</code>。</p>

<p>在 src 的目录中，我们创建三个文件：</p>

<p><code>src/index.html</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="cp">&lt;!DOCTYPE html&gt;</span>
</span><span class='line'><span class="nt">&lt;html&gt;</span>
</span><span class='line'>    <span class="nt">&lt;head&gt;</span>
</span><span class='line'>      <span class="nt">&lt;title&gt;</span>ES6 Today<span class="nt">&lt;/title&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/head&gt;</span>
</span><span class='line'>    <span class="nt">&lt;style&gt;</span>
</span><span class='line'>      <span class="nt">body</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">border</span><span class="o">:</span> <span class="m">2px</span> <span class="k">solid</span> <span class="m">#9a9a9a</span><span class="p">;</span>
</span><span class='line'>        <span class="k">border</span><span class="o">-</span><span class="n">radius</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
</span><span class='line'>        <span class="k">padding</span><span class="o">:</span> <span class="m">6px</span><span class="p">;</span>
</span><span class='line'>        <span class="k">font-family</span><span class="o">:</span> <span class="k">monospace</span><span class="p">;</span>
</span><span class='line'>        <span class="k">text-align</span><span class="o">:</span> <span class="k">center</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="nc">.color</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">padding</span><span class="o">:</span> <span class="m">1</span><span class="n">rem</span><span class="p">;</span>
</span><span class='line'>        <span class="k">color</span><span class="o">:</span> <span class="m">#fff</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="nt">&lt;/style&gt;</span>
</span><span class='line'>    <span class="nt">&lt;body&gt;</span>
</span><span class='line'>      <span class="nt">&lt;h1&gt;</span>ES6 Today<span class="nt">&lt;/h1&gt;</span>
</span><span class='line'>      <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;info&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
</span><span class='line'>      <span class="nt">&lt;hr&gt;</span>
</span><span class='line'>      <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;content&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
</span><span class='line'>
</span><span class='line'>      <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;//code.jquery.com/jquery-2.1.4.min.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'>      <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;js/my-app.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/body&gt;</span>
</span><span class='line'><span class="nt">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>src/print-info.js</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">printInfo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#info&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;&lt;p&gt;minimal website example with&#39;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s1">&#39;Broccoli and Babel&lt;/p&gt;&#39;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="nx">printInfo</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>src/print-colors.js</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// ES6 Generator</span>
</span><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">hexRange</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">,</span> <span class="nx">step</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">stop</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">step</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">yield</span> <span class="nx">i</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">printColors</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">content$</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#content&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// contrived example</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">hex</span> <span class="nx">of</span> <span class="nx">hexRange</span><span class="p">(</span><span class="mi">900</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">newDiv</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;div&gt;&#39;</span><span class="p">)</span>
</span><span class='line'>          <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">)</span>
</span><span class='line'>          <span class="p">.</span><span class="nx">css</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="err">`#</span><span class="nx">$</span><span class="p">{</span><span class="nx">hex</span><span class="p">}</span><span class="err">`</span> <span class="p">})</span>
</span><span class='line'>          <span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="err">`</span><span class="nx">hex</span> <span class="nx">code</span><span class="o">:</span> <span class="err">#</span><span class="nx">$</span><span class="p">{</span><span class="nx">hex</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">content$</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">newDiv</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="nx">printColors</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>你应该注意到这一点：<code>function* hexRange</code>。是的，这是 ES6 的生成器。这一个特性并没有在所有的浏览器得到支持。为了能够使用它(生成器)，我们需要个工具。Babel 可以提供，我们也很快地使用到它。</p>

<p>下一步是合并所有的JS文件，并在网站中使用它。这最难的部分是编写我们的Brocfile 文件。这时，我们安装四个插件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>npm install --save-dev broccoli-babel-transpiler
</span><span class='line'>npm install --save-dev broccoli-funnel
</span><span class='line'>npm install --save-dev broccoli-concat
</span><span class='line'>npm install --save-dev broccoli-merge-trees
</span></code></pre></td></tr></table></div></figure>


<p>然后，使用它们 ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Babel transpiler</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">babel</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;broccoli-babel-transpiler&#39;</span><span class="p">);</span>
</span><span class='line'><span class="c1">// filter trees (subsets of files)</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">funnel</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;broccoli-funnel&#39;</span><span class="p">);</span>
</span><span class='line'><span class="c1">// concatenate trees</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">concat</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;broccoli-concat&#39;</span><span class="p">);</span>
</span><span class='line'><span class="c1">// merge trees</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">mergeTrees</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;broccoli-merge-trees&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// Transpile the source files</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">appJs</span> <span class="o">=</span> <span class="nx">babel</span><span class="p">(</span><span class="s1">&#39;src&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// Grab the polyfill file provided by the Babel library</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">babelPath</span> <span class="o">=</span> <span class="nx">require</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;broccoli-babel-transpiler&#39;</span><span class="p">);</span>
</span><span class='line'><span class="nx">babelPath</span> <span class="o">=</span> <span class="nx">babelPath</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\/index.js$/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
</span><span class='line'><span class="nx">babelPath</span> <span class="o">+=</span> <span class="s1">&#39;/node_modules/babel-core&#39;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">browserPolyfill</span> <span class="o">=</span> <span class="nx">funnel</span><span class="p">(</span><span class="nx">babelPath</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">files</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;browser-polyfill.js&#39;</span><span class="p">]</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Add the Babel polyfill to the tree of transpiled files</span>
</span><span class='line'><span class="nx">appJs</span> <span class="o">=</span> <span class="nx">mergeTrees</span><span class="p">([</span><span class="nx">browserPolyfill</span><span class="p">,</span> <span class="nx">appJs</span><span class="p">]);</span>
</span><span class='line'><span class="c1">// Concatenate all the JS files into a single file</span>
</span><span class='line'><span class="nx">appJs</span> <span class="o">=</span> <span class="nx">concat</span><span class="p">(</span><span class="nx">appJs</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// we specify a concatenation order</span>
</span><span class='line'>  <span class="nx">inputFiles</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;browser-polyfill.js&#39;</span><span class="p">,</span> <span class="s1">&#39;**/*.js&#39;</span><span class="p">],</span>
</span><span class='line'>  <span class="nx">outputFile</span><span class="o">:</span> <span class="s1">&#39;/js/my-app.js&#39;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Grab the index file</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">funnel</span><span class="p">(</span><span class="s1">&#39;src&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">files</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;index.html&#39;</span><span class="p">]});</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// Grab all our trees and</span>
</span><span class='line'><span class="c1">// export them as a single and final tree</span>
</span><span class='line'><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">mergeTrees</span><span class="p">([</span><span class="nx">index</span><span class="p">,</span> <span class="nx">appJs</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>是时候构建并执行我们的代码了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>broccoli build dist
</span></code></pre></td></tr></table></div></figure>


<p>这里，你应该在dist目录中看到如下的结构：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$&gt;</span> tree dist/
</span><span class='line'>dist/
</span><span class='line'><span class="p">|</span>--index.html
</span><span class='line'><span class="p">|</span>--js
</span><span class='line'><span class="p">|</span>--<span class="p">|</span>-- my-app.js
</span></code></pre></td></tr></table></div></figure>


<p>这是个静态的网站，你可以部署到任意的服务器中，检查这代码是可行的。例如，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd </span>dist/
</span><span class='line'>python -m SimpleHTTPServer
</span><span class='line'><span class="c"># visit http://localhost:8000/</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以看到：</p>

<p><img src="https://raw.githubusercontent.com/givanse/broccoli-babel-examples/master/es6-website/screenshot.png" alt="es6 today" /></p>

<h4>更多乐趣在 Babel 和 Broccoli 中</h4>

<p>上面的第二个例子提供我们一方法来怎么使用Babel，从而完成项目。它应该可以让你理解一些时间了，如果你通过Babel、Broccoli更多地使用ES6，你可以查看一下这个项目：<a href="https://github.com/jayphelps/broccoli-babel-boilerplate">broccoli-babel-boilerplate</a>。它也是用 Broccoli + Babel 开始的，它至少提高了两个点。这模板例子包括了 模块、引入、和单元测试。</p>

<p>你可以试试这里的配置例子：<a href="https://github.com/givanse/broccoli-babel-examples/tree/master/es6-modules">es6-modules</a>，Brocfile 有很多魔法的地方，其类似与我们上面做的事件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 in Depth: Symbols]]></title>
    <link href="http://shatle.github.io/blog/2015/12/10/es6-in-depth-symbols/"/>
    <updated>2015-12-10T23:07:02+08:00</updated>
    <id>http://shatle.github.io/blog/2015/12/10/es6-in-depth-symbols</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/">ES6 in Depth: Symbols</a></p></blockquote>

<p><em>ES6 in Depth 是介绍 ES6(ECMAScript 标准的第6版本缩写) 的 JS 新特性的一系列文章。</em></p>

<p><em>备注：这文章是由 Coupofy team 的 JuliaDuong 编写，有<a href="https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/">越南语版本</a>。</em></p>

<p>什么是 ES6 的 symbols?</p>

<p>Symbols 并不是 Logos。</p>

<p>在你的代码中，你或许想到你可以使用些不小的图片：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let 😻 = 😺 × 😍; // SyntaxError</span></code></pre></td></tr></table></div></figure>


<p>此处省略&#8230;</p>

<p>那么，什么是 Symbol呢？</p>

<h4>第七种类型</h4>

<p>自1997年的JS第一次标准化以来，它就包含有六种类型。直到 ES6，JS编程中的每个值都会在这些类别中。</p>

<ul>
<li>Undefined 未定义</li>
<li>Null 空</li>
<li>Boolean 布尔</li>
<li>Number 数值</li>
<li>String 字符串</li>
<li>Object  对象</li>
</ul>


<p>每个类型是其值的一个集合，前5个集合是有限的。其中，只有两个布尔值， true 和 false ，他们并没有增加新的布尔值。值 更多的有 数值 和 字符串。准确来说，有 18,437,736,874,454,810,627 不同的数值(包括 NaN，这数值的名称来自&#8221;Not a Number&#8221;的缩写)。相比字符串可能存在的数量, 我认为有 (2144,115,188,075,855,872 − 1) ÷ 65,535 &#8211; 尽管我有可能算错。</p>

<p>但是，对象值的集合是打开的。每个对象是唯一的，如珍贵的雪花。当你每次打开网页时，一堆的对象就会被创建。</p>

<p>ES6 symbols 也是值，但他们不是字符串，他们不是对象，他们是新的：第七种类型值。</p>

<p>让我们对随后来到的 ES6 symbol 的布置些场景。</p>

<h4>一个简单、小的布尔</h4>

<p>有时，它可以在JS对象中十分方便地存储一些临时的但实际属于其它的数据。</p>

<p>例如，你可以写一个JS库，用CSS的翻转(transitions)来让DOM元素在屏幕中收缩。你也注意到，当试图对一个<code>div</code>元素添加多个翻转时那是没有效果的。这显得很难受，时不时的”跳动“。你认为你可以修复这问题，但首先你需要找到一方法来判断这给定的元素是否已经移动了。</p>

<p>你怎么才能解决这问题？</p>

<p>一个方法是使用CSS的APIs 通过浏览器去查询这元素是否正在移动，但是这听起来很大刀。你的库应该已经知道这元素是正在移动的，那就是在你设置其移动的代码的第一个位置！</p>

<p>你可能希望的方法是实时跟踪移动的元素，你可以将所有移动的元素保存到一个数组中。当你库每次被调用来对一元素进行动画时，你可以查询一遍这个元素是否已经在数组中。</p>

<p>Hmm。如果这数组很大的话，这线性的检索是十分缓慢的。</p>

<p>你实际只是想做的是在元素的上面设置一个标识：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">isMoving</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">smoothAnimations</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">element</span><span class="p">.</span><span class="nx">isMoving</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这也有些潜在的问题，它们实际上有： 不仅仅是你的代码控制这些DOM。</p>

<ul>
<li>其它代码使用 <code>for-in</code> 或者 <code>Object.keys()</code>会使得你创建的属性出现困扰；</li>
<li>某些其它明智库的作者可能已经考虑到了这一技术，然后这些已经存在的库会和你的库相互地作用，这是糟糕的。</li>
<li>某些其它明智库的作者将来可能会想到这技术，然后你的库将来会出现冲突；</li>
<li>标准委员会可能决定对所有的元素增加一个 <code>.isMoving()</code>方法，然后你真的湿身了；</li>
</ul>


<p>好吧，你可以通过选择一个冗长而又笨拙的别人不用此来命名的字符串来解决后三个问题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">smoothAnimations</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">element</span><span class="p">.</span><span class="nx">__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>但这样子很费眼。</p>

<p>你实际上可以通过密码学的方法生成一个唯一的字符串来命名这属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// get 1024 Unicode characters of gibberish</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">isMoving</span> <span class="o">=</span> <span class="nx">SecureRandom</span><span class="p">.</span><span class="nx">generateName</span><span class="p">();</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">[</span><span class="nx">isMoving</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">smoothAnimations</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">element</span><span class="p">[</span><span class="nx">isMoving</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>object[name]</code>语法可以让你使用任意字符串来标识这个属性的名称，所以这代码是可用的：冲突几乎不可能出现，你的代码看起来很好。</p>

<p>但这将导致一个调试不好的体验，当你每次用<code>console.log()</code>来输出一个元素的这属性时，你将会看到大量的字符串堆在垃圾桶里。然后，如果你需要不仅仅是一个类似的属性时，那怎么办？你怎么保证它们是正常的？他们会在你每次重载时拥有不同的名称。</p>

<p>为什么会如此的艰难？我们只需要一个小小的布尔值而已！</p>

<h4>Symbol(标志符) 是答案</h4>

<p>程序可以创建标志符，来作为属性的关键字，而不会引起命名冲突：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">mySymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用<code>Symbol()</code>可创建一个新的标志符，其值不会与其它任何值相等。</p>

<p>就像一个字符串或者数值，你可以使用标志符来作为属性的key，因为它不会与其它的值相等，所以使用标志符作为属性的key不会与其它属性有冲突。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">obj</span><span class="p">[</span><span class="nx">mySymbol</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;ok!&quot;</span><span class="p">;</span> <span class="c1">// guaranteed not to collide</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">mySymbol</span><span class="p">]);</span> <span class="c1">// ok!</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，你可以用标志符来解决之前的问题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// create a unique symbol</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">isMoving</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&quot;isMoving&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">[</span><span class="nx">isMoving</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">smoothAnimations</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">element</span><span class="p">[</span><span class="nx">isMoving</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这代码有些要注意的点：</p>

<ul>
<li><p>在<code>Symbol("isMoving")</code>中的字符串&#8221;isMoving&#8221;表示为一个描述信息，这可用于调试。</p></li>
<li><p><code>element[isMoving]</code>称为一个 symbol-keyed 属性，它是一个用标志符而不是字符串来命名的属性。除此之外，它是一个正常的属性(没什么区别)。</p></li>
<li><p>类似数组，symbol-keyed 属性不能通过 点的语法<code>obj.name</code>来访问，必须使用中括号来访问。</p></li>
<li><p>如果你熟悉了标志符，你可以直接地使用 symbol-keyed 属性。之前的例子中已经展示怎么获取和设置<code>element[isMoving]</code>，如果我们需要，我们还可以使用 <code>if (isMoving in element)</code>或者甚至是<code>delete element[isMoving]</code>。</p></li>
<li><p>另外，只要<code>isMoving</code>在作用域中以上的操作都是可行的，这使得标志符拥有个弱封装的机制：一个模块内创建一些标志符，则可用于其所有的对象中，不用担心其他代码的属性创建而引起冲突。</p></li>
</ul>


<p>因为标志符在设计时就是要避免冲突的，JS多数对象注入的特性忽略标志符的key的。例如，一个<code>for-in</code>的循环，只有循环会对对象的非字符串key起作用。标志符的key是被跳过的，<code>Object.key(obj)</code>和<code>ObjectgetOwnPropertyNames(obj)</code>也是一样的。但是，标志符实际上并不是私有的：它可以使用新的API <code>Object.getOwnPropertySymbos(obj)</code>来列出一个对象的所以标志符的key。另外新的API，<code>Reflect.ownKeys(obj)</code>，返回包括字符串和标志符的keys。(我们将会在即将到来的文章中全方位地讨论Reflect API。)</p>

<p>库和框架将会挖掘出许多的标志符的用法，然后，我们将会看到JS把标志符应用于更大的范围和目标中。</p>

<h4>但是，标志符实际上是什么</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&gt;</span> <span class="k">typeof</span> <span class="nx">Symbol</span><span class="p">()</span>
</span><span class='line'><span class="s2">&quot;symbol&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>标志符并不同其它东西。</p>

<p>它们在创建后就是不可变的。你不能为它们设置属性(如果你在严格模式中，你将会得到一个TypeError)。它们可以当作属性的名称，效果类似于字符串的key。</p>

<p>另外，每个标志符是唯一的，区别于其它标志符(即使其它的标志符拥有相同的描述信息)，你可以轻松地创建新的标志符，这类似于对象。</p>

<p>ES6的标志符类似于其它语言的<a href="https://en.wikipedia.org/wiki/Symbol_%28programming%29">更为传统标志符</a> ，如Lisp和Ruby，但是并非完全接近这些语言。在Lisp中，所有的身份标识都是标志符。在JS，身份标识和多数属性的key经过考虑之后，依然定为是字符串。标志符只是额外的选项。</p>

<p>标志符的有个注意的地方：并不像其它语言一般，JS中的标志符不能自动转为字符串。试图将一个标志符和字符串拼接时，将得到得到 TypeError。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&quot;&lt;3&quot;</span><span class="p">);</span>
</span><span class='line'><span class="o">&gt;</span> <span class="s2">&quot;your symbol is &quot;</span> <span class="o">+</span> <span class="nx">sym</span>
</span><span class='line'><span class="c1">// TypeError: can&#39;t convert symbol to string</span>
</span><span class='line'><span class="o">&gt;</span> <span class="err">`</span><span class="nx">your</span> <span class="nx">symbol</span> <span class="nx">is</span> <span class="nx">$</span><span class="p">{</span><span class="nx">sym</span><span class="p">}</span><span class="err">`</span>
</span><span class='line'><span class="c1">// TypeError: can&#39;t convert symbol to string</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以通过精确地将标志符转为字符串来避免这一问题，编写方式为<code>String(sym)</code>或者<code>sym.toString()</code>。</p>

<h4>三个标志符的点</h4>

<p>这里有三种方式来获取一个标志标志符。</p>

<ul>
<li><strong>调用 Symbol()</strong>。就如我们已经谈到的，它在调用会每次返回唯一的标志符。</li>
<li><p><strong>调用 Symbol.for(string) </strong>。这会访问已经存在于<em>标志符登记处(symbol registry)</em>的标志符。不像<code>Symbol()</code>会得到唯一的标志符，在标志符登记处中的标志符是可分享的。如果你调用<code>Symbol.for("cat")</code>三十次时，你在每次得到的是同一个标志符。当多个页面、或者多个模块位于同一页面时，这登记处就十分有用的，因为它们需要分享标志符。</p></li>
<li><p><strong>如<code>Symbol.iterator</code>来使用标志符定义标准</strong>。标准库中只定义了部分标志符，但每个都是有其目的的。</p></li>
</ul>


<p>如果你依然没有确定标志符是怎么有作用的，最后一项就有意义了，因为它展示了  标志符在应用中得到证明是有用的。</p>

<h4>ES6是怎么使用著名的标志符</h4>

<p>我们已经看到在 ES6 中使用标志符可以避免与现有的代码产生冲突。几周前，在 <a href="http://shatle.github.io/blog/2015/09/09/es6-in-depth-iterators-and-the-for-of-loop/">迭代器的文章</a> 中，我们看到循环<code>for (var item of myArray)</code>在开始时调用<code>myArray[Symbol.iterator]()</code>。我提到，这方法会在<code>myArray.iterator()</code>时调用到，因为标志符可以更好地向后兼容。</p>

<p>现在，我们知道了标志符的所有信息，很容易理解它是为什么和是什么。</p>

<p>这里还指出其它地方是怎么使用ES6著名的标志符的。(这些特性未在Firefox实现。)</p>

<ul>
<li><p><strong>扩展 instanceof</strong>。在ES6中，表达式<code>object</code>、<code>instanceof</code>、<code>constructor</code>在构造器(constructor)里面有一指定方法：<code>constructor[Symbol.hasInstance](object)</code>。这就是扩展。</p></li>
<li><p><strong>消除新特性与旧代码之间的冲突</strong>。这意思非常模糊，但是我们已经确定的是，ES6的Array方法在现有的网站就是不能运行的。其它网络标准也有类似的问题：简单地添加一个方法都会导致现有的网站崩溃。但是，这些问题主要是由于动态作用域导致的，所以，ES6推介使用特殊的标志符。</p></li>
<li><p><strong>支持新类型的string-matching</strong>。在ES5中，<code>str.match(myObject)</code>会试图将 myObject 转化为一个 RegExp。在ES6中，它会首先检查 myObject 是否有一个方法 myObject<a href="str">Symbol.match</a>。现在的库可以提供字符串转化的类，来支持RegExp对象能工作的地方也能正常运行。</p></li>
</ul>


<p>每个用法都有些限制，很难看到这些特性在我每天的代码中起作用，但是从长远来看是可行的。著名的标志符对PHP和Python中的<code>__doubleUnderscores</code>进行了升级。标准委员会在将来使用它们，来为JS添加新特性，而不会危险到你已经存在代码。</p>

<h4>什么时候使用 ES6 的标志符</h4>

<p>标志符已经在 Firefox36 和 Chrome38 实现了。我自己已经在 Firefox 实现了，所以当你如果将symbol当作是cymbal时，你应该知道应该问谁了。</p>

<p>为了在未原生支持ES6 标志符的浏览器中使用标志符，你可以使用工具，如 <a href="https://github.com/zloirock/core-js#ecmascript-6-symbols">core.js</a> 。因为标志符实际上并不像以前的语言中的一样，这工具并不十分完美。<a href="https://github.com/zloirock/core-js#caveats-when-using-symbol-polyfill">请查看忠告</a></p>

<p>下周，我们将有两篇新的文章。首先，我们将会谈到一些长期的特性，也是在ES6中出现的&#8211;但受到抱怨的。我们将会涉及到两个特性，它们甚至是可以追溯到编程的源头。我们将会继续两个类似的特性，但只是点到为止。所以，请在下周加入我们，让我们深入ES6的集合中。</p>

<p>另外，让人迷恋的由 Gaston Silva 编写的文章谈到的并不是ES6的特性，但是，它也许在你项目的使用ES6上有一定的推动作用。下次见。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 in Depth: Arrow funtions]]></title>
    <link href="http://shatle.github.io/blog/2015/12/02/es6-in-depth-arrow-funtions/"/>
    <updated>2015-12-02T23:48:51+08:00</updated>
    <id>http://shatle.github.io/blog/2015/12/02/es6-in-depth-arrow-funtions</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/">ES6 in Depth: Arrow funtions</a></p></blockquote>

<p>箭头是JS每个开始的一部分，JS的第一个指导说可以在 HTML 注释中内置脚本代码，这会导致浏览器错误地认为JS代码是文本，从而不能运行JS。你可能会编写代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="err">\</span><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">language</span><span class="o">=</span><span class="s2">&quot;javascript&quot;</span><span class="o">&gt;</span> <span class="c1">// \ for md safe</span>
</span><span class='line'>  <span class="c">&lt;!--</span>
</span><span class='line'>     <span class="nb">document</span><span class="p">.</span><span class="nx">bgColor</span> <span class="o">=</span> <span class="s2">&quot;brown&quot;</span><span class="p">;</span> <span class="c1">// red</span>
</span><span class='line'>  <span class="c1">// --&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>旧的浏览器只会看到两个不支持的标签和一个注释，只有新的浏览器会看到 JS 代码。</p>

<p>为了支持这奇怪的代码，你浏览器中的 JS 引擎会将 <code>&lt;!--</code> 认为是单行注释的开始。没有开玩笑，这至始至终是JS语言的一部分，而且至今仍然是可用的。这不仅仅可以在内置的 <code>&lt;script&gt;</code>的顶部，还可以在 JS 的任何地方，它甚至在 Node 也是能工作的。</p>

<p>由此，<a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-html-like-comments">ES6 的注释风格第一次的标准化</a>，但这并不是我们这里所谈到的箭头。</p>

<p>序列箭头<code>--&gt;</code>也表示一个单行的注释，奇怪的是，HTML认为在<code>--&gt;</code>之前的部分是注释，而JS认为<code>--&gt;</code>之后剩余部分是注释。</p>

<p>这确实很怪异。这箭头只有当其出现在行的开头时才会认为是注释。这是因为在其它的内容中，<code>--&gt;</code>是一个JS的操作符，“去到”操作符。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">countdown</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="nx">n</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// &quot;n goes to zero&quot;</span>
</span><span class='line'>     <span class="nx">alert</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">blastoff</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这代码确实可以运行<a href="http://codepen.io/anon/pen/oXZaBY?editors=001">链接</a>， 这个循环运行会从 n 到 0 。这也不是ES6的一个新特性，它其实是类似箭头的操作组合，这确实会有些误导。你能猜出指出是什么吗？和平常一样，这答案的迷云可以在 <a href="http://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator">Stack Overflow</a> 中得到。</p>

<p>好了，<code>&lt;=</code>表示小于等于操作符，你可以找出JS代码中更多的这些箭头。细想一下有哪些箭头，但是现在先暂停一下，观察一下一个不认识的箭头：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c">&lt;!--</span> <span class="nx">single</span><span class="o">-</span><span class="nx">line</span> <span class="nx">comment</span>
</span><span class='line'><span class="o">--&gt;</span> <span class="err">“</span><span class="nx">goes</span> <span class="nx">to</span><span class="err">”</span> <span class="nx">operator</span>
</span><span class='line'><span class="o">&lt;=</span>  <span class="nx">less</span> <span class="nx">than</span> <span class="nx">or</span> <span class="nx">equal</span> <span class="nx">to</span>
</span><span class='line'><span class="o">=&gt;</span>  <span class="o">???</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>=&gt;</code>会发现什么呢？今天，让我们研究一下。</p>

<p>首先，让我们稍微讨论一下 函数。</p>

<h4>无处不在的函数表达式</h4>

<p>JS中一个有趣的特性是可以在任何时候添加你所需要的函数，你只需要在运行代码的中部编写合适的函数。</p>

<p>例如，你可以试图告诉浏览器当用户点击具体的按钮时做什么，你会开始编写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s2">&quot;#confetti-btn&quot;</span><span class="p">).</span><span class="nx">click</span><span class="p">(</span>
</span></code></pre></td></tr></table></div></figure>


<p>jQuery 的 <code>.click()</code>方法需要一个参数：一个函数。没问题，你仅需要编写合适的函数，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s2">&quot;#confetti-btn&quot;</span><span class="p">).</span><span class="nx">click</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">playTrumpet</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">fireConfettiCannon</span><span class="p">();</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在的我们已经很自然地编写出这类似的代码了，细想一下，这写法在JS流行之前是显得奇怪的，很多的编程语言并不会有这一特性。在1958年，Lisp 有其函数表达式，它叫 lambda 函数。但是，C++、Python、C# 和 Java 没有函数也生存了很多年。</p>

<p>这情况不会再有了，这四种语言现在也有 lambda 函数。更新的语言普遍都会内置有 lambda 函数。我们 JS 也很感谢 &#8212;- 早期 JS 编程人员大胆地构建大量的 lambda 库，从而使得这特性广泛地被使用。</p>

<p>稍微有些伤心的是，在我提到过的所有编程语言中，JS的lambda语法证明是最为冗长的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// A very simple function in six languages.</span>
</span><span class='line'><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">){</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//JS</span>
</span><span class='line'><span class="p">[](</span><span class="kr">int</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// C++</span>
</span><span class='line'><span class="p">(</span><span class="nx">lambda</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">(</span><span class="o">&gt;</span> <span class="nx">a</span> <span class="mi">0</span><span class="p">))</span>  <span class="p">;;</span> <span class="nx">Lisp</span>
</span><span class='line'><span class="nx">lambda</span> <span class="nx">a</span><span class="o">:</span> <span class="nx">a</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="err">#</span> <span class="nx">Python</span>
</span><span class='line'><span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="c1">// C#</span>
</span><span class='line'><span class="nx">a</span> <span class="o">-&gt;</span> <span class="nx">a</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="c1">// Java</span>
</span></code></pre></td></tr></table></div></figure>


<h4>你箭袋中的新箭头</h4>

<p>ES6 介绍编写函数的新的语法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// ES5</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">selected</span> <span class="o">=</span> <span class="nx">allJobs</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">job</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">job</span><span class="p">.</span><span class="nx">isSelected</span><span class="p">();</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ES6</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">selected</span> <span class="o">=</span> <span class="nx">allJobs</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">job</span> <span class="o">=&gt;</span> <span class="nx">job</span><span class="p">.</span><span class="nx">isSelected</span><span class="p">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你仅是需要个简单的一个参数的函数，这新的箭头函数语法只需要简单地 <code>Identifier =&gt; Expression</code>。你可以不用编写 <code>function</code>和<code>return</code>这些关键字，同时包括 括号、大括号、分号。</p>

<p>（我个人是非常喜欢这个特性的，没有限定键入<code>function</code>对我来说十分的重要，因为我时不时会键入<code>functoin</code>，从而不得不回头去更正它。）</p>

<p>为了编写多参数的函数（或者没有参数、剩余和默认参数、或解构参数），你将需要添加括号和参数列表。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// ES5</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">total</span> <span class="o">=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
</span><span class='line'><span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ES6</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">total</span> <span class="o">=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我认为它看起来是十分好的。</p>

<p>箭头函数可以像某些库中的功能性工具(functional tool)一样漂亮地工作，如 Underscore.js 和 Immutable。实际上，<a href="https://facebook.github.io/immutable-js/docs/#/">Immutable的文档</a> 中的例子都是用ES6来编写的，所以其中的一些已经使用上了 箭头函数。</p>

<p>那么，对于非功能性的设置该怎么办呢？箭头函数 可以包含着一个代码块，而不仅是一个表达式。回顾一下我们之前的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// ES5</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s2">&quot;#confetti-btn&quot;</span><span class="p">).</span><span class="nx">click</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">playTrumpet</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">fireConfettiCannon</span><span class="p">();</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>在ES6中如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// ES6</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s2">&quot;#confetti-btn&quot;</span><span class="p">).</span><span class="nx">click</span><span class="p">(</span><span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">playTrumpet</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">fireConfettiCannon</span><span class="p">();</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个小提升，在使用 Promises 时，这作用会更加有魔法，它可以将类如 <code>}).then( function (result) {</code>的行堆起来。</p>

<p>注意，代码块的箭头函数并不会自动返回一个值，所以需要 <code>return</code> 进行返回值操作。</p>

<p>当使用箭头函数来创建普通对象时，需要用括号将对象括起来：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// create a new empty object for each puppy to play with</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">chewToys</span> <span class="o">=</span> <span class="nx">puppies</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">puppy</span> <span class="o">=&gt;</span> <span class="p">{});</span>  <span class="c1">// BUG!</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">chewToys</span> <span class="o">=</span> <span class="nx">puppies</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">puppy</span> <span class="o">=&gt;</span> <span class="p">({}));</span> <span class="c1">// ok</span>
</span></code></pre></td></tr></table></div></figure>


<p>不幸的是，一个空对象和一个空的代码块实际上是一样的。在 ES6 中，箭头后面的 <code>{</code> 会总是被认为是 代码块的开始标识，而不是对象的开始。因此，代码 <code>puppy =&gt; {}</code>会被编译为一个箭头函数，并不会做什么，返回值为 <code>undefined</code>。</p>

<p>更多的困扰，一个对象从字面中如 <code>{key: value}</code> 至少看起来像一包含了 标签语句的代码块，但这要看你的JS引擎怎么识别它。幸运的是，<code>{</code> 是唯一的歧义的字符，所以使用括号来包含对象 是 唯一 你需要谨记的怪点。</p>

<h4><code>this</code> 是什么</h4>

<p>普通的 <code>function</code>函数和箭头函数有些微小的差别。<strong>箭头函数没有它们自有的 <code>this</code> 的值</strong>。箭头函数中的 <code>this</code> 总是来源于包含此箭头函数的作用域。</p>

<p>在我们试图在实践中指出上面意味着什么之前，让我们稍微后退一下。</p>

<p>JS 中的 <code>this</code> 是怎么工作的？它的值来源于哪里？这并没有简短的答案。如果你头脑认为它很简单，是因为你已经处理它很长时间了。</p>

<p>引起 <code>this</code> 这提问的原因是 <code>function</code> 函数会自动接收一个 <code>this</code>的值，无论他们是否想要它。你是否编写过这黑代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="nx">addAll</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">addAll</span><span class="p">(</span><span class="nx">pieces</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">pieces</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">piece</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">self</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">piece</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，你可能会喜欢在内部的函数中编写 <code>this.add(piece)</code>。但是不幸，内部函数并不会继承外部函数的<code>this</code>值。在内部函数中，<code>this</code>将可能会是<code>window</code>或者<code>undefined</code>。临时变量<code>self</code>作用是将外部函数中的<code>this</code>传递到内部函数中。（另外的方法是在内部使用 <code>.bind(this)</code>，但是两种方法都不是很漂亮。）</p>

<p>在 ES6 中，如果你按照以下规则使用，这种<code>this</code>的黑代码将会消失：</p>

<ul>
<li>当调用非箭头函数的方法时，使用 <code>object.method()</code>语法进行调用，如此这函数会从调用者中接收到一个有意义的<code>this</code>的值。</li>
<li>在任何地方都使用箭头函数</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// ES6 with method syntax</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="nx">addAll</span><span class="p">(</span><span class="nx">pieces</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">pieces</span><span class="p">,</span> <span class="nx">piece</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">piece</span><span class="p">));</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过 方法箭头，我不再会编写 <code>functoin</code>了，这真是个很好的想法。</p>

<p>箭头和非箭头函数还有一个细小的差别：箭头函数并不会获取他们自己的 <code>arguments</code>对象。同时，在ES6中，你最好在任何的地方都使用剩余和默认参数。</p>

<h4>使用箭头可穿透黑科技的核心</h4>

<p>我们已经谈到很多箭头函数的实践应用，我还想提到一个可能会用到的点：把 ES6 中的箭头函数作为一个学习的工具，去挖掘计算领域深层次的东西。无论其是否实用，这都取决于你自己。</p>

<p>在1936年，Alonzo Church 和 Alan Turing 各自独立开发了强大的的数学计算模型。Turing 称之为 <code>a-machines</code>，但是大家从开始都称为 图灵机器(Turing machines)。Church 编写的是想取代函数，他的模型称为 <a href="https://en.wikipedia.org/wiki/Lambda_calculus">λ-calculus</a>。 (λ 是希腊语中的lambda的小写。) 这就是Lisp使用关键字 <code>LAMBDA</code>来声明函数的原因，这也是为什么我们今天称函数为 &#8220;lambda&#8221;的原因。</p>

<p>但是，什么是 <em>λ-calculus</em> ? 计算模型(model of computation) 表示什么呢？</p>

<p>简短的文字是很难解释的，但是这里是我的理解：λ-calculus 是第一种编程语言之一。虽然它并不是被设计为一个编程语言，随后的一到二十年存储程序的计算机也随之出现。但是，它作为一个非常简单、纯粹的数学语言，可以展示出你想要的各种计算。Church 希望这个模型能广泛地用来证明计算。</p>

<p>然后，他发现仅需要在他的系统中有：函数(functions)。</p>

<p>想象一下这种声明是怎么特别的：没有对象、数组，没有数值，没有<code>if</code>语句、<code>while</code>循环，没有分号、分配符号、逻辑操作符，或者任意的循环，白手起家，只使用函数能够做到 JS 做到的任何类型的计算操作。</p>

<p>下面是个数学算法的程序，使用了 Church λ 的符号：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">fix</span> <span class="o">=</span> <span class="err">λ</span><span class="nx">f</span><span class="p">.(</span><span class="err">λ</span><span class="nx">x</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="err">λ</span><span class="nx">v</span><span class="p">.</span><span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)))(</span><span class="err">λ</span><span class="nx">x</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="err">λ</span><span class="nx">v</span><span class="p">.</span><span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>它等价于JS中的</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">fix</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span>  <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)))</span>
</span><span class='line'>                       <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure>


<p>如此，JS就包含了  λ-calculus （lambda积分）的实现，并且是能够运行。<em>The λ-calculus is in JavaScript</em></p>

<p>关于 Alonzo Church 和之后的研究人员对 λ-calculus 做什么的故事，还有其是怎么潜移默化地影响着每个主流编程语言，这已经超出了这篇文章讨论的范围了。但是，如果你对基础计算科感兴趣，或者你仅仅是想看到一编程语言没有其它、只有函数是怎么做到循环和递归的，你可能要努力并花费些下雨的下午去查看 <a href="https://en.wikipedia.org/wiki/Church_encoding">Church numerals</a> 和 <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Strict_fixed_point_combinator">fixed-point combinators</a>,  然后将代码运行于 Firefox 的控制台或者 <a href="https://developer.mozilla.org/en-US/docs/Tools/Scratchpad">Scratchpad</a> 。由于 ES6 的箭头 拥有其它力量，JS可以光明地声称它是探索 λ-calculus 的最好编程语言。</p>

<h4>什么时候使用箭头(箭头函数)</h4>

<p>ES6 中的箭头函数在Firefox是由我还实现的，于2013年。Jan de Mooij 的工作是其更为快速，同时感谢 Tooru Fujisawa 和 ziyunfei 的补丁。</p>

<p>箭头函数也在微软的Edge浏览器的预览版本中支持了，它们也可以在 Babel , Traceur 和 TypeScript 中使用了，如此你现在可以使用它们(从而使用箭头函数)。</p>

<p>我们的下个主题是ES6中比较特殊的一个特性。我们可以看到<code>typeof x</code>会返回一个完成新的值。那么我们会问：什么时候返回的不是string？我们将会努力寻找其相等的含义，确实有些怪异。那么，请于下周加入我们，继续深入 ES6 吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 in Depth: Destructuring]]></title>
    <link href="http://shatle.github.io/blog/2015/11/15/es6-in-depth-destructuring/"/>
    <updated>2015-11-15T10:22:40+08:00</updated>
    <id>http://shatle.github.io/blog/2015/11/15/es6-in-depth-destructuring</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/">ES6 in Depth: Destructuring</a></p></blockquote>

<p><em>编辑者说明：今天文章的早期版本是由Firefox工具开发工程师 Nick Fitzgerald 完成的，其起初来自 Nick 的博客 (Destructuring Assignment in ES6)[http://fitzgeraldnick.com/weblog/50/]</em></p>

<h4>什么是解构的赋值</h4>

<p>解构的赋值允许你给数组或者对象的变量赋值时，其语法类似于数组或者对象。这种语法非常简洁，其表达的意思也比传统的属性赋值要易懂。</p>

<p>没有解构的赋值，你可能访问一个三元素的数组时会如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">first</span> <span class="o">=</span> <span class="nx">someArray</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">second</span> <span class="o">=</span> <span class="nx">someArray</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">third</span> <span class="o">=</span> <span class="nx">someArray</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过解构的赋值，与其等价的代码，而且更为精确和可读：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">,</span> <span class="nx">third</span><span class="p">]</span> <span class="o">=</span> <span class="nx">someArray</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>SpiderMonky作为Firefox的JS的解释器，已经支持大部分的解构，但是并不是所有。(Track SpiderMonkey’s destructuring (and general ES6) support in bug 694100)[https://bugzilla.mozilla.org/show_bug.cgi?id=694100]。</p>

<h4>数组和迭代的解构</h4>

<p>我们已经在上面看到解构的赋值，其通用的语法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">[</span> <span class="nx">variable1</span><span class="p">,</span> <span class="nx">variable2</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">variableN</span> <span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这会将 array 中的元素对应地分配到 variable1 到 variableN。如果你想同时声明变量，你可以在分配的前面增加<code>var</code>、<code>let</code>、<code>const</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">[</span> <span class="nx">variable1</span><span class="p">,</span> <span class="nx">variable2</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">variableN</span> <span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">;</span>
</span><span class='line'><span class="kd">let</span> <span class="p">[</span> <span class="nx">variable1</span><span class="p">,</span> <span class="nx">variable2</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">variableN</span> <span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">;</span>
</span><span class='line'><span class="kr">const</span> <span class="p">[</span> <span class="nx">variable1</span><span class="p">,</span> <span class="nx">variable2</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">variableN</span> <span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上，用<code>variable</code>并不合适，因为你可以用你想的多深的内嵌模式(来分配值)，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">[</span><span class="nx">foo</span><span class="p">,</span> <span class="p">[[</span><span class="nx">bar</span><span class="p">],</span> <span class="nx">baz</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">]];</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 1</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 2</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">baz</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>再者，你可以用解构来跳过数组的部分元素：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">[,,</span><span class="nx">third</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="s2">&quot;baz&quot;</span><span class="p">];</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">third</span><span class="p">);</span>
</span><span class='line'><span class="c1">// &quot;baz&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>你还可以通过 “剩余”的模式来抓取数组中的尾部的元素：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">[</span><span class="nx">head</span><span class="p">,</span> <span class="p">...</span><span class="nx">tail</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tail</span><span class="p">);</span>
</span><span class='line'><span class="c1">// [2, 3, 4]</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你访问数组中超边界或者不存在的元素时，你会得到通过索引返回的值：undefined.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([][</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'><span class="c1">// undefined</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="p">[</span><span class="nx">missing</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">missing</span><span class="p">);</span>
</span><span class='line'><span class="c1">// undefined</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，利用数组的分配模式的解构分配方式也适用于迭代中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">fibs</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">yield</span> <span class="nx">a</span><span class="p">;</span>
</span><span class='line'>     <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">,</span> <span class="nx">third</span><span class="p">,</span> <span class="nx">fourth</span><span class="p">,</span> <span class="nx">fifth</span><span class="p">,</span> <span class="nx">sixth</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fibs</span><span class="p">();</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sixth</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 5</span>
</span></code></pre></td></tr></table></div></figure>


<h4>解构对象</h4>

<p>对对象解构可以让你将对象的不同属性绑定到变量中。当你指定要绑定的属性时，相关你绑定的变量的值就等于其属性值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">robotA</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Benber&quot;</span> <span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">robotB</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Flexo&quot;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">nameA</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">robotA</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">nameB</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">robotB</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">nameA</span><span class="p">);</span>
</span><span class='line'><span class="c1">// &quot;Benber&quot;</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">nameB</span><span class="p">);</span>
</span><span class='line'><span class="c1">// &quot;Flexo&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有个有益的简单语法，当属性和变量的名称一致时：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">{</span> <span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s2">&quot;lorem&quot;</span><span class="p">,</span> <span class="nx">bar</span><span class="o">:</span> <span class="s2">&quot;ipsum&quot;</span> <span class="p">};</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span><span class='line'><span class="c1">// &quot;lorem&quot;</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span>
</span><span class='line'><span class="c1">// &quot;ipsum&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>类似数组的解构，你可以解构更多的内嵌和组合：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">complicatedObj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">arrayProp</span><span class="o">:</span> <span class="p">[</span>
</span><span class='line'>     <span class="s2">&quot;Zapp&quot;</span><span class="p">,</span>
</span><span class='line'>     <span class="p">{</span> <span class="nx">second</span><span class="o">:</span> <span class="s2">&quot;Brannigan&quot;</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">]</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="p">{</span> <span class="nx">arrayProp</span><span class="o">:</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">{</span> <span class="nx">second</span> <span class="p">}]</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">complicatedObj</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">first</span><span class="p">);</span>
</span><span class='line'><span class="c1">// &quot;Zapp&quot;</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">second</span><span class="p">);</span>
</span><span class='line'><span class="c1">// &quot;Brannigan&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你解构的属性并没有定义时，你会得到 <code>undefined</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">{</span> <span class="nx">missing</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">missing</span><span class="p">);</span>
</span><span class='line'><span class="c1">// undefined</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个潜在的问题你应该了解，当你解构一个对象并分配到变量中时，但是你并没有声明它们（就是没有 let, const, 或者 var ）:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">{</span> <span class="nx">blowUp</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">blowUp</span><span class="o">:</span> <span class="mi">10</span><span class="p">};</span>
</span><span class='line'><span class="c1">// Syntax error</span>
</span></code></pre></td></tr></table></div></figure>


<p>之所以会发生这事，因为JS语法告诉解释引擎将<code>{</code>开头的表达式认为是一个块表达式（例如，<code>{ console }</code>就是个合法的块表达式）。解决方案还可以是将整个表达式用括号括起来：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">({</span> <span class="nx">safe</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{});</span>
</span><span class='line'><span class="c1">// No errors</span>
</span></code></pre></td></tr></table></div></figure>


<h4>解构的值不是对象、数组或者迭代</h4>

<p>当你对<code>null</code>和<code>undefined</code>的解构时，你会得到错误：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">{</span><span class="nx">blowUp</span><span class="p">}</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span><span class='line'><span class="c1">// TypeError: null has no properties</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，你可以解构其它原始的类型，如 布尔、数值、字符串，然后得到<code>undefined</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">{</span><span class="nx">wtf</span><span class="p">}</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">;</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">wtf</span><span class="p">);</span>
</span><span class='line'><span class="c1">// undefined</span>
</span></code></pre></td></tr></table></div></figure>


<p>这结果有点意想不到，但是通过更多的测试可以其实其原因很简单。当我们使用对象的分配模式，其值要求可被强制解释为对象。多数类型可以转化为对象，但是null 和 undefined 不行。当使用数组分配模式时，值必须允许迭代。</p>

<h4>默认值</h4>

<p>当你解构的属性没有定义时，你可以提供默认值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">[</span><span class="nx">missing</span> <span class="o">=</span> <span class="kc">true</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">missing</span><span class="p">);</span>
</span><span class='line'><span class="c1">// true</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="p">{</span> <span class="nx">message</span><span class="o">:</span> <span class="nx">msg</span> <span class="o">=</span> <span class="s2">&quot;Something went wrong&quot;</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
</span><span class='line'><span class="c1">// &quot;Something went wrong&quot;</span>
</span><span class='line'><span class="kd">var</span> <span class="p">{</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{};</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>（笔者注：前第一二个特性已经在Firefox中实现了，但第三个没有，详见 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=932080">bug 932080</a> ）</p>

<h4>解构的应用实践</h4>

<h5>定义函数参数</h5>

<p>作为开发人员，我们希望使用更加合理的API，使用一个多属性的对象作为参数，而不是强制我们的用户来记住多个独立的参数（来作为函数的参数）。当我们想要引用其属性值时，我们可以使用解构来避免重复传入对象的属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">removeBreakpoint</span><span class="p">({</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">column</span> <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这代码块来源于真实的代码，它来自Firefox的JS调试工具（也是JS的实现方式）。我们发现这模式令人很是愉快。</p>

<h5>注册对象参数</h5>

<p>扩展之前的例子，我们可以在解构时给予对象属性默认值。当我们存在的一个对象，这个对象是用来存储注册信息的，其部分属性已有合理的默认值时，解构就显得十分有好处了。例如，jQuery 的 <code>ajax</code>函数传递一个注册对象作为第二个参数，可以重写成这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">async</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">beforeSend</span> <span class="o">=</span> <span class="nx">noop</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">cache</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">complete</span> <span class="o">=</span> <span class="nx">noop</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">crossDomain</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">global</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
</span><span class='line'>  <span class="c1">// ... more config</span>
</span><span class='line'><span class="p">})</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// ... do stuff</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这避免对注册对象的每个属性重复地进行类如 <code>var foo = config.foo || theDefaultFoo;</code> 的情况。</p>

<p>(笔者注：不幸，在Firefox中，对象默认值的缩略语法并没有实现。我知道，我们已经有些段落已经进行了说明。详见 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=932080">bug 932080</a> )</p>

<h5>在ES6迭代协议中</h5>

<p>ES6 定义了迭代的协议，我们已经在这系列文章的早期文章中有谈到。当你对 <code>Map</code>进行迭代时，你会得到一系列的 <code>[key, value]</code> 键值对。我们可能解构这一对结构，可很容易访问基 key 和 value：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span><span class='line'><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="s2">&quot;the global&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nb">document</span><span class="p">,</span> <span class="s2">&quot;the document&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="nx">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s2">&quot; is &quot;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// &quot;[object Window] is the global&quot;</span>
</span><span class='line'><span class="c1">// &quot;[object HTMLDocument] is the document&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>迭代时仅要 key :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="nx">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者迭代只要 value，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="p">[,</span><span class="nx">value</span><span class="p">]</span> <span class="nx">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h5>多个返回值</h5>

<p>尽管JS语言并没有完全地支持返回多个值，但是这并不必要，因为你可以返回一个数组并对结果进行解构：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">returnMultipleValues</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">var</span> <span class="p">[</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">]</span> <span class="o">=</span> <span class="nx">returnMultipleValues</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，你可以使用一个对象来作为容器，并命名返回的值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">returnMultipleValues</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>     <span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>     <span class="nx">bar</span><span class="o">:</span> <span class="mi">2</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">var</span> <span class="p">{</span> <span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">returnMultipleValues</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实，这两种模式更好的方式是将结果保存到临时容器中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">returnMultipleValues</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>     <span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>     <span class="nx">bar</span><span class="o">:</span> <span class="mi">2</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">returnMultipleValues</span><span class="p">();</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">bar</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者，可能使用延续传递的样式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">returnMultipleValues</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">k</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">returnMultipleValues</span><span class="p">((</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<h5>导入CommonJS的模块名称</h5>

<p>还没有使用 ES6 的模块？还依然使用 CommonJS模块？没问题！当导入某些 CommonJS 模块 X 时，而模块 X 导出比你想要的还要更多的函数。利用解构，你可以精确地使用你想要使用的模块，避免命名的混乱：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">const</span> <span class="p">{</span> <span class="nx">SourceMapConsumer</span><span class="p">,</span> <span class="nx">SourceNode</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;source-map&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h4>总结</h4>

<p>所以，你可以看到解构在很多细节上的应用都很有用，在 Mozilla 中我们已经对其有很多经验。Lars Hansen 在十年之前介绍过 Opera 中的解构，接着 Brendan Eich 为 Firefox 也增加了支持。我们知道，解构如果能应用于此语言的每天工作中，会使得所有的你的代码看起来更加的简洁。</p>

<p>五周之前，我们说过，ES6会改变你编写JS的方式。我们在大脑中有一系列的具体特性，每段时间学习到的东西都能使自己有些提升。合并在一起，它们将会最终影响到你工作中的每个项目。方式的改革引导变革。</p>

<p>顺应地应用ES6的解构需要团队的努力。特别感谢 Tooru Fujisawa (arai) 和 Arpad Borsos (Swatinem) 作出的贡献。</p>

<p>对于解构的支持，Chrome的开发工作正在进行中，其它的浏览器也毫无疑问地在以后的某时会支持。现在，如果你想在Web中使用解构，那么你需要使用 <a href="http://babeljs.io/">Babel</a> 和 <a href="https://github.com/google/traceur-compiler#what-is-traceur">Traceur</a>。</p>

<hr />

<p>再次感谢 Nick Fitzgerald 的文章。</p>

<p>下周，我们将谈到一个特性，它或多或少地使用更简单的方式来改变你已经编写的JS代码，这些代码通常自始自终是语言的底层代码。你会关心吗？更为简洁的语法你是否会兴奋呢？我确信答案是肯定的，但是先不要回答我。在下周加入我们并进行了解，我们将会深入 箭头函数（arrow function）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 in Depth: Rest parameters and defaults]]></title>
    <link href="http://shatle.github.io/blog/2015/10/25/es6-in-depth-rest-parameters-and-defaults/"/>
    <updated>2015-10-25T17:09:33+08:00</updated>
    <id>http://shatle.github.io/blog/2015/10/25/es6-in-depth-rest-parameters-and-defaults</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/05/es6-in-depth-rest-parameters-and-defaults/">ES6 in Depth: Rest parameters and defaults</a></p></blockquote>

<p>今天文章是关于JS函数中更具有表达力的两个特性：剩余参数和默认参数。</p>

<h4>剩余参数</h4>

<p>创建一个可变的函数作为API是个常见的需求，而这函数可接受任意个参数。例如，<code>String.prototype.concat</code>方法可接受任意数量的字符串参数。利用剩余参数，ES6提供了一种编写可变函数的方式。</p>

<p>为了说明，让我们编写一个简单的可变函数<code>containsAll</code>，用来检查一个字符串是否包含有一定数量的子串。例如，<code>containsAll("banana", "b", "nan")</code> 会返回 <code>true</code>，而<code>containsAll("banana", "c", "nan")</code> 会返回<code>false</code>。</p>

<p>这里是一个传统的实现方式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">containsAll</span><span class="p">(</span><span class="nx">haystack</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">lenght</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">needle</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">haystack</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">){</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种实现方式使用了具有魔力的 arguments 对象，它是一个类似数组的对象，包含了传递给函数的所有参数。这代码确实可以达到我们所需求的目标，但是其可读性并不是最佳的。这函数的参数列表中只包括了一个参数<code>haystack</code>，所以如果只看一眼的话，是不可能知道这函数实际上是支持多个参数的。另外，我们必须小心迭代方式，arguments需要是以 1 开始，而不是 0 ，因为 arguments[0] 对应于 haystack。如果我们需要在 haystack 之前或者之后添加额外的参数时，我们不得不要记得更新循环方法。剩余参数 可解决这些问题。下面是一种利用剩余参数的自然的ES6实现方式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">containsAll</span><span class="p">(</span><span class="nx">haystack</span><span class="p">,</span> <span class="p">...</span><span class="nx">needles</span><span class="p">){</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">needle</span> <span class="nx">of</span> <span class="nx">needles</span><span class="p">){</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">haystack</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="nx">I</span><span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个版本的函数拥有的行为和之前第一个的一样，但是它包含了特殊的<code>...needles</code>语法。让我们看一下<code>containsAll("banana", "b", "nan")</code>是怎么调用此函数的。参数 <code>haystack</code> 如平常一样接受的是传递的第一个参数，值为“banana”。<code>needles</code>之前的省略号表示为一个剩余参数，所有其它的参数会组成一个数组被安排到变量<code>needles</code>中。对于这个例子，<code>needles</code>的值为<code>["b", "nan"]</code>。函数则按正常执行。（注意，我们这里使用了ES6 <code>for-of</code>的循环结构。)</p>

<p>只有函数的最后一个参数可以作为一个剩余参数。在一次调用中，剩余参数之前的参数会和平常一样。所有额外的参数会被放到数组中，并被分配给剩余参数。如果没有额外的参数，剩余参数会简单地被置为空数组；剩余参数不可能会是 <code>undefined</code>。</p>

<h4>默认参数</h4>

<p>通常来说，一个函数并不需要调用所有由调用者传递给的参数，当没有传递参数时，可以智能地使用默认值来作用于这些参数。JS 也有顽固的表单默认参数，当参数没有被传递时会默认设置为<code>default</code>。ES6 推出一种可以指定任意的默认参数的方法。</p>

<p>这里是例子。(其中音符号表示模板字符串，上周已经讨论过了。)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">animalSentence</span><span class="p">(</span><span class="nx">animals2</span><span class="o">=</span><span class="s2">&quot;tigers&quot;</span><span class="p">,</span> <span class="nx">anmals3</span><span class="o">=</span><span class="s2">&quot;bears&quot;</span><span class="p">){</span>
</span><span class='line'>  <span class="k">return</span> <span class="err">`</span><span class="nx">Lions</span> <span class="nx">and</span> <span class="nx">$</span><span class="p">{</span><span class="nx">animals2</span><span class="p">}</span> <span class="nx">and</span> <span class="nx">$</span><span class="p">{</span><span class="nx">animals3</span><span class="p">}</span><span class="o">!</span> <span class="nx">Oh</span> <span class="nx">my</span><span class="o">!</span><span class="err">`&#39;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于每个参数，当调用者没有传递值时，包含<code>=</code>的部分是个表达式，会默认将值赋予到参数中。所以，<code>animalSentence()</code> 返回 <code>"Lions and tigers and bears! Oh my!</code>，<code>animalSentence("elephants")</code> 返回 <code>"Lions and elephants and bears! Oh my!"</code>，<code>animalSentence("elephants", "whales")</code> 返回 <code>"Lions and elephants and whales! Oh my!"</code>。</p>

<p>这些微妙的变化来源于 默认参数：</p>

<ul>
<li>并不像Python, ES6的默认值表达式会在每次函数调用时从左到右执行。这就意味着默认表达式可以使用参数之前的参数值。例如，我们可以让我们的动物句子更有想象力些：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">animalSentenceFancy</span><span class="p">(</span><span class="nx">animals2</span><span class="o">=</span><span class="s2">&quot;tigers&quot;</span><span class="p">,</span>
</span><span class='line'>     <span class="nx">animals3</span><span class="o">=</span><span class="p">(</span><span class="nx">animals2</span> <span class="o">==</span> <span class="s2">&quot;bears&quot;</span><span class="p">)</span> <span class="o">?</span> <span class="s2">&quot;sealions&quot;</span> <span class="o">:</span> <span class="s2">&quot;bears&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="err">`</span><span class="nx">Lions</span> <span class="nx">and</span> <span class="nx">$</span><span class="p">{</span><span class="nx">animals2</span><span class="p">}</span> <span class="nx">and</span> <span class="nx">$</span><span class="p">{</span><span class="nx">animals3</span><span class="p">}</span><span class="o">!</span> <span class="nx">Oh</span> <span class="nx">my</span><span class="o">!</span><span class="err">`</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，<code>animalSentenceFancy("bears")</code>会返回<code>"Lions and bears and sealins. Oh my!"</code>。</p>

<ul>
<li><p>传递 <code>undefined</code>会被认为等价于没有传递参数，因此， <code>animalSentence(undefined, "unicorns")</code> 会返回 <code>"Lions and tigers and unicorns! Oh my!"</code>。</p></li>
<li><p>当参数传递一个没有值的变量时，其传递的值会被设置为 <code>undefined</code>，所以，</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">myFunc</span><span class="p">(</span><span class="nx">a</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="nx">b</span><span class="p">){</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>是允许的，而且其等价于</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">myFunc</span><span class="p">(</span><span class="nx">a</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="nx">b</span><span class="o">=</span><span class="kc">undefined</span><span class="p">){</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>关闭 arguments</h4>

<p>我们现在看到，剩余和默认参数可能替代arguments对象的用处，并且，移除 arguments 通常会使得代码更加易读。除了影响可读性，arguments臭名昭著还因为它 <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments">影响JS的VM效率</a>。</p>

<p>为了使得剩余和默认参数完成取代 arguments，首先第一步需要函数使用剩余或者默认参数，禁止使用 argumentes 对象。尽管支持 arguments 的特性最近不会被移除，但是现在应该尽量避免使用 arguments，而尽可能地使用剩余和默认参数。</p>

<h4>浏览器支持</h4>

<p>Firefox 从 版本15之后就支持 剩余和默认参数了。</p>

<p>不幸的是，没有其它发布的浏览器版本支持剩余和默认参数。V8 最近<a href="https://code.google.com/p/v8/issues/detail?id=2159">支持剩余参数</a>，并且 <a href="https://code.google.com/p/v8/issues/detail?id=2160">默认参数</a> 已经提到日程中。JSC 也将 <a href="https://bugs.webkit.org/show_bug.cgi?id=38408">剩余参数</a> 和 <a href="https://bugs.webkit.org/show_bug.cgi?id=38409">默认参数</a> 提到的日程中。</p>

<p><a href="http://babeljs.io/">Babel</a> 和 <a href="https://github.com/google/traceur-compiler#what-is-traceur">Traceur</a> 解释器都是支持默认参数的，所以可以开始使用它们。</p>

<h4>结论</h4>

<p>尽管技术上并不允许其它新的行为，但是剩余参数和默认参数可以让JS函数声明更加具有表现力和可读性。欢迎来电！</p>

<hr />

<p><em>Note: 感谢 Benjamin Peterson 为 Firefox 实现这些特性，包括他对项目的贡献，同样包括这周的文章教程。</em></p>

<p>下周，我们将会介绍另外 简单、强大、实现、常用的 ES6 特性。它语法类似于你已经使用的数组和对象，并会生成出一种新的、精确的数组和对象的分离方式。这意味着什么呢？为什么你需要分离对象呢？在下周三加入我们并一同来寻找，来自 Mozilla 工程师 Nick Fitzgerald 展示的 【深入ES6 的去结构化（析构）】。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 in Depth: Template strings]]></title>
    <link href="http://shatle.github.io/blog/2015/10/24/es6-in-depth-template-strings/"/>
    <updated>2015-10-24T23:50:37+08:00</updated>
    <id>http://shatle.github.io/blog/2015/10/24/es6-in-depth-template-strings</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings">ES6 in Depth: Template strings</a></p></blockquote>

<p>上周，我们已经提到要变步伐。在迭代器和生成器之后，我们来开始些简单的，这是我之前说过的。我也说过，这些是你未曾遇到过的。那，我们来看这承诺是否能够保持吧。</p>

<p>现在，让我们开始些简单的。</p>

<h4>音符基础</h4>

<p>ES6 推出了一种新的字符串语法，叫做<strong>模板字符串</strong>。他们看起来很像普通的字符串，除了其使用了音符式的字符，而不仅仅是<code>'</code>和<code>"</code>这些引号字符。对于最简单的情况，他们就是字符串：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">context</span><span class="p">.</span><span class="nx">fillText</span><span class="p">(</span><span class="err">`</span><span class="nx">Ceci</span> <span class="nx">n</span><span class="err">&#39;</span><span class="nx">est</span> <span class="nx">pas</span> <span class="nx">une</span> <span class="nx">cha</span><span class="err">î</span><span class="nx">ne</span><span class="p">.</span><span class="err">`</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，之所以称为模板字符串，而不是又普通又老的、仅包含音符的字符串，是因为模板字符串为JS提供了字符串的插入操作。这为JS提供了种好看、且方便的方法来将值插入到字符串中。</p>

<p>错误提示可以有上千百万的方法来实现，但是下面是我内心比较喜欢的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">authorize</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">user</span><span class="p">.</span><span class="nx">hasPrivilege</span><span class="p">(</span><span class="nx">action</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span>
</span><span class='line'>       <span class="err">`</span><span class="nx">User</span> <span class="nx">$</span><span class="p">{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span> <span class="nx">is</span> <span class="nx">not</span> <span class="nx">authorized</span> <span class="nx">to</span> <span class="k">do</span> <span class="nx">$</span><span class="p">{</span><span class="nx">action</span><span class="p">}.</span><span class="err">`</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，<code>${user.name}</code>和<code>${action}</code>叫做 模板替换。JS 会将<code>user.name</code>和<code>action</code>的值插入到最终的字符串中。这可能会产生一个消息如：User jorendorff is not authorized to do hockey.</p>

<p>目前，这相对于<code>+</code>的拼接操作更显得优雅点，你可能还会希望其详细如下：</p>

<ul>
<li><p>代码中的模板替换可以是任意的JS表达式，如 函数调用、算法等等都是允许的。（或许，你甚至还希望能在一个模板字符串中肉插入另一个模板字符串，我称为<em>模板插入</em>。）</p></li>
<li><p>如果值不是字符串时，它会使用常用的规则转为字符串。例如，如果<code>action</code>是个对象，那么<code>.toString()</code>方法将会被调用。</p></li>
<li><p>如果你需要在模板字符串中写入音符号，你必须避免直接用，而是使用斜杠：<code>\'</code>，其会为&#8221;&#8217;&#8221;。</p></li>
<li><p>同样的，如果你在模板字符串中需要包含<code>${</code>这两个字符，我不知道你想怎么实现，但是你可以使用<code>write \${</code>和<code>$\{</code>来规避。</p></li>
</ul>


<p>不像普通的字符串，模板字符串可以进行多行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s2">&quot;#warning&quot;</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span><span class="err">`</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Watch</span> <span class="nx">out</span><span class="o">!&lt;</span><span class="err">/h1&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Unauthorized</span> <span class="nx">hockeying</span> <span class="nx">can</span> <span class="nx">result</span> <span class="k">in</span> <span class="nx">penalties</span> <span class="nx">of</span> <span class="nx">up</span> <span class="nx">to</span> <span class="nx">$</span><span class="p">{</span><span class="nx">maxPenalty</span><span class="p">}</span> <span class="nx">minutes</span><span class="p">.</span><span class="o">&lt;</span><span class="err">/p&gt; `);</span>
</span></code></pre></td></tr></table></div></figure>


<p>所有模板字符串中的空字符，包括换行符和缩进，都会逐个输出的。</p>

<p>好了。由于我之前在上周的承诺，我感到对你们的大脑需要负一定的责任。所以，先在这说明：我心里有些许的紧张。你现在可以停止往下读，或者应该拿着一杯咖啡、好好享受一下完整而未被融化的大脑。真的，返回去并不丢脸。当 Lopes Goncalves 得到一艘海里怪兽攻击、不被暗礁打翻的船后，他是不是探索完了整个南半球？不，他返回，回家了，然后还吃了顿可口的午餐。你喜欢吃午餐，对不对？</p>

<h4>音符的未来</h4>

<p>让我们讨论一下新的东西，模板字符串不做什么：</p>

<ul>
<li><p>它们不会自动帮你处理特殊字符。为了避免跨域网站的脚本攻击，你将不得不小心地处理非信任的数据，就如你拼接普通的字符串。</p></li>
<li><p>它不直接作用于国际化库（对于不同的用户使用不同的语言库）。模板字符串不会处理特定语言的数字和日期的格式，更不用说复数了。</p></li>
<li><p>它们并不是模板库的替代品，如 Mustanche 和 Nunjucks。模板字符串没有任何内置的循环语法&#8211;例如，利用一数组来构建HTML中table的多行，或者条件。（是的，你可以使用模板插入来做到这目的，但对我来说，你那样做看起来就是是排序，是个笑话。）</p></li>
</ul>


<p>ES6 为模板字符串不仅仅提供了一种方法，其可让JS开发人员和库的设计人员更多的能量来解决这些限制或者更多。这一特性特为 <em>标签模板</em>。</p>

<p>标签模板的语法很简单，它只是在模板字符串打开重音符之前加入额外的标签，这个标签是<code>SaferHTML</code>，是合法的html字符。然后，我们就可以使用这个标签来解决之前的第一条的限制：自动处理特殊字符。</p>

<p>注意，<code>SaferHTML</code>并不是ES6标准库中的某些东西，而是要我们自己来实现的，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span>
</span><span class='line'>  <span class="nx">SaferHTML</span><span class="err">`</span><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">$</span><span class="p">{</span><span class="nx">bonk</span><span class="p">.</span><span class="nx">sender</span><span class="p">}</span> <span class="nx">has</span> <span class="nx">sent</span> <span class="nx">you</span> <span class="nx">a</span> <span class="nx">bonk</span><span class="p">.</span><span class="o">&lt;</span><span class="err">/p&gt;`;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这标签有个简单的身份：SaferHTML，但是一个标签也可以是一个属性，例如 <code>SaferHTML.escape</code>，或者甚至是一个方法调用，如<code>SaterHTML.escape({unicodeControlCharacters:false})</code>。(准确来说，任何的 <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-left-hand-side-expressions">MemberExpression or CallExpression</a> 都可以作为一个标签。)</p>

<p>我们已经看到，非标签的模板字符串对于简单的字符串拼接是比较快捷的，标签模板对于某些更为便捷的是：函数调用。</p>

<p>之前的代码等价于：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span>
</span><span class='line'>  <span class="nx">SaferHTML</span><span class="p">(</span><span class="nx">templateData</span><span class="p">,</span> <span class="nx">bonk</span><span class="p">.</span><span class="nx">sender</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>templateData</code>是一个不可变的数组，它包括了由JS引擎替我们生成的模板所有字符串的各部分。这里，这个数组有两个元素，因为这两部分是由替代的标签来分隔的，所以<code>templateData</code>会如<code>Object.freeze(["&lt;p&gt;"," has seet you a bonk.&lt;/p&gt;"])</code>。</p>

<p>(实际上，还有一个额外的属性出现在<code>templateData</code>中。我们不会在此文章中使用到，但是，为了完整性，我将进行些说明：<code>templdateData.raw</code>是标签模板中的另外一个包含所有字符串各部分的数组，它看起来像代码中在每部分的左边增加多类如<code>\n</code>的符号，而不直接另外换行，等等。标准的标签 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw">String.raw</a> 就是使用这种字符串。)</p>

<p>这里给了方便的<code>SaferHTML</code>方法来解释字上百万种的符串和替代物。</p>

<p>阅读了以上部分时，你也许会对<code>SaferHTML</code>做什么感到困扰，然后，你试着来实现它吧。毕竟，这只是一个函数而已。你可以在 Firefox 的开发者控制台进行调试。</p>

<p>这里，可能的一个答案：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">SaferHTML</span><span class="p">(</span><span class="nx">templateData</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">templateData</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="kd">var</span> <span class="nx">arg</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>     <span class="c1">// Escape special characters in the substitution.</span>
</span><span class='line'>     <span class="nx">s</span> <span class="o">+=</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/&amp;/g</span><span class="p">,</span> <span class="s2">&quot;&amp;amp;&quot;</span><span class="p">)</span>
</span><span class='line'>         <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/&lt;/g</span><span class="p">,</span> <span class="s2">&quot;&amp;lt;&quot;</span><span class="p">)</span>
</span><span class='line'>         <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/&gt;/g</span><span class="p">,</span> <span class="s2">&quot;&amp;gt;&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>     <span class="c1">// Don&#39;t escape special characters in the template.</span>
</span><span class='line'>     <span class="nx">s</span> <span class="o">+=</span> <span class="nx">templateData</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过这个定义，标签模板SaferHTML <code>&lt;p&gt;${bonk.sender} has sent you a bonk.&lt;/p&gt;</code> 会输出为<code>&lt;p&gt;ES6&amp;lt;3er has sent you a bonk.&lt;/p&gt;</code>(这结果怎么看都不对啊，作者怎么玩的)。你用户在使用时它都是安全的，即使用户是恶意的用户，如<code>Hacker Steve &lt;script&gt;alert('xss');&lt;/script&gt;</code>这样发送一个炸弹。无论代表什么意思。</p>

<p>(顺便提一下，如果函数使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments">arguments 对象</a> 来攻击你时确实是个问题，下周会解决掉。这是ES6的另一个新特性，我想你会喜欢的。)</p>

<p>一个简单的例子是不能够说明标签模板其灵活性的，让我们重温一下之前我的提到的模板字符串的短板吧，而现在又可以怎么做：</p>

<ul>
<li>模板字符串不能自动过滤特殊字符，但是，就如我们看到的，利用标签模板，你使用一个标签来解决这一问题。</li>
</ul>


<p>实际上，你可以比上面做得更好。</p>

<p>从安全的角度上看，我的<code>SaferHTML</code>函数是十分脆弱的。在HTML中，不同的地方有不同的特殊字符，需求不同的过滤方式，<code>SaferHTML</code>并不能过滤掉所有。但是，通过努力，你可以编写更为智能的<code>SafterHTML</code>函数来对<code>templdateData</code>字符串中的部分HTML，这样子可以让其知道在HTML中哪个是替代物；哪些是内置的元素属性，需要过滤<code>'</code>和<code>"</code>；哪些是URL查询字符串，需要用URL过滤，而不是HTML过滤，等等。这样子，才能正确处理好每个替代物。</p>

<p>会不会由于HTML的解释速度慢而使目标难到达呢？幸运的是，当标签模板重新执行时，其字符串块并不会改变。SafteHTML 可以将解释结果进行缓存，以提升之后调用的速度。(这缓存可以是 WeakMap, 这是另外的ES6特性，我们将会在以后的文章进行讨论。)</p>

<ul>
<li>模板字符串没有内置的国际化特性。但是，利用标签，我们可以实现。<a href="http://jaysoo.ca/2014/03/20/i18n-with-es6-template-strings/">文章</a>  展示了怎么实现的第一步。下面是个例子，可当作小玩意：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">i18n</span><span class="err">`</span><span class="nx">Hello</span> <span class="nx">$</span><span class="p">{</span><span class="nx">name</span><span class="p">},</span> <span class="nx">you</span> <span class="nx">have</span> <span class="nx">$</span><span class="p">{</span><span class="nx">amount</span><span class="p">}</span><span class="o">:</span><span class="nx">c</span><span class="p">(</span><span class="nx">CAD</span><span class="p">)</span> <span class="k">in</span> <span class="nx">your</span> <span class="nx">bank</span> <span class="nx">account</span><span class="p">.</span><span class="err">`</span>
</span><span class='line'><span class="c1">// =&gt; Hallo Bob, Sie haben 1.234,56 $CA auf Ihrem Bankkonto.</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，现在这个例子，<code>name</code>和<code>amount</code>是属于Javascript，但是这里又有些不同的不熟悉的代码，那就是<code>:c(CAD)</code>，这就是模板中需要替换的字符串部分。Javascript部分由JS的引擎控制，那个字符串部分由 Jack 的 i18n 的标签来控制。用户可以从 i18n 的文档中知道 <code>:c(CAD)</code>表示<code>amount</code>数量的货币，叫做加元。</p>

<p>这就是标签模板的作用。</p>

<ul>
<li>模板字符串不是Mustache和Nunjucks的替代品，一定程度上是因为它没有内置的循环或条件的语法。但是现在，让我们看看你可以怎么实现它。如果JS没有提供这一特性，那么可以写一个标签来达到这目的。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// Purely hypothetical template language based on</span>
</span><span class='line'><span class="c1">// ES6 tagged templates.</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">libraryHtml</span> <span class="o">=</span> <span class="nx">hashTemplate</span><span class="err">`</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
</span><span class='line'>     <span class="err">#</span><span class="k">for</span> <span class="nx">book</span> <span class="k">in</span> <span class="nx">$</span><span class="p">{</span><span class="nx">myBooks</span><span class="p">}</span>
</span><span class='line'>       <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;&lt;</span><span class="nx">i</span><span class="o">&gt;</span><span class="err">#</span><span class="p">{</span><span class="nx">book</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/i&gt; by #{book.author}&lt;/li&gt;</span>
</span><span class='line'>     <span class="err">#</span><span class="nx">end</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="err">/ul&gt;</span>
</span><span class='line'><span class="err">`</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其灵活性不止于此。注意，标签函数中的参数并不会自动转为字符串，它们可以是任何类型，返回值也是一样。标签模板甚至并不必要是字符串！你可以使用自定义的标签来实现一定的表达式，DOM 树、图片、代表全部异步进程的Promise、JS的数据结构、GL着色器(GL shaders)&#8230;</p>

<p><strong>标签模板欢迎库设计者来创建强大的领域语言</strong>。这语言可能看起来并不像JS，但是它们可以无缝地嵌于JS中，并智能地与其它语言相互影响。不负责地说，我不能想象有其它语言可以做到这点。我说不出这特性会带给我们什么，这可能性却是令人兴奋的。</p>

<h4>什么时候我可能开始使用？</h4>

<p>在服务端，io.js现在已经支持ES6的模板字符串了。</p>

<p>在浏览器，Firefox 34+ 支持模板字符串，它由Guptha Rajagopal 在去年夏天的一个内部项目中实现的。模板字符串还得到 Chrome 41+ 的支持，但是不是包括 IE 和 Safari。现在，如果你需要在网站中使用模板字符串时，你将需要 <a href="http://babeljs.io/">Babel</a> 或者 <a href="https://github.com/google/traceur-compiler#what-is-traceur">Traceur</a> (来转化为ES5)。你现在还可以使用 <a href="http://blogs.msdn.com/b/typescript/archive/2015/01/16/announcing-typescript-1-4.aspx">TypeScript</a>。</p>

<h4>什么是Markdown?</h4>

<p>Hmm?</p>

<p>好问题。</p>

<p>(这部分并不真正与JS有关，如果你不使用Markdown，你可以跳过这部分。)</p>

<p>对于模板字符串，Markdown和JS现在都使用 ` 符号来代码特殊含义。实际上，在Markdown中，它是内容中的代码界定符号。</p>

<p>如果你写以下Markdown文档时，这会带来些问题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">To</span> <span class="nx">display</span> <span class="nx">a</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">write</span> <span class="err">`</span><span class="nx">alert</span><span class="p">(</span><span class="err">`</span><span class="nx">hello</span> <span class="nx">world</span><span class="o">!</span><span class="err">`</span><span class="p">)</span><span class="err">`</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这会显示为：</p>

<pre><code>To display a message, write `alert(`hello world!`)`.
</code></pre>

<p>注意，这里并没有符号输出，Markdown 解释器会将四个空格认为是代码的界定符号，然后使用HTML的标签来替换它。</p>

<p>为了避免这问题，我们在开始时了解到Markdown些特性：你可以多个符号来作为代码的界定符号，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">To</span> <span class="nx">display</span> <span class="nx">a</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">write</span> <span class="err">``</span><span class="nx">alert</span><span class="p">(</span><span class="err">`</span><span class="nx">hello</span> <span class="nx">world</span><span class="o">!</span><span class="err">`</span><span class="p">)</span><span class="err">``</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://gist.github.com/jorendorff/d3df45120ef8e4a342e5">Gist</a> 有更为详细的内容，它是用Markdown来编写的，你可以看到其源码。</p>

<h4>下一步</h4>

<p>下周，我们将着手这数十年来程序大大在其它语言十分乐道的两个特性：一、大家喜欢尽可能不写没必要的参数；二、部分人喜欢很多的参数。好吧，我说的是就是函数的参数，这特性是我们所有人都需要知道的。</p>

<p>我们将通过 Firefox中这一特性的作者的角度来了解这些特性，所以，请在下周加入我们吧，猜测一下，其作者 Benjamin Peterson 是怎么深入 ES6的默认参数和剩余参数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[es6 in depth: generators]]></title>
    <link href="http://shatle.github.io/blog/2015/09/26/es6-in-depth-generators/"/>
    <updated>2015-09-26T23:19:46+08:00</updated>
    <id>http://shatle.github.io/blog/2015/09/26/es6-in-depth-generators</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://hacks.mozilla.org/2015/05/es6-in-depth-generators/">ES6 In Depth: Generators</a></p></blockquote>

<p>我对今天的文章感到非常的兴奋，今天，我们将讨论ES6中最为魔法的特性。</p>

<p>从“魔法”这词我想表达什么？对于初学者来说，这个特性是不同于现有JS中的，它一开始就是神秘的。从某种意义上说，它还是语言内部的正常行为(In a sense, it turns the normal behavior of the language inside out)。如果这还不够魔法，我都不知道怎么说了。</p>

<p>另外，这个特性重点还在于，其以简明的代码来消除邪恶代码中的callback。(JS常见的多层callback, 写nodejs会很是恶心。)</p>

<p>是我有点夸大了？让我们开始进入，然后由你自己来作出判断吧。</p>

<h4>ES6 生成器介绍</h4>

<p>什么是生成器？</p>

<p>让我们开始用一个例子来看一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">quips</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">yield</span><span class="s2">&quot;hello &quot;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;!&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">yield</span><span class="s2">&quot;i hope you are enjoying the blog posts&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">yield</span><span class="s2">&quot;it&#39;s cool how your name starts with X, &quot;</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">yield</span><span class="s2">&quot;see you later!&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这代码来自<a href="http://people.mozilla.org/~jorendorff/demos/meow.html">a talking cat</a>，它可能是现今网络最为重要的一种应用。(继续，<a href="http://people.mozilla.org/~jorendorff/demos/meow.html">点击，一起玩耍吧</a>。当你感觉到完全懵时，回到这里看解释。)</p>

<p>这代码看起来有几分类似函数，是不是？这个称为<code>generator-function</code>(生成器函数)，它拥有许多和函数相同的地方。但是，你现在必须清楚以下两个不同点：</p>

<ul>
<li>一般的函数以<code>function</code>开头，生成器函数是<code>function*</code></li>
<li>在生成器函数中，<code>yield</code>是关键字，其语法更像是<code>return</code>。区别在于函数(甚至是生成器函数)只能<code>return</code>一次，而生成器函数可能<code>yield</code>多次。生成器中的<code>yield</code>会延缓执行，所以它可以在以后重新唤起。</li>
</ul>


<p>这就是一般函数和生成器函数的一个很大的不同点。一般函数不能内部暂停，但生成器函数可以。</p>

<h4>生成器做什么</h4>

<p>当你调用<code>quips()</code>生成器函数时，会发生什么呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">iter</span> <span class="o">=</span> <span class="nx">quips</span><span class="p">(</span><span class="s2">&quot;jorendorff&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">[</span><span class="nx">object</span> <span class="nx">Generator</span><span class="p">]</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
</span><span class='line'>  <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s2">&quot;hello jorendorff!&quot;</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span> <span class="p">}</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
</span><span class='line'>  <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s2">&quot;i hope you are enjoying the blog posts&quot;</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span> <span class="p">}</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
</span><span class='line'>  <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s2">&quot;see you later!&quot;</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span> <span class="p">}</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
</span><span class='line'>  <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可能会习惯地按照普通的函数去推断其是怎么运行的。当你调用时，它会马上运行，它一直运行直到碰到<code>return</code>或者<code>throw</code>，这是所有JS程序大大的老习惯。</p>

<p>调用一个生成器的方法类似于<code>quips("jorendorff")</code>，但是，当你调用一个生成器时，它并不立即运行，而返回的是一个暂停的生成器对象(在例子中是<code>iter</code>)。你可以认为这个生成器函数是一个函数调用，它这时是冻结的。具体来说，仅在运行第一行代码之前，它在生成器函数开始时是冻结的。</p>

<p>每次你调用生成器对象的<code>.next()</code>方法时，函数自已会开始解冻，并且直到下一个<code>yield</code>时才会停止。</p>

<p>这就是上面为什么我们每次调用<code>iter.next()</code>，却得到不同的字符串值的原因。这些值来源于<code>quips()</code>函数中的<code>yield</code>表达式。</p>

<p>在最后一次调用<code>iter.next()</code>，我们来到了生成器函数的末尾，所以<code>.done</code>域的结果是<code>true</code>。到达函数的末尾时返回值是<code>undefined</code>，这就是<code>.value</code>域的结果是<code>undefined</code>。</p>

<p>现在可能合适回到 <a href="http://people.mozilla.org/~jorendorff/demos/meow.html">the talking cat demo page</a> 把这代码玩起来了，试试将一个<code>yield</code>放到循环里面，会发生什么呢？</p>

<p>从技术的角度来说，每次生成器<code>yield</code>时，生成器的栈架构中，<code>yield</code>的本地变量、参数、临时变量、执行的位置都会从此栈架构中移除。但是，这个生成器依然会对此栈架构保持着引用(或者是复制体)，所以之后的<code>.next()</code>调用时会再次激活生成器并继续执行。</p>

<p>这里需要指出的是生成器并不是多线程的在多线程的语言中，多个代码块可以在同一时间一起运行。这会引起不同条件的资源竞争、不确定性、非常好的性能。生成器一点都不像这样，当生成器运行时，它只能运行于调用者的那个线程中，这个执行过程是有序并确定的。并不像系统线程，当生成器碰到<code>yield</code>时，它只会在其内部的相应位置暂停起来。</p>

<p>好了，我们现在知道生成器是什么了。我们知道生成器运行、暂停、重新执行。现在有个大问题？怎么使得这强大的能力变得可用呢？</p>

<h4>生成器是迭代器</h4>

<p>上周，我们看到的ES6迭代器不仅仅是个内置的类，它们还是这新语言允许扩展的地方。你通过实现 <code>[Symbol.iterator]()</code>和<code>.next()</code>方法来创建自己的迭代器。</p>

<p>但是，实现这个接口多少都会需要些工作，让我们来看一下在实践中是怎么实现一个迭代器的。例如，让我们来实现一个简单的值域来作简单地递增一个数值，就像旧时的<code>for(:;)</code>循环：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// This should &quot;ding&quot; three times</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;Ding! at floor #&quot;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里有个解决方案，就是使用ES6的类。(如果对类的概念语法不清楚时，不用担心，我们会在以后的文章中进行说明的。)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">class</span> <span class="nx">RangeIterator</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span>
</span><span class='line'>     <span class="k">this</span><span class="p">.</span><span class="nx">stop</span> <span class="o">=</span> <span class="nx">stop</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>     <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>       <span class="k">return</span> <span class="p">{</span><span class="nx">done</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span><span class="p">};</span>
</span><span class='line'>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>       <span class="k">return</span> <span class="p">{</span><span class="nx">done</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="kc">undefined</span><span class="p">};</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// Return a new iterator that counts up from &#39;start&#39; to &#39;stop&#39;.</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="nx">RangeIterator</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://codepen.io/anon/pen/NqGgOQ">点击这里看效果</a></p>

<p>这就是如 Java 或者 Swift 的实现方式。它不是很坏，但是它又不是那么微不足道，而不用注意。这代码没有bug？这并不好说。我们试图模拟原来的<code>for(:;)</code>循环，但是看起来不并像，相反，迭代器的协议强制我们去拆散这循环。</p>

<p>看到这里，你或许对迭代器有些许的冷淡了。迭代器好用，但不好实现。</p>

<p>为了让迭代器更为容易地构建，我们不可能向你介绍一种少见、奇怪的新的JS语言流结构。但是，自从我们已有了生成器，我们能不能用它们来实现？让我们试一下吧：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">stop</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>     <span class="k">yield</span> <span class="nx">i</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://codepen.io/anon/pen/mJewga">点击这里看效果</a></p>

<p>以上的四行代码的生成器，相比于之前的包含有<code>RangeIterator</code>类的23行<code>Range()</code>实现，复杂度得到了降低。这可能就是生成器是迭代器的原因。所有的生成器都有内置的<code>.next()</code>和<code>[Symbol.iterator]()</code>的实现。你只需要写循环的行为就行了。</p>

<p>离开生成器来实现迭代器就像是被强制用被动语态来写一整封长长的邮件。如果你不能通过简单的语言来说明你想表达的意思，那么相反你最终说的会变得很费解。由于没有使用循环语法，必须要用函数式的代码来完成循环，使<code>RangeIterator</code>变得又长又显怪异。因此，生成器就是你应该要的答案。</p>

<p>生成器作为迭代器，我们可以用来做什么呢？</p>

<ul>
<li><strong>使得任何对象都可迭代</strong>。只需要写一个生成器函数来串连<code>this</code>(对象集)，yielding (反复地产出)它的每次值。然后，使用这个生成器函数来应用对象的<code>[Symbol.iterator]()</code>方法。</li>
<li><strong>简化构建数组的函数</strong>。它支持你构建函数，来返回每次循环都可处理的数组，就像这样：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// Divide the one-dimensional array &#39;icons&#39;</span>
</span><span class='line'><span class="c1">// into arrays of length &#39;rowLength&#39;.</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">splitIntoRows</span><span class="p">(</span><span class="nx">icons</span><span class="p">,</span> <span class="nx">rowLength</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">rows</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">rowLength</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="nx">rows</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">icons</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">rowLength</span><span class="p">));</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">rows</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>生成器可使这代码变为更短些：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">splitIntoRows</span><span class="p">(</span><span class="nx">icons</span><span class="p">,</span> <span class="nx">rowLength</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">rowLength</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">yield</span> <span class="nx">icons</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">rowLength</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两者在行为上的唯一不同的地方是，第一种一次性返回处理后的结果，而第二种是返回数组，是一个迭代器，结果可以按要求逐一进行处理。</p>

<ul>
<li><p><strong>得到不常见的大小</strong>。你不能创建一个无限的数组，但是，你可以返回一个产生无终止序列的生成器。无论调用者想得到多少值，都可以从这生成器中得到。</p></li>
<li><p><strong>重构复杂的循环</strong>。你是否写过庞大而丑陋的函数？你会不会想要把它打散到两个更为简单的部分中？生成器是你重构工具中的新的一把刀子。当你面对复杂的循环时，你可以将生成数据的那部分代码抽离出来，放到一个分离出来的生成器函数中。然后，循环就可以变为<code>for (var data of myNewGenerator(args))</code>。</p></li>
<li><p><strong>配合迭代器使用</strong>。ES6 并没有为过滤、重组或者直接处理可迭代的数组集 提供额外的库。但是，生成器是搞定这些的好工具，你只需要几行代码就行。</p></li>
</ul>


<p>例如，为了让DOM的<code>NodeList</code>支持<code>Array.prototype.filter</code>的等同功能，而不只是数组。部分代码有：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="o">*</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">test</span><span class="p">,</span> <span class="nx">iterable</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">item</span> <span class="nx">of</span> <span class="nx">iterable</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="nx">test</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
</span><span class='line'>      <span class="k">yield</span> <span class="nx">item</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以，生成器很有用，是不是？这是确定的。它们是以一种难以想象的简单方法来实现自定义的迭代器，这个迭代器是ES6中新的数据循环标准。</p>

<p>但是，这些并不是所有生成器可做的作用，这还没有包括它们能做的最为重要的事情。</p>

<h4>生成器和异步代码</h4>

<p>这里有些我之前写的JS结束代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>      <span class="p">};</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>也许，你要你的代码中也看到类似的事情。<a href="http://www.html5rocks.com/en/tutorials/async/deferred/">异步API</a>  通常需要一个返回函数(callback)，这意味着你每次都需要写额外的匿名函数。所以，如果你使用超过三行的代码来做这三件事时，你则正在处理三层的内嵌代码结构。</p>

<p>下面是我写的些JS代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">}).</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;close&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>  <span class="nx">done</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">);</span>
</span><span class='line'><span class="p">}).</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">done</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>异步API 有单独的错误处理会话，而不是通过 Exception 来处理，不同的API拥有不同的会话。在多数用户的API中，错误通常会被安静地默认过滤掉。在某些，甚至连成功的完成操作也会被默认过滤掉。</p>

<p>到现在，这些问题可以通过异步编程来简单地解决。但是，我们不得不接受，异步代码并不像同步代码看起来简单、好理解。</p>

<p>生成器提供了新的希望而不一定要这方式（异步代码）。</p>

<p><code>Q.async()</code>是个实验性的方法，利用它有助于生成器通过<code>promise</code>来完成异步代码，其类似于返回型的异步代码。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// Synchronous code to make some noise.</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">makeNoise</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">shake</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">rattle</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">roll</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Asynchronous code to make some noise.</span>
</span><span class='line'><span class="c1">// Returns a Promise object that becomes resolved</span>
</span><span class='line'><span class="c1">// when we&#39;re done making noise.</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">makeNoise_async</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">Q</span><span class="p">.</span><span class="nx">async</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">yield</span> <span class="nx">shake_async</span><span class="p">();</span>
</span><span class='line'>     <span class="k">yield</span> <span class="nx">rattle_async</span><span class="p">();</span>
</span><span class='line'>     <span class="k">yield</span> <span class="nx">roll_async</span><span class="p">();</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>异步版本的代码主要的区别是必须在每个要调用的异步函数之前添加<code>yield</code>关键字。</p>

<p>如果在<code>Q.async</code>代码中，添加<code>if</code>表达式或者<code>try/catch</code>代码块时，就如普通的异步代码一般。相比于其它异步代码的方式，至少这看起来不会像是学习一种新语言。</p>

<p>如果你理解到现在所介绍的，你可能会喜欢 James Long 的 更为详细的文章<a href="http://jlongster.com/A-Study-on-Solving-Callbacks-with-JavaScript-Generators">A-Study-on-Solving-Callbacks-with-JavaScript-Generators</a>。</p>

<p>所以，生成器有助于进行异步编程，其更适合人类的大脑(思维方式)，这工作还要继续进行中。在这些工作中，有帮助的可能是更好的语法。<a href="https://github.com/lukehoban/ecmascript-asyncawait">A proposal for async functions</a> 同时利用<code>promise</code>和 生成器 来编程，这灵感来源于 C#，此已经在 ES7 的开发日程中。</p>

<h4>什么时候我可以用上这些疯狂的特性</h4>

<p>在服务端，你在 io.js 中现在就可以用上生成器了，或者 加上<code>--harmony</code>的Node命令行模式中。</p>

<p>对于浏览器来说，目前只有火狐27+和Chrome39+才支持ES6的生成器。现在为了使用生成器，你需要使用 <a href="http://babeljs.io/">Babel</a> 或 <a href="https://github.com/google/traceur-compiler#what-is-traceur">Traceur</a> ，将ES6的代码转为浏览器更为友好的ES5。</p>

<p>值得说明的是：JS中的生成器首先是由 Brendan Eich 实现的，他的设计接近于由 Icon 灵感而发的 Python 生成器。生成器在2006年被火狐2.0有提到，这标准化的路程是比较波折的，在这期间其语法和行为有了不少的变化。在火狐和Chrome中的ES6生成器是由极客 Andy Wingo 实现的，这是由 Bloomberg 支持的。</p>

<h4>yield</h4>

<p>对于生成器还有更多的东西要说的。我们还没有提到<code>.throw()</code>和<code>.return()</code>方法，<code>.next()</code>的可选参数，和 <code>yield*</code>语法。但是，我认为这文章已经够长的了，现在足够引起疑惑了。就如生成器一般，我们应该暂停一下，在以后的时间再继续 。</p>

<p>但是下一周，我们要变一下方向。我们这里已经连续说到了两上高级的主题了，难道还没有说ES6会改变你的生活吗？某些是不是有简单又很有用？某些是不是也会让你微笑？ES6 还有些这样的特性。</p>

<p>即将到来的特性会作用于你每天的代码编程，请下周加入我们，一起深入ES6的模板吧。</p>
]]></content>
  </entry>
  
</feed>
